<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[设计模式] 9.迭代器模式]]></title>
    <url>%2F2019%2F04%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.(它提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节)。 迭代器模式提供了遍历容器的方便性，容器只要管理增减元素就可以了，需要遍历时交由迭代器进行。迭代器模式中的各个角色： Iterator抽象迭代器：抽象迭代器负责定义访问和遍历元素的接口，而且基本上是有固定的3个方法： first()获得第一个元素； next()访问下一个元素； hasNext()是否已经访问到底部。 ConcreteIterator具体迭代器：具体迭代器角色要实现迭代器接口，完成容器元素的遍历。 Aggregate抽象容器：容器角色负责提供创建具体迭代器角色的接口，必然提供一个类似createIterator()这样的方法，在Java中一般是iterator()方法。 Concrete Aggregate具体容器：具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 抽象迭代器 */public interface Iterator &#123; // 遍历到下一个元素 Object next(); // 是否已经遍历到尾部 boolean hasNext(); // 删除当前指向的元素 boolean remove();&#125;/** * 具体迭代器 */public class ConcreteIterator implements Iterator &#123; private Vector vector = new Vector(); // 当前当前游标 public int cursor = 0; public ConcreteIterator(Vector vector)&#123; this.vector = vector; &#125; // 判断是否到达尾部 public boolean hasNext() &#123; return this.cursor != this.vector.size(); &#125; // 返回下一个元素 public Object next() &#123; Object result = null; if(this.hasNext()) &#123; result = this.vector.get(this.cursor++); &#125;else &#123; result = null; &#125; return result; &#125; // 删除当前元素 public boolean remove() &#123; this.vector.remove(this.cursor); return true; &#125;&#125;/** * 抽象容器 */public interface Aggregate &#123; public void add(Object object); public void remove(Object object); public Iterator iterator();&#125;/** * 具体容器 */public class ConcreteAggregate implements Aggregate &#123; // 容纳对象的容器 private Vector vector = new Vector(); // 增加一个元素 public void add(Object object) &#123; this.vector.add(object); &#125; // 返回迭代器对象 public Iterator iterator() &#123; return new ConcreteIterator(this.vector); &#125; // 删除一个元素 public void remove(Object object) &#123; this.remove(object); &#125;&#125;/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; // 声明容器 Aggregate agg = new ConcreteAggregate(); // 产生对象数据放进去 agg.add("abc"); agg.add("aaa"); agg.add("1234"); Iterator iterator = agg.iterator(); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 迭代模式的应用Java中继承了Iterable接口的类，已经帮我们实现了这个模式。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 8.原型模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.(用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象)。 原型模式的核心是一个clone方法，通过该方法进行对象的拷贝。 12345678910111213141516/** * 原型模式通用源码 */public class PrototypeClass implements Cloneable &#123; // 覆写父类Object方法 @Override public PrototypeClass clone() &#123; PrototypeClass prototypeClass = null; try &#123; prototypeClass = (PrototypeClass)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // 异常处理 &#125; return prototypeClass; &#125;&#125; 原型模式的优点 性能优良：原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好得多。 逃避构造函数的约束 使用场景 资源优化场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源。 性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑用原型模式拷贝多个对象供调用者使用。 注意事项 构造函数不会被执行 一个实现了Cloneable并重写了clone方法的类A，有一个无参构造或有参构造B，通过new关键字产生一个对象S，再然后通过S.clone()方式产生了一个新的对象T，那么在对象拷贝时，构造函数B是不会执行的。 12345678910111213141516171819202122232425262728293031/** * 简单的可拷贝对象 */public class Thing implements Cloneable &#123; public Thing() &#123; System.out.println("构造函数被执行了..."); &#125; @Override public Thing clone() &#123; Thing thing = null; try &#123; thing = (Thing)super.clone(); &#125; catch (CloneNotSupportException e) &#123; e.printStackTrace(;) &#125; return thing; &#125;&#125;/** * 简单的场景类 */public class Client &#123; public static void main(String[] args) &#123; // 产生一个对象 Thing thing = new Thing(); // 拷贝一个对象 Thing cloneThing = thing.clone(); &#125;&#125; 12输出结果:构造函数被执行了... 对象拷贝时构造函数确实没有被执行，这点从原理来讲也是可以讲的通的，Object类的clone方法的原理是从内存中(具体地说就是堆内存)以二进制流的方法进行拷贝，重新分配一个内存块，那构造函数没有被执行也是非常正常的了。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[踩坑指南] 1.Lists.transform修改无效问题]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97-1-Lists-transform%E4%BF%AE%E6%94%B9%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前段时间在工作中，发现了关于Lists.transform()方法的一些坑点。在一些情况下，会造成对Lists.transform返回的值更改无效的情况。 准备工作首先先创建一个Bean用来测试1234567891011121314151617// 这两个注解是lombok插件提供的，相当于手写Getter和Setter方法@Getter@Setterpublic class TestBean &#123; Integer testA; String testB; int testC; public TestBean() &#123; &#125; public TestBean(Integer testA, String testB, int testC) &#123; this.testA = testA; this.testB = testB; this.testC = testC; &#125;&#125; 测试首先，先看一下最简单的情况。创建一个ArrayList，然后将其中的Element加入到Lists.transform返回的集合中。12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String[] args) &#123; /** * 首先先创建几个bean进行测试 */ TestBean testBean1 = new TestBean(1, "1", 1); TestBean testBean2 = new TestBean(2, "2", 2); TestBean testBean3 = new TestBean(3, "3", 3); List&lt;TestBean&gt; testBeanList = Lists.newArrayList(testBean1, testBean2, testBean3); /** * 然后使用Lists.transform，这里只是简单的将testBeanList中的Element加到transFormList中 */ List&lt;TestBean&gt; transformList = Lists.transform(testBeanList, testBean -&gt; testBean); System.out.println("Transform List(第一次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); testBean.setTestA(999); testBean.setTestB("999"); testBean.setTestC(999); &#125;); System.out.println("\n-------------------------------------------\n"); System.out.println("Transform List(第二次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); &#125;); &#125;&#125; 123456789101112输出结果为Transform List(第一次):testBean Address :TestBean@27bc2616 testA:1 testB:1 testC:1testBean Address :TestBean@3941a79c testA:2 testB:2 testC:2testBean Address :TestBean@506e1b77 testA:3 testB:3 testC:3-------------------------------------------Transform List(第二次):testBean Address :TestBean@27bc2616 testA:999 testB:999 testC:999testBean Address :TestBean@3941a79c testA:999 testB:999 testC:999testBean Address :TestBean@506e1b77 testA:999 testB:999 testC:999 可以发现，在这个例子中对lists.transform元素进行修改是成功的。 接下来再看下面的例子。在将testBeanList中的字段添加到transformList中时，新建一个Bean并加入到transform集合中，而不是加入原有的Bean。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test &#123; public static void main(String[] args) &#123; /** * 首先我们先创建几个bean进行测试 */ TestBean testBean1 = new TestBean(1, "1", 1); TestBean testBean2 = new TestBean(2, "2", 2); TestBean testBean3 = new TestBean(3, "3", 3); List&lt;TestBean&gt; testBeanList = Lists.newArrayList(testBean1, testBean2, testBean3); /** * 然后使用Lists.transform */ List&lt;TestBean&gt; transformList = Lists.transform(testBeanList, testBean -&gt; &#123; TestBean tempTestBean = new TestBean(); tempTestBean.setTestA(testBean.getTestA()); tempTestBean.setTestB(testBean.getTestB()); tempTestBean.setTestC(testBean.getTestC()); return tempTestBean; &#125;); System.out.println("Transform List(第一次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); testBean.setTestA(999); testBean.setTestB("999"); testBean.setTestC(999); &#125;); System.out.println("\n-------------------------------------------\n"); System.out.println("Transform List(第二次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); &#125;); &#125;&#125; 123456789101112输出结果为：Transform List(第一次):testBean Address :TestBean@27bc2616 testA:1 testB:1 testC:1testBean Address :TestBean@3941a79c testA:2 testB:2 testC:2testBean Address :TestBean@506e1b77 testA:3 testB:3 testC:3-------------------------------------------Transform List(第二次):testBean Address :TestBean@9807454 testA:1 testB:1 testC:1testBean Address :TestBean@3d494fbf testA:2 testB:2 testC:2testBean Address :TestBean@1ddc4ec2 testA:3 testB:3 testC:3 可以发现修改失败了。通过打印的日志，可以看出， 两次遍历transformList的过程中，遍历到的Bean的地址是不同的第一次为：27bc2616，3941a79c，506e1b77第二次为：9807454，3d494fbf，1ddc4ec2两次遍历的地址都不一样，那结果不一样当然是可能的。但是为什么对于同一个List，两次遍历会是不同的地址。再看下面的代码，这次我们将赋值的过程也打印出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Test &#123; public static void main(String[] args) &#123; /** * 首先我们先创建几个bean进行测试 */ TestBean testBean1 = new TestBean(1, "1", 1); TestBean testBean2 = new TestBean(2, "2", 2); TestBean testBean3 = new TestBean(3, "3", 3); List&lt;TestBean&gt; testBeanList = Lists.newArrayList(testBean1, testBean2, testBean3); /** * 然后使用Lists.transform */ List&lt;TestBean&gt; transformList = Lists.transform(testBeanList, testBean -&gt; &#123; TestBean tempTestBean = new TestBean(); tempTestBean.setTestA(testBean.getTestA()); tempTestBean.setTestB(testBean.getTestB()); tempTestBean.setTestC(testBean.getTestC()); System.out.print("---tempTestBean Address :" + tempTestBean.toString() + " "); System.out.print("---testA:" + tempTestBean.getTestA() + " "); System.out.print("---testB:" + tempTestBean.getTestB() + " "); System.out.println("---testC:" + tempTestBean.getTestC()); return tempTestBean; &#125;); System.out.println("Transform List(第一次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); testBean.setTestA(999); testBean.setTestB("999"); testBean.setTestC(999); &#125;); System.out.println("\n-------------------------------------------\n"); System.out.println("Transform List(第二次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); &#125;); &#125;&#125; 123456789101112131415161718输出结果Transform List(第一次):---tempTestBean Address :TestBean@3dd3bcd ---testA:1 ---testB:1 ---testC:1testBean Address :TestBean@3dd3bcd testA:1 testB:1 testC:1---tempTestBean Address :TestBean@97e1986 ---testA:2 ---testB:2 ---testC:2testBean Address :TestBean@97e1986 testA:2 testB:2 testC:2---tempTestBean Address :TestBean@26f67b76 ---testA:3 ---testB:3 ---testC:3testBean Address :TestBean@26f67b76 testA:3 testB:3 testC:3-------------------------------------------Transform List(第二次):---tempTestBean Address :TestBean@7f560810 ---testA:1 ---testB:1 ---testC:1testBean Address :TestBean@7f560810 testA:1 testB:1 testC:1---tempTestBean Address :TestBean@69d9c55 ---testA:2 ---testB:2 ---testC:2testBean Address :TestBean@69d9c55 testA:2 testB:2 testC:2---tempTestBean Address :TestBean@13a57a3b ---testA:3 ---testB:3 ---testC:3testBean Address :TestBean@13a57a3b testA:3 testB:3 testC:3 发现输出结果非常奇怪，为什么复制过程执行了两次，而且没有按顺序执行，好像也不是异步执行。 可以发现每次复制操作后，都会跟着一个后来的遍历操作，而且复制操作打印出来的Bean的地址和遍历时Bean的地址是一模一样的。出现这种现象的原因就是因为Guava中常用的懒加载导致的(具体原理可见Guava懒加载原理)。所以Lists.transform()方法并不是在调用处执行，而是在每次使用它返回的结果，也就是例子中transformList的时候，才会执行，这样就解释了为什么会有这种输出结果，而且改动不生效的原因了。 那么为什么本文中的第一个示例成功了呢。因为，只是直接返回了一个原始的Bean，并没有返回新建的Bean。那么虽然是懒加载，但是每次返回的都是同样的Bean也就不存在地址不同的问题了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; /** * 首先我们先创建几个bean进行测试 */ TestBean testBean1 = new TestBean(1, "1", 1); TestBean testBean2 = new TestBean(2, "2", 2); TestBean testBean3 = new TestBean(3, "3", 3); List&lt;TestBean&gt; testBeanList = Lists.newArrayList(testBean1, testBean2, testBean3); /** * 然后使用Lists.transform */ List&lt;TestBean&gt; transformList = Lists.transform(testBeanList, testBean -&gt; &#123; System.out.print("---testBean Address :" + testBean.toString() + " "); System.out.print("---testA:" + testBean.getTestA() + " "); System.out.print("---testB:" + testBean.getTestB() + " "); System.out.println("---testC:" + testBean.getTestC()); return testBean; &#125;); System.out.println("Transform List(第一次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); testBean.setTestA(999); testBean.setTestB("999"); testBean.setTestC(999); &#125;); System.out.println("\n-------------------------------------------\n"); System.out.println("Transform List(第二次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); &#125;); &#125;&#125; 1234567891011121314151617Transform List(第一次):---testBean Address :TestBean@27bc2616 ---testA:1 ---testB:1 ---testC:1testBean Address :TestBean@27bc2616 testA:1 testB:1 testC:1---testBean Address :TestBean@3941a79c ---testA:2 ---testB:2 ---testC:2testBean Address :TestBean@3941a79c testA:2 testB:2 testC:2---testBean Address :TestBean@506e1b77 ---testA:3 ---testB:3 ---testC:3testBean Address :TestBean@506e1b77 testA:3 testB:3 testC:3-------------------------------------------Transform List(第二次):---testBean Address :TestBean@27bc2616 ---testA:999 ---testB:999 ---testC:999testBean Address :TestBean@27bc2616 testA:999 testB:999 testC:999---testBean Address :TestBean@3941a79c ---testA:999 ---testB:999 ---testC:999testBean Address :TestBean@3941a79c testA:999 testB:999 testC:999---testBean Address :TestBean@506e1b77 ---testA:999 ---testB:999 ---testC:999testBean Address :TestBean@506e1b77 testA:999 testB:999 testC:999 可以发现正如猜想的一样，每次返回的都是同样的地址。 推荐阅读Guava懒加载原理]]></content>
      <categories>
        <category>踩坑指南</category>
      </categories>
      <tags>
        <tag>踩坑指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 7.模板方法模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redifine certain steps of an algorithm without changing the algorithm’s structure.(定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤)。 其中AbstractClass叫做抽象模板，它的方法分两类： 基本方法：也叫基本操作，是由子类实现的方法，在模板方法被调用。 模板方法：可以有多个，实现对基本方法的调度。 一般模板方法被加上final防止被覆写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 抽象模板类 */public abstract class AbstractClass &#123; // 基本方法 protected abstract void doSomething(); // 基本方法 protected abstract void doAnything(); // 模板方法 public void templateMethod() &#123; /** * 调用基本方法，完成相关的逻辑 */ this.doAnything(); this.doSomething(); &#125;&#125;/** * 具体模板类 */public class ConcreteClass1 extends AbstractClass &#123; // 实现基本方法 protected void doAnthing() &#123; // 业务逻辑处理 &#125; protected void doSomething() &#123; // 业务逻辑处理 &#125;&#125;public class ConcreteClass2 extends AbstractClass &#123; // 实现基本方法 protected void doAnthing() &#123; // 业务逻辑处理 &#125; protected void doSomething() &#123; // 业务逻辑处理 &#125;&#125;/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; AbstractClass class1 = new ConcreteClass1(); AbstractClass class2 = new ConcreteClass2(); // 调用模板方法 class1.templateMethod(); class2.templateMethod(); &#125;&#125; 优点 封装不变部分，扩展可变部分 提取公共代码，便于维护 行为由父类控制，子类实现 缺点 子类对父类造成了影响(子类执行的结果影响了父类的结果) 使用场景 多个子类有共有的方法，且逻辑基本相同时 复杂算法，核心逻辑可设计为模板方法 相同代码抽取到父类中，然后通过钩子函数约束行为 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 6.装饰模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Attach additional responsibilities to an object dynamically keeping the same interface. Decorators procide a flexible alternative to subclassing for extending functionaility.(动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活)。 有四个角色需要说明： Component抽象构件：Component是一个接口或者是抽象类，就是最原始的对象。 ConcreteComponent具体构件：是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。 Decorator装饰角色：一般是一个抽象类，实现接口或者抽象方法，它属性里必然有一个private变量指向Component抽象构件。 ConcreteDecorator具体装饰角色：把最核心的，最原始的，最基本的东西装饰成其他东西。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 抽象构件 */ public abstract class Component &#123; // 抽象方法 public abstract void operate();&#125;/** * 具体构件 */public class ConcreteComponent extends Component &#123; // 具体实现 @Override public void operate() &#123; System.out.println("do Something"); &#125;&#125;/** * 抽象装饰者 */public abstract class Decorator extends Component &#123; private Component component = null; // 通过构造函数传递被修饰者 public Decorator (Component component) &#123; this.component = component; &#125; // 委托给被修饰者执行 @Override public void operate() &#123; this.component.operate(); &#125;&#125;/** * 具体的装饰类 */public class ConcreteDecorator1 extends Decorator &#123; // 定义被修饰者 public ConcreteDecorator1(Component component)&#123; super(component); &#125; //定义自己的修饰方法 private void method1()&#123; System.out.println("method1 修饰"); &#125;//重写父类的Operation方法 public void operate()&#123; this.method1(); super.operate(); &#125;&#125;public class ConcreteDecorator2 extends Decorator &#123; // 定义被修饰者 public ConcreteDecorator2(Component component)&#123; super(component); &#125; // 定义自己的修饰方法 private void method2()&#123; System.out.println("method2修饰"); &#125; // 重写父类的Operation方法 public void operate()&#123; super.operate(); this.method2(); &#125;&#125; 1234567891011121314/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; Component component = new Component(); // 第一次装饰 component = new ConcreteDecorator1(component); // 第二次装饰 component = new ConcreteDecorator2(component); // 修饰后运行 component.operate(); &#125;&#125; 装饰模式优点 装饰类和被装饰类可以独立发展，不会耦合。 是继承关系的替代方案。 可以动态地扩展一个实现类的功能。 装饰模式缺点 多层装饰比较复杂。 使用场景 需要扩展一个类的功能，或给一个类增加附加功能。 需要动态地给一个对象增加功能，这些功能可以在动态的撤销。 需要为一批的兄弟类进行改装或加装功能。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 5.责任链模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Avoid coupling the sender of a request to its receiver by giving more than one object by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handle it.(使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止)。 123456789101112131415161718192021222324252627282930313233343536/** * 抽象处理者 */public abstract class Handler &#123; private Handler nextHandler; // 每个处理者都必须对请求做出处理 public final Response handleMessage(Request request) &#123; Response response = null; // 判断是否是自己的处理级别 if(this.getHandlerLevel().equals(request.getRequestLevel()) &#123; response = this.echo(request); &#125; else &#123; // 不属于自己的处理级别 // 判断是否有下一个处理者 if (this.nextHandler != null) &#123; response = this.nextHandler.handleMessage(request); &#125; else &#123; // 没有适当的处理者， 业务自行处理 &#125; &#125; return response; &#125; // 设置下一个处理者是谁 public void setNext(Handler _handler) &#123; this.nextHandler = _handler; &#125; // 每个处理者都有一个处理级别 protected abstract Level getHandlerLevel(); // 每个处理者都必须实现处理任务 protected abstract Response echo(Request request);&#125; 抽象处理着实现三个职责： 定义一个请求的处理方法handleMessage，唯一对外开放的方法； 定义一个链的编排方法setNext，设置下一个处理者； 定义了具体请求者必须实现的两个方法：定义自己能够处理的级别getHandlerLevel和具体的处理任务echo； 注意handleMessage方法的final关键字 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 具体处理者 */public class ConcreteHandler1 extends Handler &#123; // 定义自己的处理逻辑 protected Response echo(Request request) &#123; // 完成处理逻辑 return null; &#125; // 设置自己的处理级别 protected Level getHandlerLevel() &#123; // 设置自己的处理级别 return null; &#125;&#125; public class ConcreteHandler2 extends Handler &#123; // 定义自己的处理逻辑 protected Response echo(Request request) &#123; // 完成处理逻辑 return null; &#125; // 设置自己的处理级别 protected Level getHandlerLevel() &#123; // 设置自己的处理级别 return null; &#125;&#125;public class ConcreteHandler3 extends Handler &#123; // 定义自己的处理逻辑 protected Response echo(Request request) &#123; //完成处理逻辑 return null; &#125; // 设置自己的处理级别 protected Level getHandlerLevel() &#123; // 设置自己的处理级别 return null; &#125;&#125; 123456789101112131415161718/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; // 声明所有的处理节点 Handler handler1 = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); Handler handler3 = new ConcreteHandler3(); // 设置链中的阶段顺序1--&gt;2--&gt;3 handler1.setNext(handler2); handler2.setNext(handler3); // 提交请求， 返回结果 Response response = handler1.handlerMessage(new Request()); &#125;&#125; 责任链的优点 将请求和处理分开。请求者不必知道是谁处理的。 责任链的缺点 性能问题，每个请求都从链头到链尾遍历。 责任链的注意事项 限制结点数量，避免出现超长链。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 4.建造者模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Separate the construction of a complex object from its representation so that the same construction process can create different representations.(将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示) Product产品类：通常是实现类模板方法模式。 Builder抽象建造者：规范产品的组建，一般是由子类实现。 ConcreteBuilder具体建造者：实现抽象类定义的所有方法，并且返回一个组建好的对象。 Director导演类：负责安排已有模块的顺序，然后告诉Builder开始建造。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 产品类 */public class Product &#123; public void doSomething() &#123; // 独立业务处理 &#125;&#125;/** * 抽象建造者 */public abstract class Builder &#123; // 设置产品的不同部分，以获得不同的产品 public abstract void setPart(); // 建造产品 public abstract Product buildProduct();&#125;/** * 具体建造者 */public class ConcreteProduct extends Builder &#123; private Product product = new Product(); // 设置产品零件 public void setPart() &#123; /** * 产品类的逻辑处理 */ &#125; // 组建一个产品 public Product buildProduct() &#123; return product; &#125;&#125;/** * 导演类 */public class Director &#123; private Builder builder = new ConcreteBuilder(); // 构造不同的产品 public Product getAProduct() &#123; builder.setPart(); /** * 设置不同的零件，产生不同的产品 */ return builder.buildProduct(); &#125;&#125; 建造者模式的优点 封装性：使用建造者模式可以使客户端不必知道产品内部的组成细节。 建造者独立，容易扩展。 建造者模式使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。 多个零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，可以使用建造者模式。 注意事项建造者模式关注的是零件类型和顺序。 事例生产不同车辆，不同车辆的启动顺序不同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 相当于Product，只不过对其又进行了一次抽象public abstract class CarModel &#123; // 这个参数是各个基本方法执行的顺序 private ArrayList&lt;String&gt; sequence = new ArrayList&lt;String&gt;(); // 模型是启动开始跑了 protected abstract void start(); // 能发动， 还要能停下来， 那才是真本事 protected abstract void stop(); // 喇叭会出声音， 是滴滴叫， 还是哔哔叫 protected abstract void alarm(); // 引擎会轰隆隆地响， 不响那是假的 protected abstract void engineBoom(); // 那模型应该会跑吧， 别管是人推的， 还是电力驱动， 总之要会跑 final public void run() &#123; //循环一遍， 谁在前， 就先执行谁 for(int i=0;i&lt;this.sequence.size();i++)&#123; String actionName = this.sequence.get(i); if (actionName.equalsIgnoreCase("start")) &#123; this.start(); // 启动汽车 &#125; else if (actionName.equalsIgnoreCase("stop")) &#123; this.stop(); // 停止汽车 &#125; else if (actionName.equalsIgnoreCase("alarm")) &#123; this.alarm(); // 喇叭开始叫了 &#125; else if (actionName.equalsIgnoreCase("engine boom")) &#123; // 如果是engine boom关键 this.engineBoom(); // 引擎开始轰鸣 &#125; &#125; &#125; //把传递过来的值传递到类内 final public void setSequence(ArrayList sequence) &#123; this.sequence = sequence; &#125;&#125;// 产品类public class BenzModel extends CarModel &#123; protected void alarm() &#123; System.out.println("奔驰车的喇叭声音是这个样子的..."); &#125; protected void engineBoom() &#123; System.out.println("奔驰车的引擎是这个声音的..."); &#125; protected void start() &#123; System.out.println("奔驰车跑起来是这个样子的..."); &#125; protected void stop() &#123; System.out.println("奔驰车应该这样停车..."); &#125; &#125;// 产品类public class BMWModel extends CarModel &#123; protected void alarm() &#123; System.out.println("宝马车的喇叭声音是这个样子的..."); &#125; protected void engineBoom() &#123; System.out.println("宝马车的引擎是这个声音的..."); &#125; protected void start() &#123; System.out.println("宝马车跑起来是这个样子的..."); &#125; protected void stop() &#123; System.out.println("宝马车应该这样停车..."); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/** * 抽象建造者 */public abstract class CarBuilder &#123; // 建造一个模型， 你要给我一个顺序要求， 就是组装顺序 public abstract void setSequence(ArrayList&lt;String&gt; sequence); // 设置完毕顺序后， 就可以直接拿到这个车辆模型 public abstract CarModel getCarModel();&#125;/** * 具体建造者 */public class BenzBuilder extends CarBuilder &#123; private BenzModel benz = new BenzModel(); public CarModel getCarModel() &#123; return this.benz; &#125; public void setSequence(ArrayList&lt;String&gt; sequence) &#123; this.benz.setSequence(sequence); &#125;&#125;/** * 具体建造者 */public class BMWBuilder extends CarBuilder &#123; private BMWModel bmw = new BMWModel(); public CarModel getCarModel() &#123; return this.bmw; &#125; public void setSequence(ArrayList&lt;String&gt; sequence) &#123; this.bmw.setSequence(sequence); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 导演类 */ public class Director &#123; private ArrayList&lt;String&gt; sequence = new ArrayList(); private BenzBuilder benzBuilder = new BenzBuilder(); private BMWBuilder bmwBuilder = new BMWBuilder(); /* * A类型的奔驰车模型， 先start， 然后stop， 其他什么引擎、 喇叭一概没有 */ public BenzModel getABenzModel() &#123; // 清理场景， 这里是一些初级程序员不注意的地方 this.sequence.clear(); // ABenzModel的执行顺序 this.sequence.add("start"); this.sequence.add("stop"); // 按照顺序返回一个奔驰车 this.benzBuilder.setSequence(this.sequence); return (BenzModel) this.benzBuilder.getCarModel(); &#125; /** * B型号的奔驰车模型，是先发动引擎，然后启动，然后停止，没有喇叭 */ public BenzModel getBBenzModel() &#123; this.sequence.clear(); this.sequence.add("engine boom"); this.sequence.add("start"); this.sequence.add("stop"); this.benzBuilder.setSequence(this.sequence); return (BenzModel) this.benzBuilder.getCarModel(); &#125; /** * C型号的宝马车是先按下喇叭（炫耀嘛） ，然后启动，然后停止 */ public BMWModel getCBMWModel() &#123; this.sequence.clear(); this.sequence.add("alarm"); this.sequence.add("start"); this.sequence.add("stop"); this.bmwBuilder.setSequence(this.sequence); return (BMWModel) this.bmwBuilder.getCarModel(); &#125; /** * D类型的宝马车只有一个功能，就是跑，启动起来就跑，永远不停止 */ public BMWModel getDBMWModel() &#123; this.sequence.clear(); this.sequence.add("start"); this.bmwBuilder.setSequence(this.sequence); return (BMWModel) this.benzBuilder.getCarModel(); &#125;&#125; 1234567891011121314151617181920/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; Director director = new Director(); // 1万辆A类型的奔驰车 for (int i = 0; i &lt; 10000; i++) &#123; director.getABenzModel().run(); &#125; // 100万辆B类型的奔驰车 for (int i = 0; i &lt; 1000000; i++) &#123; director.getBBenzModel().run(); &#125; // 1000万辆C类型的宝马车 for (int i = 0; i &lt; 10000000; i++) &#123; director.getCBMWModel().run(); &#125; &#125;&#125; 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 3.抽象工厂模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Provide an interface for creating families of related or dependent objects without specifying their concrete classes.(为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 抽象产品类 */public abstract class AbstractProductA &#123; // 每个产品共有的方法 public void shareMethod() &#123;&#125; // 每个产品相同方法，不同实现 public abstract void doSomething();&#125;/** * 产品A1的实现类 */ public class ProductA1 extends AbstractProductA &#123; public void doSomething() &#123; System.out.println("产品A1的实现方法"); &#125;&#125;/** * 产品A2的实现类 */public class ProductA2 extends AbstractProduct &#123; public void doSomething() &#123; System.out.println("产品A2的实现方法"); &#125;&#125;/** * 抽象工厂类，有N个产品族，在抽象工厂类中就应该有N个创建方法 */public abstract class AbstractCreator &#123; // 创建A产品家族 public abstract AbstractProductA createProductA(); // 创建B产品家族 public abstract AbstractProductB createProductB();&#125;/** * 产品等级1的实现类，有M个产品等级就应该有M个实现工厂类，在每个实现工厂中， * 实现不同产品族的生产任务 */public class Creator1 extends AbstractCreator &#123; // 只生产产品等级为1的产品 public AbstractProductA creatorProductA() &#123; return new ProductA1(); &#125; // 只生产产品等级为2的产品 public AbstractProductB creatorProductB() &#123; return new ProductA2(); &#125;&#125;/** * 产品等级2的实现类 */public class Creator2 extends AbstractCreator &#123; // 只生产产品等级为2的A产品 public AbstractProductA createProductA() &#123; return new ProductA2(); &#125; // 只生产产品等级为2的B产品 public AbstractProductB createProductB() &#123; return new ProductB2(); &#125;&#125;/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; // 定义两个工厂 AbstractCreator creator1 = new Creator1(); AbstractCreator creator2 = new Creator2(); // 产生A1对象 AbstractProductA a1 = creator1.createProductA(); // 产生A2对象 AbstractProductA a2 = creator2.createProductA(); // 产生B1对象 AbstractProductB b1 = creator1.createProductB(); // 产生B2对象 AbstractProductB b2 = creator2.createProductB(); &#125;&#125; 抽象工厂模式的缺点产品族扩展非常困难 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 2.工厂方法模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Define an interface for creating an object, but let subclassed decide with class to instantiate. Factory Method lets a class defer instantiation to subclasses.(定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类)。 抽象产品类Product负责定义产品的共性，实现对事务最抽象的定义; 抽象创建类Creator也就是抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。 12345678910/** * 抽象产品类 */public abstract class Product &#123; // 产品类的公共方法 public void method1() &#123;&#125; // 抽象方法 public abstract void method2() &#123;&#125;&#125; 1234567891011121314/** * 具体产品类 */public class ConcreteProduct1 extends Product &#123; public void method2() &#123; // 业务逻辑处理 &#125;&#125;public class ConcreteProduct2 extends Product &#123; public void method2() &#123; // 业务逻辑处理 &#125;&#125; 1234567/** * 抽象工厂类 */public abstract class Creator &#123; // 创建一个产品对象，其输入参数类型可以自行设置 public abstract &lt;T extends Product&gt; T createProduct (Class&lt;T&gt; c);&#125; 1234567891011121314/** * 具体工厂类，具体如何产生一个产品对象 */public class ConcreteCreator extends Creator &#123; public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c)&#123; Product product = null; try &#123; product = (Product) Class.forName (c.getName()).newInstance(); &#125;catch (Exception e)&#123; // 异常处理 &#125; return (T) product; &#125;&#125; 123456789101112/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; Creator creator = new ConcreteCreator(); Product product = creator.createProduct(ConcreteProduct1.class); /** * 继续业务处理 */ &#125;&#125; 工厂方法模式的优点： 工厂类不用任何修改就可以完成系统扩展。 屏蔽产品类，产品类实现如何变化，调用者都不需要关心。 工厂模式使用场景： 在所有需要生成对象的地方都可以使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码复杂度。 需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。例如，设计一个邮件服务器，有3中网络协议：POP3、IMAP、HTTP，我们可以把这三种方法作为产品类 工厂模式的扩展： 简单工厂模式：一个模块仅需要一个工厂类，没必要把它生产出来，可以使用静态方法。缺点是扩展困难。 12345678910111213141516/** * 工厂类 */ public class HumanFactory &#123; public static &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c) &#123; // 定义一个生产出的人种 Human human = null; try &#123; // 产生一个人种 human = (Human) Class.forname(c.getName()).newInstance(); &#125; catch (Exception e) &#123; System.out.println("人种生成错误"); &#125; return (T)human; &#125;&#125; 12345678910/** * 场景类 */public class NvWa &#123; public static void main(String[] args) &#123; Human whiteHuman = HumanFactory.createHuman(WhiteHuman.class); Human blackHuman = HumanFactory.createHuman(BlackHuman.class); Human yellowHuman = HumanFactory.createHuman(YellowHuman.class); &#125;&#125; 多个工厂类：为每个产品定义一个创造者，然后由调用者去选择与哪个工厂方法关联 1234567/** * 多工厂模式的抽象工厂类, 抽象方法中已经不再需要传递相关参数了，因为每一个具体的 * 的工厂都已经非常明确自己的职责，创建自己负责的产品类对象。 */ public abstract class AbstractHumanFactory &#123; public abstract Human createHuman();&#125; 12345678/** * 黑色人种创建工厂实现 */public class BlackHumanFactory extentds AbstractHumanFactory &#123; public Human createHuman() &#123; return new BlackHuman(); &#125;&#125; 12345678/** * 黄色人种创建工厂实现 */ public class YellowHumanFactory extends AbstractHumanFactory &#123; public Human createHuman() &#123; return new YellowHuman(); &#125;&#125; 12345678/** * 白色人种创建工厂实现 */public class WhiteHumanFactroy extends AbstractHumanFactory &#123; public Human createHuman() &#123; return new WhiteHuman(); &#125;&#125; 12345678910/** * 场景类 */public class NvWa &#123; public static void main(String[] args)&#123; Human whiteHuman = (new WhiteHumanFactory()).createHuman(); Human blackHuman = (new BlackHumanFactory()).createHuman(); Human yellowHuman = (new YellowHumanFactory()).createHuman(); &#125;&#125; 替代单例模式 12345678910/** * 单例类 */public class Singleton &#123; // 不允许通过new产生一个对象 private Singleton() &#123;&#125; public void doSomething() &#123; 业务处理 &#125;&#125; 1234567891011121314151617181920212223/** * 负责生成单例的工厂类 */public class SingletonFactory &#123; private static Singleton singleton; static &#123; try &#123; Class clazz = Class.forName(Singleton.class.getName()); // 获得无参构造 Constructor constructor = clazz.getDeclaredConstructor(); // 设置无参构造是可访问的 constructor.setAccessible(true); // 产生一个实例对象 singletion = (Singleton) constructor.newInstance(); &#125; catch (Exection e)&#123; // 异常 &#125; &#125; public static Singleton getSingleton() &#123; return singleton; &#125;&#125; 延迟初始化一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。ProductFactory负责产品类对象的创建工作，并且通过prMap变量产生一个缓存，对需要再次被重用的对象保留，Product和ConcreteProduct是一个示例代码。 {% asset_img 延迟初始化通用类图.png 延迟初始化通用类图 %} 1234567891011121314151617public class ProductFactory &#123; private static final Map&lt;String, String&gt; prMap = new HashMap(); public static synchronized Product createProduct(String type) throws Exception &#123; Product product = null; // 如果Map中已经有这个对象 if (prMap.containsKey(type))&#123; product = prMap.get(type); &#125;else &#123; if (type.equals("Product1")) &#123; product = new ConcreteProduct1(); &#125;else&#123; product = new ConcreteProduct2(); &#125; &#125; return product; &#125;&#125; 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 1.单例模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一个类只能生成一个对象，所有对象对它的依赖都是相同的。通过定义一个私有访问权限的构造函数，避免被其他类new出一个对象，而该类自己可以new出一个对象，其他类可以通过getInstance获得同一个对象 Ensure a class has only one instance, and provide a global point of access to it.(确保某一个类只有一个实例，并且自行实例化并向整个系统提供这个实例)。 饿汉式单例：第一次引用该类的时候就创建对象实例，无法延迟加载。12345678910111213public class Singleton &#123; private static final Singleton singleton = new Singleton(); // 限制产生多个对象 private Singletion () &#123;&#125; // 通过该方法获得实例对象 public static Singleton getSingleton() &#123; return singleton; &#125; // 类中其他方法，尽量使static public static void doSomething() &#123; &#125;&#125; 懒汉式单例：可以做到延迟加载，但是线程不安全。如果有两条线程同时调用getSingleton()方法，就有可能导致重复创建对象。 123456789101112131415/** * 懒汉式单例。 */ public class Singleton &#123; private static Singleton singleton = null; // 限制产生多个对象 private Sigleton()&#123;&#125; // 通过该方法获得实例对象 public static synchronized Singleton getSingleton() &#123; if (singleton == null)&#123; singleton = new Singleton(); &#125; return singleton; &#125; &#125; 考虑线程安全, 缺点是效率低下，无法实际应用。 123456789101112public class Singleton &#123; private static volatile Singleton singleton = null; private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; return singleton; &#125;&#125; 兼顾线程安全和效率的写法, 缺点是在jdk1.5之前，volatile无法避免重排序所导致的问题。 1234567891011121314public class Singleton &#123; private static volatile Singleton singleton = null; private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null)&#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 静态内部类法, 需要额外的工作(Serializable、transient、readResolve)来实现序列化，否则每次反序列化一个序列化的对象实例时都会创建一个新的实例。可能会有人使用反射强行调用私有构造器(如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常)。 1234567891011public class Singleton &#123; private static class Holder &#123; private static Singleton singleton = new Singleton(); &#125; private Singleton() &#123;&#125;; public static Singleton getSingleton() &#123; return Holder.singleton; &#125;&#125; 枚举写法：使用枚举除了线程安全和防止反射强行调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。 12345678910public enum Singleton &#123; INSTANCE; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 单例模式的优点 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建，销毁时，而且创建或销毁时性能又无法优化，单例模式就很好。 由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用驻留内存的方式来解决(在JAava EE中采用单例模式时需要注意JVM垃圾回收机制)。 单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。 单例模式可以在系统设置全局的访问点，优化和共享资源访问。 Bean为单例模式，可以方便的管理生命周期。 单例模式的缺点 单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。 单例与单一职责原则有冲突。 使用场景在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现”不良反应”。可以采用单例模式，例如： 生成唯一系列号。 在整个项目需要一个共享访问点或共享数据，例如一个web页面上的计数器。 创建一个对象需要消耗的资源过多，例如IO和访问数据库。 需要定义大量的静态常量和静态方法的环境。 注意事项 要考虑对象复制，在Java中，对象默认是不可以被复制的，若实现Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象复制是不可调用类的构造函数，因此即使是私有的构造函数，对象仍然可以被复制。最好解决方法是单例类不要实现Cloneable接口。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 16.3Sum Closest]]></title>
    <url>%2F2018%2F12%2F15%2FLeetCode-16-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个包含n个整数的数组和一个target数，找出数组中3个和与target数最接近的数，并返回它们的和。你可以假设只有一种特定的答案。 例子： 输入: [-1, 2, 1, -4], target = 1. 输出：2 解释: -1 + 2 + 1 = 2 最接近 解题方法首先将nums数组排序，然后使用一个指针i从头遍历数组，对于元素i有以下两种可能： 如果i = 0或者nums[i] != nums[i-1]：使用两个指针left，right分别指向i+1和数组最后一个元素，然后用nums[left] + nums[right]和-nums[i]相比。 使用一个temp记录最接近的和是多少 i元素与i-1元素相等，则i向后移，避免选取重复三元组。最后返回和为temp对应的三个数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution&#123; public: int threeSumClosest(vector&lt;int&gt; &amp;nums, int target) &#123; int close = 2147483647; int output = 0; if (nums.size() &lt;= 2) return 0; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size() - 2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123; int sum = target - nums[i]; int left = i + 1, right = nums.size() - 1; while (left &lt; right) &#123; int temp = abs(sum - nums[left] - nums[right]); if (temp == 0) return target; else if (temp &lt; close) &#123; close = temp; output = nums[i] + nums[left] + nums[right]; &#125; if (nums[left] + nums[right] == sum) &#123; while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; left++; right--; &#125; else if (nums[left] + nums[right] &gt; sum) right--; else left++; &#125; &#125; &#125; return output; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 15.3Sum]]></title>
    <url>%2F2018%2F12%2F15%2FLeetCode-15-3Sum%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个包含n个整数的数组，从数组中找出三个元素a, b, c使a + b + c = 0。找出数组中所有可能的组合。 注意：返回的集合中不能有重复的三元组 例子: 输入: [-1, 0, 1, 2, -1, -4], 输出: [ [-1, 0, 1], [-1, -1, 2] ] 解题方法首先将数组nums排序，然后使用一个指针i从头遍历数组，对于元素i有以下两种可能： 如果i = 0或者nums[i] != nums[i-1]：使用两个指针left，right分别指向i+1和数组最后一个元素，然后用nums[left] + nums[right]和-nums[i]相比。 如果nums[left] + nums[right] = -nums[i]，就将三个数加入到输出中。 如果nums[left] + nums[right] &gt; -nums[i]，就将right左移。 如果nums[left] + nums[right] &lt; -nums[i]，就将left右移。 i元素与i-1元素相等，则i向后移，避免选取重复三元组。直到所有输出都被找到 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution&#123; public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; &amp;nums) &#123; vector&lt;int&gt; A; vector&lt;vector&lt;int&gt;&gt; B; if (nums.size() &lt;= 2) return B; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size() - 2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123; int sum = 0 - nums[i]; int left = i + 1, right = nums.size() - 1; while (left &lt; right) &#123; if (nums[left] + nums[right] == sum) &#123; A.push_back(nums[i]); A.push_back(nums[left]); A.push_back(nums[right]); B.push_back(A); A.clear(); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; left++; right--; &#125; else if (nums[left] + nums[right] &gt; sum) right--; else left++; &#125; &#125; &#125; return B; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 13.Roman to Integer]]></title>
    <url>%2F2018%2F12%2F14%2FLeetCode-13-Roman-to-Integer%2F</url>
    <content type="text"><![CDATA[题目翻译罗马数字是用以下7种字符表示的：I, V, X, L, C, D 和 M. 字符 值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 举例来说，2在罗马数字中用II表示，12用XII表示，27写作XXVII 罗马数字通常将最大数写在最左，较小数写在右面。但是数字4的写法并不是IIII而是IV。因为1在5之前，我们就用5减去它，变成4。同样，这个规则对9也适用，9被写作IX 有六个使用减法的实例： I 可以被放在 V (5) 和 X (10) 之前就变成了 4 和 9. X 可以被放在 L (50) 和 C (100) 之前就变成了 40 和 90. C 可以被放在 D (500) 和 M (1000) 之前就变成了 400 and 900. 给定一个罗马数字，将其转换为整数。输入保证在1到3999的范围内。 例子： 输入: “III” 输出: 3 输入: &quot;IV&quot; 输出: 4 输入: &quot;IX&quot; 输出: 9 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V = 5, III = 3. 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90 and IV = 4. 解题方法从头遍历输入字符串，对于’I’，’X’，’C’，判断后面的字符，是否是4或者9这种特殊情况。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384int romanToInt(char *s)&#123; int i, count = 0; for (i = 0; i &lt; strlen(s) - 1; i++) &#123; switch (s[i]) &#123; case 'I': if (s[i + 1] == 'V') &#123; count += 4; i++; &#125; else if (s[i + 1] == 'X') &#123; count += 9; i++; &#125; else count++; break; case 'V': count += 5; break; case 'X': if (s[i + 1] == 'L') &#123; count += 40; i++; &#125; else if (s[i + 1] == 'C') &#123; count += 90; i++; &#125; else count += 10; break; case 'L': count += 50; break; case 'C': if (s[i + 1] == 'D') &#123; count += 400; i++; &#125; else if (s[i + 1] == 'M') &#123; count += 900; i++; &#125; else count += 100; break; case 'D': count += 500; break; case 'M': count += 1000; break; default: break; &#125; &#125; if (i == strlen(s) - 1) &#123; if (s[i] == 'I') count += 1; else if (s[i] == 'X') count += 10; else if (s[i] == 'C') count += 100; else if (s[i] == 'V') count += 5; else if (s[i] == 'L') count += 50; else if (s[i] == 'D') count += 500; else count += 1000; &#125; return count;&#125;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 12.Integer to Roman]]></title>
    <url>%2F2018%2F12%2F14%2FLeetCode-12-Integer-to-Roman%2F</url>
    <content type="text"><![CDATA[题目翻译罗马数字是用以下7种字符表示的：I, V, X, L, C, D 和 M. 字符 值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 举例来说，2在罗马数字中用II表示，12用XII表示，27写作XXVII 罗马数字通常将最大数写在最左，较小数写在右面。但是数字4的写法并不是IIII而是IV。因为1在5之前，我们就用5减去它，变成4。同样，这个规则对9也适用，9被写作IX 有六个使用减法的实例： I 可以被放在 V (5) 和 X (10) 之前就变成了 4 和 9. X 可以被放在 L (50) 和 C (100) 之前就变成了 40 和 90. C 可以被放在 D (500) 和 M (1000) 之前就变成了 400 and 900. 给定一个整数，将其转换为罗马数字。输入保证在1到3999的范围内。 例子： 输入: 3 输出: &quot;III&quot; 输入: 4 输出: &quot;IV&quot; 输入: 9 输出: &quot;IX&quot; 输入: 58 输出: &quot;LVIII&quot; 解释: L = 50, V = 5, III = 3. 输入: 1994 输出: &quot;MCMXCIV&quot; 解释: M = 1000, CM = 900, XC = 90 and IV = 4. 解题方法先分别求出给定数字的个、十、百、千位。因为千位不能大于4，所以只用判断个、十、百位的数字。对于这三位的数字有以下几种可能 值等于4或9：直接算出相应的字符，然后加到字符串尾就可以。 值小于4：字符串加上n个相应的字符(例如，个位为3，就加3个’I’；十位为2，就加2个’X’)。 值大于等于5：字符串加上相应位为5的字符(例如，个位加’V’，十位加’L’)，然后重复上一步骤。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution&#123; public: string intToRoman(int num) &#123; int tho = num / 1000; int hun = (num / 100) % 10; int ten = (num / 10) % 10; int one = num % 10; string s = ""; for (int i = 0; i &lt; tho; i++) s += "M"; if (hun == 9) s += "CM"; else if (hun == 4) s += "CD"; else &#123; if (hun &gt;= 5) s += "D"; for (int i = 0; i &lt; hun % 5; i++) s += "C"; &#125; if (ten == 9) s += "XC"; else if (ten == 4) s += "XL"; else &#123; if (ten &gt;= 5) s += "L"; for (int i = 0; i &lt; ten % 5; i++) s += "X"; &#125; if (one == 9) s += "IX"; else if (one == 4) s += "IV"; else &#123; if (one &gt;= 5) s += "V"; for (int i = 0; i &lt; one % 5; i++) s += "I"; &#125; return s; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 6.索引(四)——覆盖索引、索引排序、冗余索引]]></title>
    <url>%2F2018%2F12%2F13%2FMySQL-6-%E7%B4%A2%E5%BC%95-%E5%9B%9B-%E2%80%94%E2%80%94%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E3%80%81%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F%E3%80%81%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[覆盖索引如果一个索引包含(或者说覆盖)所有需要查询的字段的值，就称之为“覆盖索引”。B-Tree索引存放的是字段的值，如果key中包含所有需要查询字段的值，就是覆盖索引。 覆盖索引可以极大地提高性能。因为只需要扫描索引，而无须返回表，有以下好处： 索引条目远小于数据行大小，所以只读取索引可以减少数据访问量。这对缓存的负载很重要，对于I/O密集型应用很有帮助，因为索引比数据小，更容易全部放入内存中。 因为索引是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随即从磁盘读取每一行数据的I/O要少的多。 由于InnoDB的聚簇索引，覆盖索引对于InnoDB很有用。InnoDB的二级索引在叶子节点中保存了行的主键值，如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。 覆盖索引必须要存储索引类的值，所以MySQL只能使用B-Tree索引做覆盖索引。 使用索引扫描来做排序只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向(倒序或正序)都一样时，MySQL才能使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求。 当前导列为常量时，ORDER BY子句可以不满足索引的最左前缀的要求。 下面是一个例子：123456789101112131415161718192021222324252627CREATE TABLE rental ( ... PRIMARY KEY (rental_id), UNIQUE KEY rental_date (rental_date, inventory_id, customer_id), ...);mysql &gt; SELECT ... FROM rental WHERE rental_date = '2005-05-25' ORDER BY inventory_id DESC;-- 可以使用索引排序，因为查询为索引第一列提供了常量条件，而使用第二列进行排序。合在一起便形成了索引最左前缀。mysql &gt; ... WHERE rental_date &gt; '2005-05-25' ORDER BY rental_date, inventory_id;-- 可以使用索引排序，因为ORDER BY使用的两列就是索引的最左前缀。mysql &gt; ... WHERE rental_date = '2005-05-25' ORDER BY inventory_id DESC, customer_id ASC;-- 不可以使用索引排序，因为查询使用了两种不同的排序方向。mysql &gt; WHERE rental_date = '2005-05-25' ORDER BY inventory_id, staff_id;-- 不可以使用索引排序，因为ORDER BY中有不在索引中的列。mysql &gt; WHERE rental_date = '2005-05-25' ORDER BY customer_id;-- 不可以使用索引排序，因为WHERE子句和ORDER BY子句中的列无法组合成索引的最左前缀。mysql &gt; ... WHERE rental_date &gt; '2005-05-25' ORDER BY inventory_id, customer_id;-- 不可以使用索引排序，因为在索引列第一列上是范围条件。mysql &gt; ... WHERE rantal_date = '2005-05-25' AND inventory_id IN (1, 2) ORDER BY customer_id;-- 不可以使用索引排序，因为查询在inventory_id列上有多个等于条件，相当于范围查询。 冗余和重复索引MySQL允许在相同列上创建多个索引，MySQL需要单独维护重复的索引，会影响性能。 重复索引是指相同的列上按照相同的顺序创建的相同类型的索引，应该避免这种索引(如果索引类型不同，不算重复索引)。 冗余索引和重复索引有些不同，如果创建了索引(A，B)，再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引。但是如果创建了(A，B)，再创建索引(B，A)或者(B)就不是冗余索引。因为这两个不是(A，B)的最左前缀索引。不同类型的索引也不会是冗余索引。 大多数情况下不需要冗余索引，但有的时候，如果要扩展索引，可能需要在当前索引上加上一个很长的列(如很长的VARCHAR)，会影响性能，冗余索引可能是较好的选择。 索引下推可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉。 例如执行下列语句，从图中可知索引下推的作用(绿色虚线代表回表) mysql&gt; select * from tuser where name like &apos;张 %&apos; and age=10 and ismale=1; 推荐阅读极客时间：MySQL实战45讲 —— 05深入浅出索引(下) 12参考内容 &gt;&gt; 高性能MySQL第三版 &gt;&gt; 极客时间：MySQL实战45讲 —— 05深入浅出索引(下)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>MySQL性能</tag>
        <tag>覆盖索引</tag>
        <tag>索引排序</tag>
        <tag>冗余索引</tag>
        <tag>索引下推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 6.动态SQL]]></title>
    <url>%2F2018%2F12%2F13%2FMyBatis-6-%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[动态SQLMyBatis的动态SQL包括以下几种元素 元素 作用 备注 if 判断语句 单条件分支判断 choose(when、otherwise) 相当于Java中的case 多条件分支判断 trim(where、set) 辅助元素 用于处理一些SQL拼装问题 foreach 循环语句 在in语句等列举条件常用 if元素例如，根据角色名称(roleName)去查找角色，但角色名称是一个可填可不填的条件，不填写的时候则它不作为查询条件。 123456&lt;select id = "findRoles" parameterType = "string" resultMap = "roleResultMap"&gt; select role_no, role_name, note from t_role where 1=1 &lt;if test = "roleName != null and roleName != ''"&gt; and role_name like #&#123;roleName&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise元素例如， 当角色编号不为空，则只用角色编号作为条件查询。 当角色编号为空，而角色名称不为空，则角色名称作为条件进行模糊查询。 当角色编号和角色名称都为空，则要求角色备注不为空。 123456789101112131415&lt;select id = "findRoles" parameterType = "role" resultMap = "roleResultMap"&gt; select role_no, role_name, note from t_role where 1=1 &lt;choose&gt; &lt;when test = "roleNo != null and roleNo != ''"&gt; AND role_no = #&#123;roleNo&#125; &lt;/when&gt; &lt;when test = "roleName != null and roleName != ''"&gt; AND role_name like #&#123;roleName&#125; &lt;/when&gt; &lt;otherwise&gt; AND note is not null &lt;/otherwise&gt; &lt;/choose&gt;&lt;select&gt; trim、where、set元素前面的例子中，都存在一个条件“1=1”，因为若是没有这个条件，语句就会产生错误(where and)。如果觉得“1=1”显得很奇怪，可以使用where元素。12345678&lt;select id = "findRoles" parameterType = "string" resultMap = "roleResultMap"&gt; select role_no, role_name, note from t_role &lt;where&gt; &lt;if test = "roleName != null and roleName != ''"&gt; and role_name like #&#123;roleName&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这样当where元素里面的条件成立时，才会加入where关键字到SQL语句中。 有时需要去掉一些SQL特殊语法，例如，and、or。可以使用trim来达到目的。12345678&lt;select id = "findRoles" parameterType = "string" resultMap = "roleResultMap"&gt; select role_no, role_name, note from t_role &lt;trim prefix = "where" prefixOverrides = "and"&gt; &lt;if test = "roleName != null and roleName != ''"&gt; and role_name like #&#123;roleName&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; trim元素意味着要去掉一些特殊字符，prefix代表语句前缀，prefixOverrides则是要去掉的那串字符串。 现实场景中，经常存在更新一行数据其中一个字段的可能。可以使用set元素实现123456789101112&lt;update id = "updateRole" parameterType = "role"&gt; update t_role &lt;set&gt; &lt;if test = "roleName != null and roleName != ''"&gt; role_name = #&#123;roleName&#125;, &lt;/if&gt; &lt;if test = "note != null and note != ''"&gt; note = #&#123;note&#125; &lt;/if&gt; &lt;/set&gt; where role_no = #&#123;roleNo&#125;&lt;/update&gt; foreach元素作用是遍历集合，例如 1234567&lt;select id = "findUserBySex" resultType = "user"&gt; select * from t_user where sex in &lt;foreach item = "sex" index = "index" collection = "sexList" open = "(" separator ="," close = ")"&gt; #&#123;sex&#125; &lt;/foreach&gt;&lt;/select&gt; collection：配置的sexList是传递进来的参数名称，可以是一个数组或者List、Set等集合。 item：配置的是循环中当前的元素。 index：配置的是当前元素在集合的位置下标。 open和close：以什么符号将这些集合元素包装起来。 separator：各个元素的间隔符。 bind元素方便进行模糊查询，与数据库无关。例如，想要按角色名进行模糊查询123456&lt;select id = "findRole" resultType = "RoleBean"&gt; &lt;bind name = "pattern" value = "'%' + _parameter + '%'"/&gt; SELECT id, role_name as roleName, create_date as createDate, end_date as endDate, end_flag as endFlag, note FROM t_role where role_name like #&#123;pattern&#125;&lt;/select&gt; 这里的“_parameter”代表的就是传递进来的参数，它和通配符连接后，赋给了pattern，然后就可以在select语句中使用这个变量进行模糊查询 还可以传递多个参数123456789/** * 查询角色 * @param roleName 角色名称 * @param note 备注 * @return 符合条件的角色 */public List&lt;RoleBean&gt; findRole(@Param("roleName") String roleName, @Param("note") String note); 1234567&lt;select id = "findRole" resultType = "RoleBean"&gt; &lt;bind name = "pattern_roleName" value = "'%' + roleName + '%'"/&gt; &lt;bind name ="pattern_note" value = "'%' + note + '%"/&gt; SELECT id, role_name as roleName, create_date as createDate, end_date as endDate, end_flag as endFlag, note FROM t_role where role_name like #&#123;pattern_roleName&#125; and note like #&#123;pattern_note&#125;&lt;/select&gt; 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>动态SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 5.映射器(四)——级联]]></title>
    <url>%2F2018%2F12%2F08%2FMyBatis-5-%E6%98%A0%E5%B0%84%E5%99%A8-%E5%9B%9B-%E2%80%94%E2%80%94%E7%BA%A7%E8%81%94%2F</url>
    <content type="text"><![CDATA[级联在数据库中有许多一对多和一对一的关系，例如一个角色可以分配给多个用户，也可以只分配给一个用户。我们通常需要一个单独的表保存所有角色，一个表保存用户和角色的关系，当我们想把用户信息和角色信息同时显示时，我们同行使用这样的SQL1234select r.*, u.* from t_role as r join t_user_role as ur on r.id = ur.role_id inner join t_user as u on ur.user_id = u.id where r.id = #&#123;id&#125; 通过这个语句我们可以查询到角色和他的用户信息，并希望将结果集存储到user(JavaBean)的集合中。但是user中又没有role这一属性(因为JavaBean和数据库表对应)。我们就需要用到级联。 级联中存在三种对应关系： 一对一的关系：在MyBatis中表示为association 一对多的关系：在MyBatis中表示为collection 多对多的关系：在MyBatis中表示为discriminator 使用如下的关系模型来解释 其中学生证和学生是一对一关系；学生和课程成绩是一对多的关系，一个学生可以有多门课程；课程和成绩也是一对多的关系；健康表是一对多的关系 一对一级联(association)：学生(Student)与学生证(Selfcard)应该是一对一关系。所以我们一般会创建StudentBean和StudentSelfcardBean两个POJO对象。并且Student的POJO中有一个类型为StudentSelfcardBean的属性studentSelfcard，这样便形成了级联。 然后需要建立Student的映射器StudentMapper和StudentSelfcard的映射器StudentSelfcardMapper。并且在StudentSelfcardMapper中提供一个findStudentSelfcardByStudentId的方法，代码如下所示 12345678910111213141516&lt;mapper namespace = "StudentSelfcardMapper"&gt; &lt;resultMap id = "studentSelfcardMap" type = "StudentSelfcardBean"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "studentId" column = "student_id"/&gt; &lt;result property = "native_" column = "native"/&gt; &lt;result property = "issueDate" column = "issue_date"/&gt; &lt;result property = "endDate" column = "end_date"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;/resultMap&gt; &lt;select id = "findStudentSelfcardByStudentId" parameterType = "int" resultType = "studentSelfcardMap"&gt; select id, student_id, native, issue_data, end_date, note from t_student_selfcard where student_id = #&#123;student_id&#125; &lt;/select&gt;&lt;/mapper&gt; 这样配置完后，就可以在StudentMapper中使用StudentSelfcardMapper进行级联，代码如下 12345678910111213141516&lt;mapper namespace = "StudentMapper"&gt; &lt;resultMap id = "studentMap" type = "StudentBean"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "cnname" column = "cnname"/&gt; &lt;result property = "sex" column = "sex"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;association property ="studentSelefCard" column = "id" select = "StudentSelefcardMapper.findStudentSelfcardByStudentId"/&gt; &lt;/resultMap&gt; &lt;select id = "getStudent" parameterType = "int" resultType = "studentMap"&gt; select id, cnname, sex, note from t_student where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 这样，MyBatis中的association语句，就将column指定的参数(这里是student.id)传递给了select属性定义的方法(这里是findStudentSelfcardByStudentId)。如果多个参数，使用逗号分隔。 getStudent实际查找过程为：根据传进来的id，先查到Student信息，然后根据其id，查询出学生证信息，并将结果级联。 一对多级联(collection)：例如，每个学生都可能有多门课程，而在学生确定的前提下，该学生的一门成绩只对应一门课程。所以有两个级联，一个是学生和成绩的级联，是一对多的关系；还有课程成绩和课程的级联，是一对一的关系(注意是在学生确定的前提下)。 这个时候，我们需要建立一个LectureBean来记录课程，再建立一个StudentLectureBean来记录成绩，并且StudentLectureBean有一个类型为LectureBean属性的lecture。代码如下：1234567891011121314151617public class LectureBean &#123; private Integer id; private String lectureName; private String note; //... setter and getter ...&#125;public class StudentLectureBean &#123; private int id; private Integer studentId; private LectureBean lecture; private BigDecimal grade; private String note; //... setter and getter ...&#125; 为了能读到成绩，在上文提到的StudentBean中添加一个类型为List的属性，studentLectureList。12345678910111213141516171819202122232425262728293031323334353637&lt;mapper namespace = "StudentMapper"&gt; &lt;resultMap id = "studentMap" type = "StudentBean"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "cnname" column = "cnname"/&gt; &lt;result property = "sex" column = "sex"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;association property = "studentSelfcard" column = "id" select = "StudentSelfcardMapper.findStudentSelfcardByStudentId"/&gt; &lt;collection property = "studentLectureList" column = "id" select = "StudentLectureMapper.findStudentLectureByStudentId"/&gt; &lt;/resultMap&gt; &lt;select id = "getStudent" parameterType = "int" resultMap = "studentMap"&gt; select id, cnname, sex, note from t_student where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;&lt;mapper namespace = "StudentLectureMapper"&gt; &lt;resultMap id = "studentLectureMap" type = "StudentLectureBean"&gt; &lt;id property = "id" column ="id"/&gt; &lt;result property = "studentId" column = "student_id"/&gt; &lt;result property = "grade" column = "grade"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;association property = "lecture" column = "lecture_id" select = "LectureMapper.getLecture"/&gt; &lt;/resultMap&gt; &lt;select id = "findStudentLectureByStudentId" parameterType = "int" resultMap = "studentLectureMAp"&gt; select id, student_id, lecture_id, grade, note from t_student_lecture where student_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;&lt;mapper namespace = "LectureMapper"&gt; &lt;select id = "getLecture" parameterType = "int" resultType = "LectureBean"&gt; select id, lecture_name as lectureName, note from t_lecture where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 多对多级联(discriminator)：也叫鉴别器级联，在特定条件下使用不同的POJO。比如例子中的健康情况表。可以根据学生的性别属性，决定关联男性/女性健康表，相当于Java中的switch语句。 首先需要两个健康情况POJO，分别存储男性和女性健康表的基础信息。123456789public class MaleStudentBean extends StudentBean &#123; private List&lt;StudentHealthMaleBean&gt; studentHealthMaleList = null; //... setter and getter ...&#125;public class FemaleStudentBean extends StudentBean &#123; private List&lt;StudentHealthFemaleBean&gt; studentHealthFemaleList = null; //... setter and getter ...&#125; 这样就可以根据StudentBean中的sex属性，来判断使用MaleStudentBean还是FemaleStudentBean的对象了。注意这里存储时，使用int类型的1，2代替男女。 123456789101112131415161718192021222324252627282930&lt;mapper namespace = "StudentBean"&gt; &lt;resultMap id = "studentMap" type = "StudentBean"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "cnname" column = "cnname"/&gt; &lt;result property = "sex" column = "sex"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;association property = "studentSelfcard" column = "id" select = "StudentSelfcardMapper.findStudentSelfcardByStudentId"/&gt; &lt;collection property = "studentLectureList" column = "id" select = "StudentLectureMapper.findStudentLectureByStudentId"/&gt; &lt;discriminator javaType = "int" column = "sex"&gt; &lt;case value = "1" resultMap = "maleStudentMap"/&gt; &lt;case value = "2" resultMap = "femaleStudentMap"/&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;select id = "getStudent" parameterType = "int" resultMap = "studentMap"&gt; select id, cnname, sex, note from t_student where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id = "maleStudentMap" type = "MaleStudentBean" extends = "studentMap"&gt; &lt;collection property = "studentHealthMaleList" column = "id" select = "StudentHealthMaleMapper.findStudentHealthMaleByStudentId"/&gt; &lt;/resultMap&gt; &lt;resultMap id = "femaleStudentMap" type = "FemaleStudentBean" extends = "studentMap"&gt; &lt;collection property = "studentHealthMaleList" column = "id" select = "StudentHealthFemaleMapper.findStudentHealthMaleByStudentId"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 级联的优点与缺点：优点： 可以方便快捷的获取数据 缺点： 多层关联的可读性差 有时不需要获取所有数据，例如只想获得成绩，不想查看健康情况。或造成性能下降。 表很多时，级联关系可能很复杂。会产生N+1问题(例如，每次取一个Student，都要查看n个成绩)。 延迟加载：MyBatis引入该功能来处理 N+1 问题。一开始并不取出级联数据，只有当使用了它才发送SQL去取回数据。例如一开始只取出学生的基本情况，使用成绩时，MyBatis才发送SQL去查看学生成绩。由于一直没有使用健康情况，所以MyBatis也不会去查看健康情况。 MyBatis属性中通过设置lazyLoadingEnabled和aggressiveLazyLoading来配置该功能： lazyLoadingEnabled：是否开启延迟加载功能。 aggressiveLazyLoading：对任意延迟属性的调用会使带有延迟加载属性的对象完整加载。当它为“true”时，会按层级加载，当它为“false”时，则按需加载(默认为true)。 默认情况下，开启lazyLoadingEnabled后，是按层级延迟加载的，如图可视，当访问课程成绩时，学生证信息也会被加载。要改变这个特性，需要用到aggressiveLazyLoading，当它为“true”时，会按层级加载，当它为“false”时，则按需加载。 1234567891011&lt;!-- 全局设置 --&gt;&lt;setting name = "aggressiveLazyLoading" value = "false"/&gt;&lt;!-- 局部设置 --&gt;&lt;!-- fetchType = "lazy"为按需加载 --&gt;&lt;association property = "studentSelfcard" column = "id" fetchType = "lazy" select = "StudentSelfcardMapper.findStudentSelfcardByStudentId"/&gt;&lt;!-- fetchType = "eager"为按层级加载 --&gt;&lt;association property = "studentSelfcard" column = "id" fetchType = "eager" select = "StudentSelfcardMapper.findStudentSelfcardByStudentId"/&gt; 延迟加载的原理是通过动态代理实现的。 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
        <tag>级联</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 4.映射器(三)——sql/resultMap元素]]></title>
    <url>%2F2018%2F12%2F08%2FMyBatis-4-%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%89-%E2%80%94%E2%80%94sql-resultMap%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[sql元素可以定义一串SQL语句，在其他语句(e.g., select)中可以引用。 例如， 1234567891011&lt;sql id = "role_columns"&gt; id, role_name, note&lt;/sql&gt;&lt;select parameterType = "long" id = "getRole" resultMap = "roleMap"&gt; select &lt;include refid = "role_columns"/&gt; from t_role where id = #&#123;id&#125;&lt;/select&gt;&lt;select parameterType = "map" id = "findRoles"&gt; select id, role_name, note from t_role where rold_name like #&#123;roleName&#125; and note like #&#123;note&#125;&lt;/select&gt; 这个例子中，用sql元素定义了role_columns，并使用refid元素进行引用。 也可以制定参数来使用1234567891011&lt;sql id = "role_columns"&gt; #&#123;prefix&#125;.role_no, #&#123;prefix&#125;.role_name, #&#123;prefix&#125;.note&lt;/sql&gt;&lt;select parameterType = "string" id = "getRole" resultMap = "roleResultMap"&gt; select &lt;include refix = "role_columns"&gt; &lt;property name = "prefix" value = "r"/&gt; &lt;/include&gt; from t_role r where role_no = #&#123;roleNo&#125;&lt;/select&gt; 还可以给refid一个参数值，由程序制定引入SQL123&lt;sql id = "someinclude"&gt; select * from &lt;include refid = "$&#123;tableName&#125;"/&gt;&lt;/sql&gt; resultMap结果映射集resultMap 元素的构成resultMap元素里的元素 12345678910111213&lt;resultMap&gt; &lt;constructor&gt; &lt;idArg/&gt; &lt;arg/&gt; &lt;/constructor&gt; &lt;id/&gt; &lt;result/&gt; &lt;association/&gt; &lt;collection/&gt; &lt;discriminator&gt; &lt;case/&gt; &lt;discriminator/&gt;&lt;/resultMap&gt; constructor：用来配置构造方法，一个POJO可能可能不存在没有参数的构造方法，这个时候可以用constructor进行配置。例如， 1234&lt;constructor&gt; &lt;idArg column = "id" javaType = "int"/&gt; &lt;arg column = "role_name" javaType = "string"/&gt;&lt;/constructor&gt; id：表示哪个列是主键，允许多个主键，多个主键称为联合主键。 result：配置POJO到SQL列名的映射关系。 result元素和id元素的属性 元素名称 说明 备注 property 映射到列结果的字段或属性。如果POJO的属性匹配是存在的，和给定SQL列名(column元素)相同的，那么MyBatis就会映射到POJO上 可以使用导航式字段，比如访问一个学生对象(Student)需访问学生证(selfcard)的发证日期(issueDate),那么我们可以写成selfcard.issueDate column 这里对应的是SQL的列 - javaType 配置Java的类型 可以是特定的类完全限定名或者MyBatis上下文的别名 jdbcType 配置数据库类型 JDBC的类型 typeHandler 类型处理器 允许使用特定的处理器来覆盖MyBatis默认处理器，需要制定jdbcType和javaType的相互转化规则 使用map存储结果集123&lt;select id = "findColorByNote" parameterType = "string" resultType = "map"&gt; select id, color, note from t_color where note like #&#123;note&#125;&lt;/select&gt; 可读性比较差，并不推荐 使用POJO存储结果集配置代码如图 12345&lt;resultMap id = "roleResultMap" type = "Role"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "roleName" column = "role_name"/&gt; &lt;result property = "note" column = "note"/&gt;&lt;/resultMap&gt; resultMap中的id属性：代表这个resultMap的标识 resultMap中的type属性：代表需要映射的POJO id元素：表示主键 property：表示POJO属性名称 column：表示数据库SQL列名 使用resultMap的代码123&lt;select parameterType = "long" id = "getRole" resultMap = "roleResultMap"&gt; select id, note_name, note from t_role where id = #&#123;id&#125;&lt;/select&gt; 推荐阅读基于MyBatis实现的JavaWeb项目源码-github 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 5.索引(三)——聚簇索引]]></title>
    <url>%2F2018%2F12%2F04%2FMySQL-5-%E7%B4%A2%E5%BC%95-%E4%B8%89-%E2%80%94%E2%80%94%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[聚簇索引聚簇索引是一种数据存储方式，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中(叶子页包含了行的全部数据，节点页只包含了索引列)。“聚簇”表示数据行和相邻的键值紧凑的存储在一起。一个表只能有一个聚簇索引。 InnoDB会选择主键列进行聚簇索引，如果没有定义主键，InnoDB会选择唯一的非空索引代替。如果还是没有，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。 InnoDb的普通索引(二级索引)的叶子结点中存放的是主键的值，所以需要先查询普通索引(二级索引)的叶子节点找到对应的主键值，然后再根据主键值去聚集索引中查询到对应的数据。 非聚集索引的索引与数据是存在不同文件的。 聚簇索引优点： 可以把相关的数据保存在一起，例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数数据页就能获取某个用户的全部邮件，减少磁盘I/O次数。 数据访问更快：聚簇索引同时将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据要比非聚簇索引更快。 使用覆盖索引扫描的查询可以直接使用节点中的主键值。 聚簇索引缺点： 聚簇索引最大限度地提高了I/O密集型应用的性能。如果数据全放放在内存中，那么聚簇索引就没了优势。 插入速度严重依赖于插入顺序。按照主键顺序插入最快。 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。页分裂会导致表占用更多磁盘空间 当行比较稀疏，或者有由于页分裂导致数据存储不连续的时候，可能会导致全表扫描变慢。 二级索引(费聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。 二级索引访问需要两次索引查找，而不是一次(因为二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值)。 InnoDB和MyISAM数据分布对比对于以下这个表，InnoDB和MyISAM存储方式不同：1234567CREATE TABLE layout_test ( col1 int NOT NULL, col2 int NOT NULL, PRIMARY KEY(col1), KEY(col2)); MyISAM的数据分布MyISAM按照数据插入的顺序存储在磁盘上，如图所示。因为这里行是定长的，所以MyISAM可以从表的开头跳过所需字节直接找到需要的行。可以看出MyISAM的主键索引和其他索引在结构上没有不同。 InnoDB的数据分布如图所示，可以发现图中显示了整个表，而不仅仅是索引。因为在InnoDB中，聚簇索引就是表，不需要像MyISAM那样需要独立的行存储。 聚簇索引的每一个叶子结点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列(在这里是col2)。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。 另一点和MyISAM不同的是，InnoDB的二级索引和聚簇索引并不相同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样会减少当出现行移动或者数据页分裂(上文有提到)时二级索引的维护工作。使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动时无需更新二级索引中的这个“指针”。 在InnoDB表中按主键顺序插入行尽量按主键顺序插入行，最简单的方法使用自增列(AUTO_INCREMENT)。因为这样填充时，当页满时，下一条记录就可以写在新页中。而如果无序插入，那么每次都要为行找到合适的位置，会增加许多额外工作。有以下一些缺点 写入的目标页可能已经刷新到磁盘上，并从缓存中移除，InnoDB在插入前必须先找到并从磁盘读取目标页到内存中，导致大量随机I/O。 因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页，而不是一个页。 频繁的页分裂，页会变得稀疏并被不规则地填充，最终会有碎片。 对于高并发工作负载，按主键顺序可能导致性能下降。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>MySQL性能</tag>
        <tag>InnoDB</tag>
        <tag>MyISAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 19.Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F12%2F04%2FLeetCode-19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个链表和一个整数n，返回链表倒数第n个结点。 例子： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. 输出: 1-&gt;2-&gt;3-&gt;5. 备注: n永远是有效的。 要求一次遍历。 解题方法使用两个指针p，q分别指向链表头。p先走n次，如果p走到头就说明n大于等于链表长度，就删除头结点(所以新建了一个h指向头结点，便于删除头结点)。如果p没有走到头，就让p和q一起走，直到p走到头，q指向的就是要删除的结点。 代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *h = new ListNode(0); h-&gt;next = head; ListNode *p =h ,*q=h; while(n--&amp;&amp;p!=NULL) p = p-&gt;next; if(n&gt;0) return NULL; while(p&amp;&amp;p-&gt;next)&#123; p = p-&gt;next; q = q-&gt;next; &#125; q-&gt;next= q-&gt;next-&gt;next; return h-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 4.索引(二)——高性能索引]]></title>
    <url>%2F2018%2F12%2F04%2FMySQL-4-%E7%B4%A2%E5%BC%95-%E4%BA%8C-%E2%80%94%E2%80%94%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[如果使用高性能索引独立的列：如果查询中的列不是独立的，则MySQL不会使用索引。“独立的列” 指的是索引列不能是表达式的一部分，也不能是函数的参数。 例如， 1mysql &gt; SELECT actor_id FROM actor where actor_id +1 =5; 这个查询就无法使用actor_id列的索引，因为它是表达式的一部分。但是如果我们把where的表达式写成actor_id = 4 就可以使用这列的索引了。所以，在写where语句时，尽量将索引列单独放在比较符号的一侧。 前缀索引和索引选择性：索引的选择性是指：不重复的索引值(基数，cardinality)和数据表的记录总数(#T)的比值，范围从 1/#T 到 1 之间。索引的选择性越高，则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 前缀索引：对于一些很长的字符列，通常只索引开始的部分字符。例如BLOB、TEXT或很长VARCHAR，必须使用前缀索引，因为MySQL索引长度有限制。选择前缀索引时，应该让前缀索引的“基数”接近于完整列的“基数”。前缀索引的缺点是无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。 如何计算索引选择性：下面给出一个例子，演示如何计算完整列和不同长度前缀的的选择性： 1234567891011mysql &gt; CREATE TABLE city_demo (city VARCHAR(50) NOT NULL);-- 随机向city_demo中插入许多城市(可重复)--计算完整列的选择性mysql &gt; SELECT COUNT(DISTINCT city) / COUNT(*) FROM city_demo;--计算不同长度前缀的选择性(下面例子为长度为3，4，5的前缀)mysql &gt; SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3, COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4, COUNT(DISTINCT LEFT(city, 5))/COUNT(*) AS sel5 FROM city_demo 如何创建前缀索引：12--创建前缀长度为5的索引mysql &gt; ALTER TABLE city_demo ADD KEY (city(5)); 特殊用处：可以用来做后缀索引，其基本原理是把想要存储的信息(如电子邮件地址)反转后存储，然后建立前缀索引。这样可以用来查找电子邮件域名等。 多列索引：一个常见的错误是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。为每个列创建独立的索引，在WHERE语句中需要多个列的条件时，并不是最优的结果。 多列索引中列正确的顺序依赖于使用该索引的查询，并且应该更好地满足排序和分组的需要。索引首先按照最左列进行排序，其次是第二列，等等(对于B-Tree索引来说)。 将选择性最高的列放在前面通常是很好的。这对于优化WHERE 条件很有帮助，但是并不会提升排序和分组的效率。性能不止依赖于列的选择性，也和查询条件的值的分布有关。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>MySQL性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 14.Longest Common Prefix]]></title>
    <url>%2F2018%2F12%2F03%2FLeetCode-14-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[题目翻译给定一组字符串，找到这些字符串的最小前缀。 解题方法这些字符串的前缀的最大长度不可能超过这些字符串中最小的那个的长度。所以可以先找到那个最小的作为暂时的最大前缀，然后挨个与其他字符串比较，出现不一样的字符就删除该字符及之后的所有字符。 代码123456789101112131415161718192021class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return ""; string pattern = strs[0]; for(int i = 1;i&lt;strs.size();i++) pattern = pattern.size()&lt;strs[i].size()?pattern:strs[i]; for(int i = 0;i&lt;strs.size();i++)&#123; for(int j = 0;j&lt;pattern.size();j++)&#123; if(strs[i][j]!=pattern[j])&#123; pattern.erase(pattern.begin()+j,pattern.end()); break; &#125; &#125; &#125; return pattern; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 11.Container With Most Water]]></title>
    <url>%2F2018%2F12%2F03%2FLeetCode-11-Container-With-Most-Water%2F</url>
    <content type="text"><![CDATA[题目翻译给定n个数字代表n条线段，每个线段的下标为它的横坐标，值为它的高度。使用两个线段和x轴组成一个装水的容器，求出最大的容器。你可以假设容器都是直的，并且n大于等于2。 解题方法既然是装水的容器，那么高度只能由两个线段中较短的那个决定，所以用i, j表示数组里两个数，可知 $容积=min(height[i], height[j])*abs(j-i)$。很容易可以想到暴力求解算法。但是可以进行优化。首先i，j分别为数组两端数字，并向中间移动。可知这时i，j之间影响容量大小的为短的那条边，因为高的那条边向里移动容积一定会减少。所以只要每次向里移动较短的那条边就可以了。 代码123456789101112131415161718192021class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int i = 0, j = height.size()-1; int max = 0; int cur = 0; while(i&lt;j)&#123; if(height[i]&lt;height[j])&#123; cur = height[i]*(j-i); i++; &#125; else&#123; cur = height[j]*(j-i); j--; &#125; max = max&gt;cur?max:cur; &#125; return max; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 3.映射器(二)——insert/update/delete元素]]></title>
    <url>%2F2018%2F12%2F03%2FMyBatis-3-%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%8C-%E2%80%94%E2%80%94insert-update-delete%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[insert元素MyBatis会在执行插入之后返回一个整数，以表示进行操作后插入的记录数。 属性名称 说明 备注 id 它和Mapper的命名空间组合起来是唯一的，提供给MyBatis调用(其实就是Dao中对应的方法名) 如果命名空间和id组合起来不唯一，MyBatis将抛出异常 parameterType 传入参数的类型，例如long，String等(可以给出类的全命名，也可以给出类的别名，但别名必须是MyBatis内部定义或自定义的) 可以选择JavaBean、Map等复杂的参数类型 parameterMap 即将废弃，不建议使用 - flushCache 调用SQL后，是否要求MyBatis清空之前查询的本地缓存和二级缓存 true/false，默认为false timeout 设置超时参数，等超时的时候将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数 statementType 告诉MyBatis使用哪个JDBC的Statement工作，取值为STATEMENT(Statement)、CallableStatement 默认值为PREPARED keyProperty 表示以哪个列作为属性的主键，不能和keyColumn同时使用 设置哪个列为主键，联合主键可以用逗号隔开 useGenerateKeys 这会令MyBatis使用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键，例如，MySQL和SQLSever自动递增字段，Oracle的序列等，但是使用它就必须要给KeyProperty或者keyColumn赋值 true/false。默认为false keyColumn 指明第几列是主键，不能和keyProperty同时使用，只接受整形参数 和keyProperty一样，联合主键可以用逗号隔开 databaseId 取决于数据库厂商 - lang 自定义语言，可以使用第三方语言 - 插入实例：123&lt;insert parameterType = "role" id = "insertRole"&gt; insert into t_role(role_name, note) values(#&#123;roleName&#125;, #&#123;note&#125;)&lt;/insert&gt; 主键回填和自定义：MySQL中的主键可能需要根据一些特殊规则声称，例如自增字段，再插入后我们需要获得该主键。可以使用keyProperty属性指定哪个是主键字段，同时使用useGeneratedKeys属性告诉MyBatis这个主键是否使用数据库内置策略生成。例如，下面的例子中，id为表t_role的自增字段 123&lt;insert id = "insertRole" parameterType = "role" useGeneratedKeys = "true" keyProperty = "id"&gt; insert into t_role (role_name, note) values(#&#123;roleName&#125;, #&#123;note&#125;)&lt;/insert&gt; 我们传入的role对象，无需设置id的值，MyBatis会根据数据库的设置自动处理，在处理完毕后，MyBatis会自动回填MySQL数据库生成的id值到传入的JavaBean中。 实际工作中，还可能有一些更复杂的要求。例如，如果表t_role中没有记录，则设置id=1，否则取当前最大id加2，成为新的主键。这时需要使用selectKey元素处理 123456&lt;insert id = "insertRole" parameterType = "role" useGeneratedKeys = "true" keyProperty = "id"&gt; &lt;selectKey keyProperty = "id" resultType = "int" order = "BEFORE"&gt; select if ( max(id) is null, 1, max(id) + 2 ) as newId from t_role &lt;/selectKey&gt; insert into t_role(id, role_name, note) values (#&#123;id&#125;, #&#123;roleName&#125;, #&#123;note&#125;)&lt;/insert&gt; update元素和insert一样，MyBatis执行完update元素后会返回一个整数，代表进行更新的记录数。 更新实例：123456&lt;update parameterType = "role" id = "updateRole"&gt; update t_role set role_name = #&#123;roleName&#125;, note = #&#123;note&#125; where id = #&#123;id&#125;&lt;/update&gt; delete元素和insert一样，MyBatis执行完delete元素后会返回一个整数，代表进行删除的记录数。 删除实例：123&lt;delete id = "delete" parameterType = "long"&gt; delete from t_role where id = #&#123;id&#125;&lt;/delete&gt; 特殊字符串替换和处理优势我们想要传递SQL语句本身，而不是SQL所需的参数。例如，我们可能想要传递SQL列名，可以使用$符号实现。 1select $&#123;columns&#125; from t_tablename 但是这样对于SQL而言是不安全的。 推荐阅读基于MyBatis实现的JavaWeb项目源码-github 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 9.Palindrome Number]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-9-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[题目翻译求给定的数是否为回文数。 解题方法使用一个新数将原数反转，要是相等就是回文数，注意负数没有回文数。 代码1234567891011121314class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0) return 0; int newnum=0; int temp=x; while(temp)&#123; newnum=newnum*10+temp%10; temp/=10; &#125; return newnum==x; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 8.String to Integer]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-8-String-to-Integer%2F</url>
    <content type="text"><![CDATA[题目翻译实现atoi函数，将字符串变为整数。 输入的开头可能存在许多无用的空格，需要忽视掉。 空格后可能包含代表数正负的 ‘+’ 号和 ‘-‘ 号。 如果遇到不符合的字符就返回0。 如果溢出就按溢出方向返回INT_MAX (2147483647) 或 INT_MIN (-2147483648) 解题方法跳过开头的空格，然后判断是否存在 ‘+’ 号和 ‘-‘ 号。然后按序转换，遇到不符合字符退出。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int myAtoi(string str) &#123; if(str.size()==0) return 0; long long res = 0; int i = 0; for(i = 0;i&lt;str.size();i++)&#123; if(str[i]!=' ') break; &#125; if(i==str.size()) return 0; int flag = str[i]=='-'?-1:1; if(str[i]=='+'||str[i]=='-') i++; for(i;i&lt;str.size();i++)&#123; if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')&#123; res = res*10 + (str[i]-'0'); if(res*flag&gt;INT_MAX||res*flag&lt;INT_MIN) return flag&gt;0?INT_MAX:INT_MIN; &#125;else break; &#125; return res*flag; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 7.Reverse Integer]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个32位有符号整数，将这个数翻转。 例子： 输入：123 输出：321 输入：-80 输出：-8 注意：只考虑32位数，如果翻转后数字溢出返回0。 解题方法将原数每次模10加到输出上然后乘以10。 代码123456789101112class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x)&#123; res = res*10 + x%10; x/=10; &#125; return (res &lt; INT_MIN || res &gt; INT_MAX) ? 0 : res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 6.ZigZag Conversion]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-6-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[题目翻译给定字符串 “PAYPALISHIRING” 与特定数字numRows = 3，字符串实际显示方式为 P A H N A P L S I I G Y I R 从左到右，从上到下输出它们，结果为 “PAHNAPLSIIGYIR”。 解题方法通过找规律可得原字符串 n的值为 2 * (numRows - 1)。 第一行的字符在原字符串的位置为(0, 0+n, 0+2n…)。 第二行为(1, 1+n-2, 1+n, 1+2(n-2), 1+2n…)。 最后一行的值为( numRows-1, numRows-1+n, numRows-1+2n…)。 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows&gt;=s.size()||numRows&lt;=1) return s; string res(s); int flag = (numRows - 1)&lt;&lt;1; int m = flag, n = flag - m; int level = 0; int total = 0; while(m&gt;=0)&#123; int i = level; while(i&lt;s.size())&#123; if(m!=0)&#123; res[total++] = s[i]; i+=m; &#125; if(i&lt;s.size()&amp;&amp;n!=0)&#123; res[total++] = s[i]; i+=n; &#125; &#125; level++; m-=2; n+=2; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>数学规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 2.映射器(一)——select元素]]></title>
    <url>%2F2018%2F12%2F02%2FMyBatis-2-%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%80-%E2%80%94%E2%80%94select%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[映射器MyBatis是针对映射器构造的SQL轻量级框架，通过配置生成对应的JavaBean返回给调用者。 映射器的主要元素映射器的配置 元素名称 描述 备注 select 查询语句 可以自定义参数，返回结果集 insert 插入语句 执行后返回一个整数，代表插入的条数 update 更新语句 执行后返回一个整数，代表更新的条数 delete 删除语句 执行后返回一个整数，代表删除的条数 parameterMap 定义参数映射关系 即将被删除的元素，不建议使用 sql 允许定义一部分的SQL，然后在多个地方引用 例如，一张表列名，可以一次定义，在多个SQL语句中使用 resultMap 用来描述从数据库结果集中加载的对象 提供映射规则 cache 给定命名空间的缓存配置 - cache-ref 其他命名空间缓存配置的引用 - select元素select元素负责从数据库中读出数据，并且组装数据。执行前，需要定义参数，例如int，float等简单参数类型，也可以是JavaBean、Map等复杂类型。执行后，MyBatis提供了自动映射可以把结果集绑定到JavaBean上。select配置如下： 元素 说明 备注 id 它和Mapper的命名空间组合起来是唯一的，提供给MyBatis调用(其实就是Dao中对应的方法名) 如果命名空间和id组合起来不唯一，MyBatis将抛出异常 parameterType 传入参数的类型，例如long，String等(可以给出类的全命名，也可以给出类的别名，但别名必须是MyBatis内部定义或自定义的) 可以选择JavaBean、Map等复杂的参数类型 parameterMap 即将废弃，不建议使用 - resultType 返回的类型。定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射；也可以定义为int、float、double等参数；不能和resultMap同时使用 - resultMap 可以执行强大的映射功能，通过该元素，可以自定义映射，不能与resultType同时使用 可以配置映射规则，typeHandler等 flushCache 调用SQL后，是否要求MyBatis清空之前查询的本地缓存和二级缓存 true/false，默认为false useCache 启动二级缓存的开关，是否要求MyBatis将此次结果缓存 true/false，t默认为true timeout 设置超时参数，等超时的时候将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数 fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数 statementType 告诉MyBatis使用哪个JDBC的Statement工作，取值为STATEMENT(Statement)、CallableStatement 默认值为PREPARED resultSetType 针对JDBCresultSet接口 默认值是数据库厂商提供的JDBC驱动所设置的 databaseId 取决于数据库厂商 - resultOrdered 仅适用于嵌套集select语句。如果为true，就是假设包含了嵌套结果集或者是分组了。当返回一个主结果行的时候，就不能对前面结果集引用。确保了在获取嵌套结果集的时候不会导致内存不够用 true/false，默认为false resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用 简易数据类型的例子例如，想要统计一个姓氏的数量，我们应该把‘姓’作为参数，而将结果(一个整数)作为结果返回123&lt;select id = "countFirstName" parameterType="String" resultType="int"&gt; select count(*) as total from t_userwhere name like #&#123;firstName&#125;&lt;/select&gt; 对应Dao中的方法为1public int countFirstName(String firstName); 每个部分的含义： id：对应的是Dao中的方法名 parameterType：是参数类型，也就是Dao中方法的参数类型 resultType：定义返回类型，也就是Dao中方法的返回类型 #{firstName}：也就是Dao中方法的参数名，#{}符号告诉MyBatis这是一个变量 在完整应用中的使用可以看下面这个例子mapper，Dao，JavaBean 自动映射MyBatis中可以设置参数autoMappingBehavior，当该值不为NONE时，MyBatis会自动根据SQL列名和JavaBean的属性自动映射(前提是他们一致)。大部分的数据库规范要求每个单词用下划线分割，而Java则是用驼峰命名。下面给出一个例子 JavaBean 1234567891011121314151617181920212223242526272829public class Role&#123; private Long id; private String roleName; private String note; public Long getId () &#123; return id; &#125; public void setId (Long id) &#123; this.id = id; &#125; public String getRoleName () &#123; retrun roleName; &#125; public void setRoleName (String roleName) &#123; this.roleName = roleName; &#125; public String getNote () &#123; return note; &#125; public void setNote (String note) &#123; this.note = note; &#125;&#125; 数据库表T_ROLE 字段 类型 说明 ID INT(20) 角色编号，主键，递增 ROLE_NAME VARCHAR(60) 角色名称 NOTE VARCHAR(1024) 备注 Mapper 1234&lt;select id = "getRole" parameterType = "long" resultType = "Role" &gt; select id, role_name as roleName, note from t_role where id = #&#123;id&#125;&lt;/select&gt; Dao 1public Role getRole(Long id); autoMappingBehavior属性包含三个值，可以再settings元素中配置： NONE：取消自动映射 PARTIAL(默认)：只会自动映射没有定义嵌套结果集映射的结果集 FULL：自动映射所有结果集 mapUnderscoreToCamelCase设置为true，可以实现从数据库到POJO的自动映射，前提是命名是规范的。 传递多个参数使用Map传递参数Mapper 12345&lt;select id="findRoleByMap" parameterType="map" resultMap="roleMap"&gt; select id, role_name, note from t_role where role_name like #&#123;roleName&#125; and note like #&#123;note&#125;&lt;/select&gt; Dao 1public List&lt;Role&gt; findRoleByMap (Map&lt;String, String&gt; params); 传递参数123456Map&lt;String, String&gt; paramsMap = new HashMap&lt;String, String&gt; ();paramsMap.put("roleName", "me");paramsMap.put("note", "te");roleMapper.findRoleByMap(paramsMap); 缺点是Map需要键值对应，业务关联性不强，造成可读性下降。 使用注解方式传递参数我们需要使用MyBatis的参数注解@param(org.apache.ibatis.annotations.Param)来实现想要的功能。操作方法是，把RoleDao接口修改为下面的形式。 12public List&lt;Role&gt; findRoleByAnnotation (@Param ("roleName") String rolename, @Param("note") String note); 注解式参数12345&lt;select id="findRoleByAnnotation" resultMap="roleMap"&gt; select id, role_name, note from t_role where role_name like #&#123;role_name&#125; and note like #&#123;note&#125;&lt;/select&gt; 缺点是如果参数过多会很复杂。 使用JavaBean传递参数首先定义一个参数的JavaBean1234567891011121314151617public class RoleParam &#123; private String roleName; private String note; public String getRoleName () &#123; return roleName; &#125; public void setRoleName (String roleName) &#123; this.roleName = roleName; &#125; public String getNote () &#123; return note; &#125; public void setNote (String note) &#123; this.note = note; &#125;&#125; 12345&lt;select id="findRoleByParams" parameterType = "RoleParam" resultMap="roleMap"&gt; select id, role_name, note from t_role where role_name like #&#123;role_name&#125; and note like #&#123;note&#125;&lt;/select&gt; 1public List&lt;Role&gt; findRoleByParams (RoleParam params); 使用resultMap映射结果集例如123456789&lt;resultMap id = "roleResultMap" type="Role"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="roleName" column="role_name"/&gt; &lt;result property="note" column="note"/&gt;&lt;/resultMap&gt;&lt;select parameterType="long" id="getRole" resultMap = "roleResultMap" &gt; select id, role_name, note from t_role where id = #&#123;id&#125;&lt;/select&gt; 解释一下配置： 定义了一个唯一标识(id)为roleResultMap的resultMap，用type属性定义它对应的是哪个JavaBean 通过id元素定义roleResultMap，这个对象代表着使用哪个属性作为其主键。 通过result元素定义普通列的映射关系。例如，把SQL结果返回的列role_name和type属性定义JavaBean的属性roleName等做对应。 推荐阅读基于MyBatis实现的JavaWeb项目源码-github 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 2.Add Two Numbers]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[题目翻译给定两个非空单链表代表两个非负整数。每个结点有一位数字，以倒序保存在链表中。将两数相加，并返回一个代表结果的链表。假设两个数字不含无效的0(即数字不以0开头)，0本身除外。 例子： 输入: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出: 7 -&gt; 0 -&gt; 8 解释: 342 + 465 = 807. 解题方法遍历两个链表把每一位上的数字相加，并用变量记录是否需要进位，该变量初始为0。因为两个数字位数可能不同，所以有四种情况 两个链表中都有这一位数字，且两数与进位变量相加小于10，则直接得到新结点，并且将进位变量置位0. 两个链表中都有这一位数字，但两数与进位变量相加大于等于10，新结点的值为得到的和减10，并且将进位变量置位1. 只有一个链表有这一位数字，且这个数字加进位量小于10，直接得到新结点，变位量置位0. 只有一个链表有这一位数字，且这个数字加进位量大于等于10，新结点的值为得到的和减10，并且将进位变量置位1. 需要考虑到，最后可能两个链表相加完成后，进位量为1，要把这一进位量加到数字前面。 代码1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *p = l1; ListNode *q = l2; ListNode *h = new ListNode(0); ListNode *t = h; int flag = 0; while(p || q || flag&gt;0)&#123; int sump = p?p-&gt;val:0; int sumq = q?q-&gt;val:0; t-&gt;next = new ListNode(sump + sumq + flag); t = t-&gt;next; flag = t-&gt;val&gt;=10?1:0; t-&gt;val = t-&gt;val&gt;=10?t-&gt;val-10:t-&gt;val; p = p?p-&gt;next:NULL; q = q?q-&gt;next:NULL; &#125; t-&gt;next = NULL; return h-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 3.索引(一)——索引的类型]]></title>
    <url>%2F2018%2F12%2F02%2FMySQL-3-%E7%B4%A2%E5%BC%95-%E4%B8%80-%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[索引索引的作用：在MySQL中，想要查找某个行时，首先在索引中找到对应值，然后根据匹配的索引找到对应的数据行。在MySQL中，索引是在存储引擎层而不是服务器层实现的。对于索引的创建和如何使用索引进行查询 推荐阅读：如何理解并正确使用MySQL索引 索引的类型B-Tree索引B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。推荐阅读：什么是B树 B-Tree索引可以加快访问数据的速度，因为存储引擎可以从索引的根节点开始进行搜索，从而取代全表扫描。B-Tree对索引列是顺序组织存储的，所以比较适合查找范围数据 可以对多个列创建索引，索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。例如，定义索引时顺序为 姓名，生日。那么首先按姓名进行排序，只有当两人姓名一样时，才按生日排序。 B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型查询有效： 全值匹配：全值匹配指的是和索引中的所有列进行匹配。 匹配最左前缀：只匹配索引的第一列 匹配列前缀：只匹配第一列的值的开头部分，例如只匹配姓以J为开头的人。 匹配范围值：例如匹配成绩为60-100之间的人，只使用索引第一列 精确匹配某一列并范围匹配另一列：例如匹配所有姓名为张三，成绩在60-100分的人。 只访问索引的查询：查询只访问索引，并不访问数据行。 因为索引树中的节点是有序的，所以除了按值查找外，还可以用于查询中的ORDER BY操作。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。 B-Tree索引的限制： 如果不是按照索引最左列开始查找，则无法使用索引。例如，索引列按顺序为：姓名，生日，该索引无法用于查找某个特定生日的人，因为生日不是最左数据。同样也无法查找姓名以某个字结尾的人。 不能跳过索引中的列。例如，索引按顺序为：姓，名，生日。则无法查找所有在姓张的，且在1月1日生的人，因为不能跳过名。在这个查询中，MySQL只能使用‘姓’这列的索引。 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询(注意：LIKE也属于范围查询条件)。所以对于范围值有限的查询，可以用多个等于条件来代替范围条件。 哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎会对索引的索引列计算一个哈希码，不同键值行的哈希码不同。哈希索引将所有哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。如果哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中 例如，现在数据库表中有姓，名两列数据，且‘姓’列添加了哈希索引。当要查询一个姓为‘张’的数据时。MySQL先计算‘张’的哈希值，并且用该值在哈希表中找到对应的记录指针。 哈希索引自身只需存储对应哈希值，所以非常快。但是也存在限制： 哈希索引只包含哈希值和行指针，而不存储字段值。所以不能使用索引中的值来避免读取行 哈希索引无法用于排序，因为不是按照索引值顺序存储的(按照哈希后的值存储) 哈希索引不支持部分索引列匹配查找。 哈希索引只支持等值比较(包括=、IN()、&lt;=&gt;)。也不支持任何范围查询。 如果有很多哈希冲突，查询/维护代价会变高。 InnoDB有一个特殊功能叫做“自适应哈希索引(adaptive hash index)”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree索引之上在创建一个哈希索引。 创建自定义哈希索引：如果存储引擎不支持哈希索引，则可以在B-Tree基础上创建一个伪哈希索引(本质上还是使用B-Tree查找)。 例如，需要存储大量URL，并且需要根据URL进行搜索查找。如果使用B-Tree直接查找，会很慢，存储内容也会很多。所以，可以给表新增一列，并且使用一个哈希函数，这个新增的列记录对应行URL哈希后的值，并在该列加上索引，这样在查找时，先对给定的URL进行哈希，然后再新增列上查找对应哈希后的值，找到后再返回对应的行就可以了。 有序数组即按一定顺序，将数据存在一个数组里，这种索引支持等值查询(二分法)，也支持范围查询(二分然后遍历)。但有序数组在更新时花费很高，所以只适合静态存储引擎。 全文索引它查找的是文本中的关键词，而不是直接比较索引中的值。在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE操作。 普通索引和唯一索引 普通索引：数据库中的基本索引类型，允许在定义索引的列中插入重复值和空值 唯一索引：索引列的值必须唯一，但允许有空值，主键索引是一种特殊的唯一索引，不允许有空值（比如自增ID） 单列索引和组合索引 单列索引： 即一个索引只包含单个列，一个表可以有多个单列索引 组合索引： 指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。 全文索引： 类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建，MySQL中只有MyISAM存储引擎支持全文索引 索引的优点索引除了可以让服务器快速地定位到指定位置，还有其他附加作用 对于B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。 优点： 索引减少了服务器需要扫描的数据量。 索引可以帮助服务器避免排序和临时表。 索引可将随机I/O变为顺序I/O InnoDB索引模型在InnoDB中，表都是根据主键顺序以索引的形式存放的，并且因为InnoDB采用B+ Tree，所以数据都存储在B+ Tree中。每一个索引在InnoDB里面对应一棵B+ Tree。 索引类型分为主键索引和非主键索引： 主键索引：叶子节点存的是整行数据，也称为聚簇索引。 非主键索引：叶子节点内容是主键的值，也称为二级索引。 对主键索引和非主键索引查询的区别： 主键查询方式只需要查询主键的B+ Tree。 普通查询需要先索引该列的B+ Tree，然后找到对应的主键，再进行主键查询，该过程称为回表。 如何选择主键一般情况下，使用自增主键是个比较好的选择： 可以减少插入/删除行时的分页/合并消耗。 主键长度越小，普通索引的叶子节点越小(因为叶子节点存储的是主键)。 下面这种场景下，可以直接使用业务字段做主键 只有一个索引 该索引必须是唯一索引 什么时候要使用索引 主键自动建立唯一索引。 经常作为查询条件在WHERE或者ORDER BY语句中出现的列要建立索引 作为排序的列要建立索引。 查询中与其他表关联的字段，外键关系建立索引。 高并发条件下倾向组合索引。 什么时候不要使用索引 经常增删改的的列不要建立索引。 有大量重复的列不要建立索引。 表记录太少不要建立索引。 在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。 在索引的列上使用表达式或者函数会使索引失效。 在查询条件中使用正则表达式，只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。 在查询条件中使用&lt;&gt;会导致索引失效。 在查询条件中使用IS NULL会导致索引失效。 在查询条件中使用OR连接多个条件会导致索引失效，这时应该改为两次查询，然后用UNION ALL连接起来。 尽量不要多列排序，如果一定要，最好为这队列构建组合索引。 索引操作创建表时创建索引在执行CREATE TABLE语句时可以创建索引,也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。12345CREATE TABLE table_name( column_name data_type, ...... [UNIQUE|FULLTEXT|SPATIAL] &#123;INDEX|KEY&#125; index_name [USING &#123;BTREE | HASH&#125;] (col_name [(length)] [ASC | DESC]...); 为已存在表创建索引1234ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING &#123;BTREE | HASH&#125;] (col_name [(length)] [ASC | DESC]...)ALTER TABLE table_name ADD PRIMARY KEY (col_name [(length)] [ASC | DESC]..)CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING &#123;BTREE | HASH&#125;] ON tbl_name (col_name [(length)] [ASC | DESC],...) 删除索引12DROP INDEX index_name ON talbe_nameALTER TABLE table_name DROP INDEX index_name 联合索引123456CREATE TABLE t（ a INT, b INT, PRIMARY KEY（a）, KEY idx_a_b（a, b））ENGINE=InnoDB 联合索引的第二个好处是已经对第二个键值进行了排序处理。 全文索引12345678910111213//创建表的时候添加FULLTEXT索引CTREATE TABLE my_table( id INT(10) PRIMARY KEY, name VARCHAR(10) NOT NULL, my_text text CHARACTER SET utf8 COLLATE utf8_general_ci NULL, FULLTEXT(my_text));//创建表以后，在需要的时候添加FULLTEXT索引ALTER my_table ADD FULLTEXT ft_index(my_text);CREATE INDEX ft_index ON my_table(my_text); 推荐阅读什么是B树 如何理解并正确使用MySQL索引 极客时间：MySQL实战45讲 —— 04深入浅出索引(上) 12参考内容 &gt;&gt; 高性能MySQL第三版 &gt;&gt; 极客时间：MySQL实战45讲 —— 04深入浅出索引(上)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>InnoDB</tag>
        <tag>B-Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 2.数据类型及优化]]></title>
    <url>%2F2018%2F12%2F02%2FMySQL-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据类型选择原则 更小的通常更好(占用空间少)：但需要注意，不要低估值的范围 简单的更好：如整形比字符型好 尽量避免NULL：如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较更为复杂，并且会使用更多存储空间。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。尤其是有索引的列，应该避免可以为NULL。InnoDB对于稀疏数据(只有少数行为非NULL)，可以使用可以为NULL的列。 数据类型整数类型： 类型 位数 TINYINT 8 SMALLINT 16 MEDIUMINT 24 INT 32 BIGINT 64 UNSIGNED为可选属性。为整形类型指定宽度，如int(11)，并不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储来说int(1)和int(20)是一样的。 实数类型：不仅只是为了存储小数部分，还可以存储比BIGINT还大的数。MySQL既支持精确类型，也支持不精确类型。 FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。 DECIMAL类型用于存储精确的小数。在5.0版本及之后，支持精确计算。CPU不支持对DECIMAL直接计算，所以在5.0及更高版本中，MySQL服务器自身实现了DECIMAL的高精度计算，所以，浮点运算速度更快。 浮点和DECIMAL类型都可以指定精度。MySQL5.0及更高版本将数字打包保存到一个二进制字符串中。 MySQL5.0和更高版本DECIMAL最多允许65个数字。早期版本限制为254个数字且每个数字为一个字节。但其实并不能在计算中使用这么大的数字，因为早期版本DECIMAL只是一种存储格式，计算时会转换为浮点型。 应该只在对小数进行精确计算时才使用DECIMAL，在数据量比较大时，可以考虑BIGINT代替DECIMAL，将需要的单位根据小数位数乘以相应倍数即可。 字符串类型：VARCHAR和CHAR是两种最主要的字符串类型。 VARCHAR：VARCHAR类型用于存储可变长字符串。比定长类型更节省空间。但如果MySQL表使用ROW_FORMAT = FIXED创建的话，每一行都会使用定长存储，会很浪费空间。VARCHAR需要使用1或两个额外字节记录字符串长度：如果列的最大长度小于或等于255字节，则只需要使用1个字节表示，否则需要两个。 由于行是可变的，UPDATE时可能需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，不同的存储引擎处理方式不一样。例如，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页使行可以放进页内。 在5.0或更高版本，MySQL在存储和检索时，会保留末尾空格。早期版本会剔除。 下面情况使用VARCHAR比较合适： 字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题； 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储； CHAR：CHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。 下面情况使用CHAR比较合适： 很短的字符串； 数据经常变更； 所有值都接近同一个长度。 BLOB类型和TEXT类型：都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。它们分别属于两组不同的数据类型 字符类型 对应二进制类型 TINYTEXT TINYBLOB SMALLTEXT SMALLBLOB TEXT BLOB MEDIUMTEXT MEDIUMBLOB LONGTEXT LONGBLOB MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。这两种类型的排序也和其他类型不同：只对每个列的最前max_sort_length字节而不是整个字符串做排序。 枚举类型：枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL内部会将每个值在列中的位置保存为整数，并在表的.frm文件中保存“数字-字符串”的映射关系。所以实际存储的为整数，而不是字符串。 例如： mysql &gt; CREATE TABLE enum_test( -&gt; e ENUM(&apos;fish&apos;, &apos;apple&apos;, &apos;dog&apos;) NOT NULL); mysql &gt; INSERT INTO enum_test(e) VALUES(&apos;fish&apos;), (&apos;dog&apos;), (&apos;apple&apos;); mysql &gt; SELECT e + 0 FROM enum_test; 结果： | e + 0 | | 1 | | 3 | | 2 | 如果使用数字本身作为枚举常量，会造成混乱，应避免这么做。 同样，枚举字段按照存储的整数而不是预定义的字符串进行排序。 mysql &gt; SELECT e FROM enum_test ORDER BY e; 结果： | e | | fish | | apple | | dog | 可以使用FIELD()函数显式地指定排序顺序，但会导致MySQL无法利用索引消除排序。 mysql &gt; SELECT e FROM enum_test ORDER BY FIELD(e, &apos;apple&apos;,&apos;dog&apos;,&apos;fish&apos;); 结果： | e | | apple | | dog | | fish | 枚举的缺点是，字符串列表固定，添加或删除预定义字符串，必须使用ALTER TABLE会花费许多时间。 优点是可能缩小表的大小。 日期和时间类型： DATETIME：能保存大范围的值，从1001年到9999年，精度为秒，与时区无关。使用8个字节的存储空间。 TIMESTAMP：从1970年1月1日午夜以来的秒数，使用4个字节的存储空间，只能表示1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，及UNIX_TIMESTAMP()函数把日期转换我Unix时间戳。显示值依赖于时区。默认情况下，如果插入时没有指定第一个TIMESTAMP的列的值，MySQL则设置这个列的值为当前时间。在插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值(除非在UPDATE语句中明确指定了值)。可以配置任何TIMESTAMP列的插入和更新行为。TIMESTAMP列默认为NOT NULL。 位数据类型：所有位类型，不管底层存储格式还是处理方式如何，从技术上来说都是字符串类型。在MySQL5.0之前，BIT与TINYINT相同。但在5.0及之后版本中，并不相同。 BIT：可以使用BIT在一列中存储多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)包含两个位，最大长度为64。BIT的行为因存储引擎而异。MyISAM会打包存储所有BIT的列，17个单独的BIT列只需要17个位(假设全都不可为NULL)，这样MyISAM只使用3个字节就足够了。而InnoDB为每个BIT列使用一个足够存储的最小整数类型来存放。 MySQL把BIT当作字符串类型，而不是数字类型。当检索BIT(1)的值时，结果是一个包含二进制0或1值的字符串，而不是ASCII码的“0”或“1”。但是，在数字上下文的场景中检索时，结果将是位字符串转换成的数字。例如，如果存储一个值b‘00111001’(二进制等于57)到BIT(8)的列并且检索，得到的内容是字符码为57的字符串。也就是得到ASCII码为57的字符“9”。但是在数字上下文场景中，得到的是数字57： 12345678mysql &gt; CREATE TABLE bittest(a bit(8));mysql &gt; INSERT INTO bittest VALUE(b &apos;00111001&apos;);mysql &gt; SELECT a, a + 0 FROM bittest;结果为：| a | a + 0|| 9 | 57 | 如果想在一个bit的存储空间中存储一个布尔值，一个可选的方法是创建一个可以为空的CHAR(0)列。该列可以保存空值(NULL)或者长度为零的字符串(空字符串)。 SET：如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，它在MySQL内部以一系列打包的位的集合来表示。缺点是改变列的定义的代价较高，需要ALTER TABLE，并且无法在SET列上通过索引查找。 可选的替代操作是使用一个整数包装一系列的位。例如，可以把8个位包装到一个TINYINT中，并且按位操作来使用(类似于Linux中文件的权限控制) 例如：12345678910mysql &gt; SET @CAN_READ := 1 &lt;&lt; 0, -&gt; @CAN_WRITE := 1 &lt;&lt; 1, -&gt; @CAN_DELETE := 1 &lt;&lt; 2;mysql &gt; CREATE TABLE acl (perms TINYINT UNSIGNED NOT NULL DEFAULT 0);mysql &gt; INSERT INTO acl(perms) VALUE(@CAN_READ + @CAN_DELETE);mysql &gt; SELECT perms FROM acl WHERE perms &amp; @CAN_READ;结果：| perms || 5 | MySQL schema 设计陷阱 太多关联：耗费很长时间查询和缓存。 太多的列：MySQL存储引擎API工作时，会在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列，这个过程代价很高(MyISAM定长行结构与服务器层相匹配，不需要转换)。代价依赖于列的数量 过度使用枚举：每次在枚举列中增加一个新选项，都要做一次ALTER TABLE操作 变相枚举：枚举ENUM列允许在列中存储一组定义值中的单个值，集合SET允许在列中存储一组定义值中的一个或多个值。所以当列中的值不可能同时出现多种情况时(e.g., 同一门成绩的挂科和通过不可能同时存在)，应该使用枚举代替集合。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL数据类型</tag>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 1.MySQL架构与引擎]]></title>
    <url>%2F2018%2F12%2F01%2FMySQL-1-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[基础架构MySQL服务器逻辑架构: 最上层服务负责连接处理、授权认证。安全等。 第二层包含了MySQL的大多核心功能，包括查询解析、分析、优化、缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。 第三层为存储引擎，存储引擎负责MySQL中数据的存储和提取。存储引擎不负责解析SQL(InnoDB是例外，它会解析外键定义)，不同存储引擎也不会相互通信。 并发控制读写锁：读锁也叫共享锁，写锁也叫排它锁。读锁是相互不阻塞的，多个用户在同一时刻可以同时读取同一个资源，而且互不干扰。写锁是排他的，一个写锁会阻塞其他的写锁和读锁，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。 表锁：开销最小的策略，会锁定整张表。一个用户在对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列之前。 行锁：可以最大程度支持并发处理，但同时锁开销最大。行级锁只在存储引擎层实现。 事务 事务是一组原子性的SQL查询。事务内的语句，要么全部执行成功，要么全部失败。 事务具有ACID的特性: Atomicity(原子性)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能执行其中的一部分操作，这就是事务的原子性。 Consistency(一致性)：数据库总是从一个一致性的状态转换到另外一个一致性的状态。 Isolation(隔离性)：通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的。 Durability(持久性)：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。 隔离级别: 未提交读(Read Uncommitted)：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，也被称为脏读(Dirty Read)。一般很少使用 提交读(Read Committed)：一个事务开始时，只能看见已经提交的事务所做的修改。即一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。也叫做不可重复读(nonrepeatable read)，因为两次同样的查询，可能得到不一样的结果。 可重复读(Repeatable Read)：解决了脏读问题，同时保证了在同一个事务中多次读取同样记录的结果是一致的。但无法解决幻读(Phantom Read)问题，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和XtraDB通过多版本并发控制(MVCC)解决了幻读问题。 可串行化(Serializable)：通过强制事务串行执行，避免了幻读。会在读取的每一行数据上都加锁。 隔离级别 脏读 不可重复读 幻读 加锁读 未提交读 √ √ √ × 提交读 × √ √ × 可重复读 × × √ × 可串行读 × × × √ 可以通过SET TRANSACTION ISOLATION LEVEL设置隔离级别。 mysql &gt; SET SESSION TRANSACTION ISOLATION LEVER ***; *** 为相应级别 死锁：锁的行为和顺序是和存储引擎相关的，以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁发生后，只有部分或者完全回滚其中一个事务才能打破死锁。对于事务型系统是无法避免的。 InnoDB解决死锁的方法是，将持有最少行级排他锁的事务进行回滚。 事务日志：事务日志可以帮助提高事务效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快的多。事务日志持久以后，内存中被修改的数据可以慢慢刷回到磁盘。称之为预写式日志(Write-Ahead Logging)，修改数据需要写两次磁盘。 自动提交：MysQL默认采用自动提交事务，如果不显式地开始一个事务，则每个查询都被当做一个事务执行提交操作，可以通过设置AUTOCOMMIT变量来查看。 mysql &gt; SHOW VARIABLES LIKE &apos;AUTOCOMMIT&apos;; mysql &gt; SET AUTOCOMMIT = 1; 1或者on表示启用，0或者off表示禁用。当AUTOCOMMIT= 0时，所有查询在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事务。修改AUTOCOMMIT对非事务型的表，比如MyISAM是无效的，因为对这类表来说，没有COMMIT和ROLLBACK的概念，可以看成一直处于AUTOCOMMIT开启状态。还有些命令，在执行前会强制COMMIT提交当前活动事务，如会导致大量数据改变的操作(e.g., ALTER TABLE) 在同一事务中，使用多种存储引擎是不可靠的(如事务型引擎和非事务引擎，回滚会造成数据不一致) 隐式和显式锁定：InnoDB采用两段锁定协议(two-phase locking protocol)。在事务执行过程中，随时可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。这些都属于隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁 InnoDB也支持显示锁定，但不属于SQL规范，如： SELECT ... LOCK IN SHARE MODE SELECT ... FOR UPDATE 多版本并发控制(MVCC):MVCC是行级锁的一个变种，但是在很多情况下避免了加锁操作，大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC通过保存数据在某个时间点的快照来实现的。不管执行多长时间，每个事务看到的数据都是一致的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。 InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是实际的是兼职，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。 SELECT：InnoDB会根据以下两个条件检查每行记录： InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始前未被删除。只有符合上述两个条件的记录，才能返回作为查询结果。 INSERT：InnoDB为新插入的每一行保存当前系统版本号作为版本号。 DELETE：InnoDB为删除的每一行保存当前系统版本号作为删除标识。 UPDATE：InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。 MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作。其他两个级别不兼容，因为READ UNCOMMITTED总是读取最新数据行，而SERIALIZABLE则会对所有读取的行都加锁。 存储引擎mysql &gt; SHOW TABLE STATUS LIKE &apos;***&apos; 用来查看表的相关信息，***为表名 InnoDB：被设计用来处理大量短期事务(short-lived)事务，短期事务大部分情况是正常提交的，很少被回滚。InnoDB的数据存储在表空间(tablespace)中，表空间是由InnoDB管理的一个黑盒子，由一系列数据文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。也可以使用裸设备作为表空间的存储介质。InnoDB采用MVCC支持高并发，默认隔离级别为可重复读，并且通过间隙锁(next-key locking)策略防止幻读。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。 InnoDB表基于聚簇索引建立，所以对主键查询有很高的性能，不过二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应尽可能的小。 MyISAM：提供了大量特性，包含全文索引、压缩、空间函数。但不支持事务和行级锁，而且没有安全的崩溃恢复。对于只读的数据，或者表比较小、可以容忍修复操作，则可以使用MyISAM。 MyISAM会将表存储在：数据文件和索引文件中。表可以包含动弹或者静态(长度固定)行。MySQL会根据表的定义来决定采用何种行格式。MyISAM表可以存储的行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸. 特性： 加锁与并发：对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也可以往表中插入新的记录。 修复：MySQL可以手工或者自定执行检查和修复操作，这里修复与事务恢复和崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，可以通过CHECK TABLE mytable检查表的错误，如果有错误可以通过执行REPAIR TABLE mytable进行修复。 索引：即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。同时也支持全文索引。 延迟更新索引键：创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。可以提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置。 压缩表：压缩表不能进行修改，支持索引，但索引也是只读的。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>存储引擎</tag>
        <tag>ACID</tag>
        <tag>隔离级别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 3.Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个字符串，找出最长不重复子串。 例子： 输入: &quot;abcabcbb&quot; 输出: 3 解释：&quot;abc&quot; 输入: &quot;bbbbb&quot; 输出: 1 解释：&quot;b&quot; 输入: &quot;pwwkew&quot;&quot; 输出: 3 解释：&quot;wke&quot; 注意子串必须是连续的。 解题方法使用hash保存出现过的字符和位置。使用一个cur变量记录当前子串长度，start变量记录当前子串起始位置。遍历字符串，有三种可能： 如果当前字符没出现过，就将该字符与下标存到hash中，当前子串长度cur加1。 如果当前字符出现过，但是上一次出现的位置不在当前记录的子串中，就把当前长度cur加1，并把该字符在hash中的位置更新。 如果当前字符出现过，并且上一次出现的位置在当前子串中，说明该子串含有重复字符了，就把start变为上一次出现位置的后一个(这样可以保证子串中没有重复字符)。然后将当前子串长度更新，并把当前字符的位置更新。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char,int&gt; H; map&lt;char,int&gt;::iterator it; int max = 0; int start = 0; int cur = 0; for(int i = 0;i&lt;s.size();i++)&#123; it = H.find(s[i]); if(it==H.end())&#123; H.insert(pair&lt;char,int&gt;(s[i],i)); cur++; &#125;else&#123; if(it-&gt;second&lt;start)&#123; cur++; &#125;else&#123; start = it-&gt;second + 1; cur = i - start + 1; &#125; it-&gt;second = i; &#125; max = max&gt;cur?max:cur; &#125; max = max&gt;cur?max:cur; return max; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>哈希</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1.Two Sum]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个整数数组和一个目标值，返回两个相加等于目标值的数的下标。你可以假设每组输入只有一个正确答案，并且你不能使用同一个元素两次。 例子： 输入： nums = [2, 7, 11, 15], target = 9, 输出： [0,1] 解释： 因为num[0] + nums[1] = 2 + 7 = 9 解题方法解法1：使用hash，如果target与当前数的差已经在hash中就返回两个数的下标，否则把当前数加入到hash中。 解法2：将原数组的值和下标放在一个pair中，并组成一个新的数组，将该数组升序排列。从两端向里遍历，若两端的数的和大于target，则将右端向左移动。若两端数的和小于target，则左端向右移动，直到找到和为target的两个数字。 代码123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2); if(nums.size()&lt;=1) return res; map&lt;int,int&gt; H; map&lt;int,int&gt;::iterator it; for(int i = 0;i&lt;nums.size();i++)&#123; it = H.find(target - nums[i]); if(it == H.end())&#123; H.insert(pair&lt;int,int&gt;(nums[i],i)); &#125;else&#123; res[0] = it-&gt;second; res[1] = i; break; &#125; &#125; return res; &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;private: static bool cmp(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) &#123; return A.first &lt; B.first; &#125;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, 0); vector&lt;pair&lt;int, int&gt;&gt; temp; for (int i = 0; i&lt;nums.size(); i++) temp.push_back(pair&lt;int, int&gt;(nums[i], i)); sort(temp.begin(), temp.end(), cmp); int i = 0, j = temp.size() - 1; while (i&lt;j) &#123; if (temp[i].first + temp[j].first&gt;target) j--; else if (temp[i].first + temp[j].first&lt;target) i++; else &#123; res[0] = temp[i].second &lt; temp[j].second ? temp[i].second : temp[j].second; res[1] = temp[i].second &gt;= temp[j].second ? temp[i].second : temp[j].second; return res; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>哈希</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 1.MyBatis基本构成]]></title>
    <url>%2F2018%2F12%2F01%2FMyBatis-1-MyBatis%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[MyBatis核心组件： SqlSessionFactoryBuilder(构造器)：它会根据配置信息或者代码来生成SqlSessionFactory(工厂接口)。 SqlSessionFactory：依靠工厂来生成SqlSession(会话)。 SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口。 SQLMapper：由一个Java接口和XML文件(或注解)构成的，需要给出对应的SQL和映射规则，负责发送SQL去执行，并返回结果。 构建SqlSessionFactory：每个MyBatis应用都是以SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactory是一个工厂接口而不是现实类，它的任务是创建SqlSession。SqlSession类似于JDBC的Connection对象。MyBatis提供了两种模式去创建SqlSessionFactory： XML配置(推荐) 代码 Mybatis中有一个Configuration类存在于整个MyBatis应用的生命期中，以便重复读取和运用。可以解析一次配置的XML文件保存到Configuration类对象中，方便从这个对象中读取配置信息，性能高。单例占用空间小，基本不占用存储空间，而且可以反复使用。Configuration类对象保存着配置在MyBatis的信息。在MyBatis中提供了两个SqlSessionFactory的实现类，DefaultSqlSessionFactory和SqlSessionManager。不过SqlSessionManager目前没有使用。 创建SqlSession：SqlSession是一个接口类，真正工作的是Executor接口。构建了SqlSessionFactory，然后生成SqlSession。SqlSession接口类似于一个JDBC中的Connection接口对象，需要保证每次用完正常关闭，所以正确做法是将关闭SqlSession接口的代码写在finally语句中保证每次都会关闭SqlSession。 123456789101112131415// 定义SqlSession Sqlsession sqlSession = null; try &#123; // 打开SqlSession会话 sqlSession = sqlSessionFactory.openSession(); //... sqlSession.commit(); &#125; catch(Exception ex) &#123; sqlSession.rollback(); &#125;finally &#123; // 确保资源被正确关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; 主要用途有两种： 获取映射器，让映射器通过命名空间和方法名称找到对应的SQL，发送给数据库执行后返回结果。 直接通过命名信息去执行SQL返回结果。在SqlSession层可以通过update、insert、select、delete等方法，带上SQL的id来操作在XML中配置好的SQL。 映射器：由Java接口和XML文件(或注解)共同组成的，它的作用如下。 定义参数类型。 描述缓存。 描述SQL语句。 定义查询结果和POJO的映射关系。同样有XML和代码两种方式生成。 组件的生命周期 SqlSessionFactoryBuilder：一旦构建了SqlSessionFactory，它的作用就已经完结，应该被回收。所以它的生命周期只存在于方法的局部，作用是生成SqlSessionFactory对象。 SqlSessionFactory：作用是创建SqlSession(相当于JDBC的Connection对象)。每次应用程序需要访问数据库，就要通过SqlSessionFactory创建SqlSession，所以SqlSessionFactory存在于应用的整个生命周期中。应该采用单例模式(一般方法为将构造方法私有化，并给出一个静态方法，让其返回唯一单例，在多线程初始化单例时，一般需要加线程锁避免类对象被多次初始化)，以避免创建更多SqlSessionFactory而消耗资源。所以一个数据库只应该对应一个SqlSessionFactory。 SqlSession：一个会话，相当于JDBC一个Connection对象，生命周期是在请求数据库处理事务的过程中。该对象线程不安全，应该属于其隔离级别，数据库锁等特性。每次创建的SqlSession都应及时关闭，避免占用数据库连接池。所以，它存活于一个应用的请求和操作中，可以执行多条SQL。 Mapper：是一个接口，没有任何实现类，作用是发送SQL，并返回需要的结果，或者执行SQL以修改数据库数据。因此应该在一个SqlSession事务方法之内，属于方法级别。类似于JDBC中的一条SQL语句的执行，最大的范围和SqlSession相同。 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
