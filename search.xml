<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[MyBatis] 4.映射器(三)——sql/resultMap元素]]></title>
    <url>%2F2018%2F12%2F08%2FMyBatis-4-%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%89-%E2%80%94%E2%80%94sql-resultMap%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[sql元素可以定义一串SQL语句，在其他语句(e.g., select)中可以引用。 例如， 1234567891011&lt;sql id = "role_columns"&gt; id, role_name, note&lt;/sql&gt;&lt;select parameterType = "long" id = "getRole" resultMap = "roleMap"&gt; select &lt;include refid = "role_columns"/&gt; from t_role where id = #&#123;id&#125;&lt;/select&gt;&lt;select parameterType = "map" id = "findRoles"&gt; select id, role_name, note from t_role where rold_name like #&#123;roleName&#125; and note like #&#123;note&#125;&lt;/select&gt; 这个例子中，用sql元素定义了role_columns，并使用refid元素进行引用。 也可以制定参数来使用1234567891011&lt;sql id = "role_columns"&gt; #&#123;prefix&#125;.role_no, #&#123;prefix&#125;.role_name, #&#123;prefix&#125;.note&lt;/sql&gt;&lt;select parameterType = "string" id = "getRole" resultMap = "roleResultMap"&gt; select &lt;include refix = "role_columns"&gt; &lt;property name = "prefix" value = "r"/&gt; &lt;/include&gt; from t_role r where role_no = #&#123;roleNo&#125;&lt;/select&gt; 还可以给refid一个参数值，由程序制定引入SQL123&lt;sql id = "someinclude"&gt; select * from &lt;include refid = "$&#123;tableName&#125;"/&gt;&lt;/sql&gt; resultMap结果映射集resultMap 元素的构成resultMap元素里的元素 12345678910111213&lt;resultMap&gt; &lt;constructor&gt; &lt;idArg/&gt; &lt;arg/&gt; &lt;/constructor&gt; &lt;id/&gt; &lt;result/&gt; &lt;association/&gt; &lt;collection/&gt; &lt;discriminator&gt; &lt;case/&gt; &lt;discriminator/&gt;&lt;/resultMap&gt; constructor：用来配置构造方法，一个POJO可能可能不存在没有参数的构造方法，这个时候可以用constructor进行配置。例如， 1234&lt;constructor&gt; &lt;idArg column = "id" javaType = "int"/&gt; &lt;arg column = "role_name" javaType = "string"/&gt;&lt;/constructor&gt; id：表示哪个列是主键，允许多个主键，多个主键称为联合主键。 result：配置POJO到SQL列名的映射关系。 result元素和id元素的属性 元素名称 说明 备注 property 映射到列结果的字段或属性。如果POJO的属性匹配是存在的，和给定SQL列名(column元素)相同的，那么MyBatis就会映射到POJO上 可以使用导航式字段，比如访问一个学生对象(Student)需访问学生证(selfcard)的发证日期(issueDate),那么我们可以写成selfcard.issueDate column 这里对应的是SQL的列 - javaType 配置Java的类型 可以是特定的类完全限定名或者MyBatis上下文的别名 jdbcType 配置数据库类型 JDBC的类型 typeHandler 类型处理器 允许使用特定的处理器来覆盖MyBatis默认处理器，需要制定jdbcType和javaType的相互转化规则 使用map存储结果集123&lt;select id = "findColorByNote" parameterType = "string" resultType = "map"&gt; select id, color, note from t_color where note like #&#123;note&#125;&lt;/select&gt; 可读性比较差，并不推荐 使用POJO存储结果集配置代码如图 12345&lt;resultMap id = "roleResultMap" type = "Role"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "roleName" column = "role_name"/&gt; &lt;result property = "note" column = "note"/&gt;&lt;/resultMap&gt; resultMap中的id属性：代表这个resultMap的标识 resultMap中的type属性：代表需要映射的POJO id元素：表示主键 property：表示POJO属性名称 column：表示数据库SQL列名 使用resultMap的代码123&lt;select parameterType = "long" id = "getRole" resultMap = "roleResultMap"&gt; select id, note_name, note from t_role where id = #&#123;id&#125;&lt;/select&gt; 推荐阅读基于MyBatis实现的JavaWeb项目源码-github 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 5.索引(三)——聚簇索引]]></title>
    <url>%2F2018%2F12%2F04%2FMySQL-5-%E7%B4%A2%E5%BC%95-%E4%B8%89-%E2%80%94%E2%80%94%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[聚簇索引聚簇索引是一种数据存储方式，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中(叶子页包含了行的全部数据，节点页只包含了索引列)。“聚簇”表示数据行和相邻的键值紧凑的存储在一起。一个表只能有一个聚簇索引。 InnoDB会选择主键列进行聚簇索引，如果没有定义主键，InnoDB会选择唯一的非空索引代替。如果还是没有，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。 聚簇索引优点： 可以把相关的数据保存在一起，例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数数据页就能获取某个用户的全部邮件，减少磁盘I/O次数。 数据访问更快：聚簇索引同时将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据要比非聚簇索引更快。 使用覆盖索引扫描的查询可以直接使用节点中的主键值。 聚簇索引缺点： 聚簇索引最大限度地提高了I/O密集型应用的性能。如果数据全放放在内存中，那么聚簇索引就没了优势。 插入速度严重依赖于插入顺序。按照主键顺序插入最快。 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。页分裂会导致表占用更多磁盘空间 当行比较稀疏，或者有由于页分裂导致数据存储不连续的时候，可能会导致全表扫描变慢。 二级索引(费聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。 二级索引访问需要两次索引查找，而不是一次(因为二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值)。 InnoDB和MyISAM数据分布对比对于以下这个表，InnoDB和MyISAM存储方式不同：1234567CREATE TABLE layout_test ( col1 int NOT NULL, col2 int NOT NULL, PRIMARY KEY(col1), KEY(col2)); MyISAM的数据分布MyISAM按照数据插入的顺序存储在磁盘上，如图所示。因为这里行是定长的，所以MyISAM可以从表的开头跳过所需字节直接找到需要的行。可以看出MyISAM的主键索引和其他索引在结构上没有不同。 InnoDB的数据分布如图所示，可以发现图中显示了整个表，而不仅仅是索引。因为在InnoDB中，聚簇索引就是表，不需要像MyISAM那样需要独立的行存储。 聚簇索引的每一个叶子结点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列(在这里是col2)。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。 另一点和MyISAM不同的是，InnoDB的二级索引和聚簇索引并不相同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样会减少当出现行移动或者数据页分裂(上文有提到)时二级索引的维护工作。使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动时无需更新二级索引中的这个“指针”。 在InnoDB表中按主键顺序插入行尽量按主键顺序插入行，最简单的方法使用自增列(AUTO_INCREMENT)。因为这样填充时，当页满时，下一条记录就可以写在新页中。而如果无序插入，那么每次都要为行找到合适的位置，会增加许多额外工作。有以下一些缺点 写入的目标页可能已经刷新到磁盘上，并从缓存中移除，InnoDB在插入前必须先找到并从磁盘读取目标页到内存中，导致大量随机I/O。 因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页，而不是一个页。 频繁的页分裂，页会变得稀疏并被不规则地填充，最终会有碎片。 对于高并发工作负载，按主键顺序可能导致性能下降。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>MySQL性能</tag>
        <tag>InnoDB</tag>
        <tag>MyISAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 19.Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F12%2F04%2FLeetCode-19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个链表和一个整数n，返回链表倒数第n个结点。 例子： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. 输出: 1-&gt;2-&gt;3-&gt;5. 备注: n永远是有效的。 要求一次遍历。 解题方法使用两个指针p，q分别指向链表头。p先走n次，如果p走到头就说明n大于等于链表长度，就删除头结点(所以新建了一个h指向头结点，便于删除头结点)。如果p没有走到头，就让p和q一起走，直到p走到头，q指向的就是要删除的结点。 代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *h = new ListNode(0); h-&gt;next = head; ListNode *p =h ,*q=h; while(n--&amp;&amp;p!=NULL) p = p-&gt;next; if(n&gt;0) return NULL; while(p&amp;&amp;p-&gt;next)&#123; p = p-&gt;next; q = q-&gt;next; &#125; q-&gt;next= q-&gt;next-&gt;next; return h-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 4.索引(二)——高性能索引]]></title>
    <url>%2F2018%2F12%2F04%2FMySQL-4-%E7%B4%A2%E5%BC%95-%E4%BA%8C-%E2%80%94%E2%80%94%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[如果使用高性能索引独立的列：如果查询中的列不是独立的，则MySQL不会使用索引。“独立的列” 指的是索引列不能是表达式的一部分，也不能是函数的参数。 例如， 1mysql &gt; SELECT actor_id FROM actor where actor_id +1 =5; 这个查询就无法使用actor_id列的索引，因为它是表达式的一部分。但是如果我们把where的表达式写成actor_id = 4 就可以使用这列的索引了。所以，在写where语句时，尽量将索引列单独放在比较符号的一侧。 前缀索引和索引选择性：索引的选择性是指：不重复的索引值(基数，cardinality)和数据表的记录总数(#T)的比值，范围从 1/#T 到 1 之间。索引的选择性越高，则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 前缀索引：对于一些很长的字符列，通常只索引开始的部分字符。例如BLOB、TEXT或很长VARCHAR，必须使用前缀索引，因为MySQL索引长度有限制。选择前缀索引时，应该让前缀索引的“基数”接近于完整列的“基数”。前缀索引的缺点是无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。 如何计算索引选择性：下面给出一个例子，演示如何计算完整列和不同长度前缀的的选择性： 1234567891011mysql &gt; CREATE TABLE city_demo (city VARCHAR(50) NOT NULL);-- 随机向city_demo中插入许多城市(可重复)--计算完整列的选择性mysql &gt; SELECT COUNT(DISTINCT city) / COUNT(*) FROM city_demo;--计算不同长度前缀的选择性(下面例子为长度为3，4，5的前缀)mysql &gt; SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3, COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4, COUNT(DISTINCT LEFT(city, 5))/COUNT(*) AS sel5 FROM city_demo 如何创建前缀索引：12--创建前缀长度为5的索引mysql &gt; ALTER TABLE city_demo ADD KEY (city(5)); 特殊用处：可以用来做后缀索引，其基本原理是把想要存储的信息(如电子邮件地址)反转后存储，然后建立前缀索引。这样可以用来查找电子邮件域名等。 多列索引：一个常见的错误是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。为每个列创建独立的索引，在WHERE语句中需要多个列的条件时，并不是最优的结果。 多列索引中列正确的顺序依赖于使用该索引的查询，并且应该更好地满足排序和分组的需要。索引首先按照最左列进行排序，其次是第二列，等等(对于B-Tree索引来说)。 将选择性最高的列放在前面通常是很好的。这对于优化WHERE 条件很有帮助，但是并不会提升排序和分组的效率。性能不止依赖于列的选择性，也和查询条件的值的分布有关。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>MySQL性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 14.Longest Common Prefix]]></title>
    <url>%2F2018%2F12%2F03%2FLeetCode-14-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[题目翻译给定一组字符串，找到这些字符串的最小前缀。 解题方法这些字符串的前缀的最大长度不可能超过这些字符串中最小的那个的长度。所以可以先找到那个最小的作为暂时的最大前缀，然后挨个与其他字符串比较，出现不一样的字符就删除该字符及之后的所有字符。 代码123456789101112131415161718192021class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return ""; string pattern = strs[0]; for(int i = 1;i&lt;strs.size();i++) pattern = pattern.size()&lt;strs[i].size()?pattern:strs[i]; for(int i = 0;i&lt;strs.size();i++)&#123; for(int j = 0;j&lt;pattern.size();j++)&#123; if(strs[i][j]!=pattern[j])&#123; pattern.erase(pattern.begin()+j,pattern.end()); break; &#125; &#125; &#125; return pattern; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 11.Container With Most Water]]></title>
    <url>%2F2018%2F12%2F03%2FLeetCode-11-Container-With-Most-Water%2F</url>
    <content type="text"><![CDATA[题目翻译给定n个数字代表n条线段，每个线段的下标为它的横坐标，值为它的高度。使用两个线段和x轴组成一个装水的容器，求出最大的容器。你可以假设容器都是直的，并且n大于等于2。 解题方法既然是装水的容器，那么高度只能由两个线段中较短的那个决定，所以用i, j表示数组里两个数，可知 $容积=min(height[i], height[j])*abs(j-i)$。很容易可以想到暴力求解算法。但是可以进行优化。首先i，j分别为数组两端数字，并向中间移动。可知这时i，j之间影响容量大小的为短的那条边，因为高的那条边向里移动容积一定会减少。所以只要每次向里移动较短的那条边就可以了。 代码123456789101112131415161718192021class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int i = 0, j = height.size()-1; int max = 0; int cur = 0; while(i&lt;j)&#123; if(height[i]&lt;height[j])&#123; cur = height[i]*(j-i); i++; &#125; else&#123; cur = height[j]*(j-i); j--; &#125; max = max&gt;cur?max:cur; &#125; return max; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 3.映射器(二)——insert/update/delete元素]]></title>
    <url>%2F2018%2F12%2F03%2FMyBatis-3-%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%8C-%E2%80%94%E2%80%94insert-update-delete%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[insert元素MyBatis会在执行插入之后返回一个整数，以表示进行操作后插入的记录数。 属性名称 说明 备注 id 它和Mapper的命名空间组合起来是唯一的，提供给MyBatis调用(其实就是Dao中对应的方法名) 如果命名空间和id组合起来不唯一，MyBatis将抛出异常 parameterType 传入参数的类型，例如long，String等(可以给出类的全命名，也可以给出类的别名，但别名必须是MyBatis内部定义或自定义的) 可以选择JavaBean、Map等复杂的参数类型 parameterMap 即将废弃，不建议使用 - flushCache 调用SQL后，是否要求MyBatis清空之前查询的本地缓存和二级缓存 true/false，默认为false timeout 设置超时参数，等超时的时候将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数 statementType 告诉MyBatis使用哪个JDBC的Statement工作，取值为STATEMENT(Statement)、CallableStatement 默认值为PREPARED keyProperty 表示以哪个列作为属性的主键，不能和keyColumn同时使用 设置哪个列为主键，联合主键可以用逗号隔开 useGenerateKeys 这会令MyBatis使用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键，例如，MySQL和SQLSever自动递增字段，Oracle的序列等，但是使用它就必须要给KeyProperty或者keyColumn赋值 true/false。默认为false keyColumn 指明第几列是主键，不能和keyProperty同时使用，只接受整形参数 和keyProperty一样，联合主键可以用逗号隔开 databaseId 取决于数据库厂商 - lang 自定义语言，可以使用第三方语言 - 插入实例：123&lt;insert parameterType = "role" id = "insertRole"&gt; insert into t_role(role_name, note) values(#&#123;roleName&#125;, #&#123;note&#125;)&lt;/insert&gt; 主键回填和自定义：MySQL中的主键可能需要根据一些特殊规则声称，例如自增字段，再插入后我们需要获得该主键。可以使用keyProperty属性指定哪个是主键字段，同时使用useGeneratedKeys属性告诉MyBatis这个主键是否使用数据库内置策略生成。例如，下面的例子中，id为表t_role的自增字段 123&lt;insert id = "insertRole" parameterType = "role" useGeneratedKeys = "true" keyProperty = "id"&gt; insert into t_role (role_name, note) values(#&#123;roleName&#125;, #&#123;note&#125;)&lt;/insert&gt; 我们传入的role对象，无需设置id的值，MyBatis会根据数据库的设置自动处理，在处理完毕后，MyBatis会自动回填MySQL数据库生成的id值到传入的JavaBean中。 实际工作中，还可能有一些更复杂的要求。例如，如果表t_role中没有记录，则设置id=1，否则取当前最大id加2，成为新的主键。这时需要使用selectKey元素处理 123456&lt;insert id = "insertRole" parameterType = "role" useGeneratedKeys = "true" keyProperty = "id"&gt; &lt;selectKey keyProperty = "id" resultType = "int" order = "BEFORE"&gt; select if ( max(id) is null, 1, max(id) + 2 ) as newId from t_role &lt;/selectKey&gt; insert into t_role(id, role_name, note) values (#&#123;id&#125;, #&#123;roleName&#125;, #&#123;note&#125;)&lt;/insert&gt; update元素和insert一样，MyBatis执行完update元素后会返回一个整数，代表进行更新的记录数。 更新实例：123456&lt;update parameterType = "role" id = "updateRole"&gt; update t_role set role_name = #&#123;roleName&#125;, note = #&#123;note&#125; where id = #&#123;id&#125;&lt;/update&gt; delete元素和insert一样，MyBatis执行完delete元素后会返回一个整数，代表进行删除的记录数。 删除实例：123&lt;delete id = "delete" parameterType = "long"&gt; delete from t_role where id = #&#123;id&#125;&lt;/delete&gt; 特殊字符串替换和处理优势我们想要传递SQL语句本身，而不是SQL所需的参数。例如，我们可能想要传递SQL列名，可以使用$符号实现。 1select $&#123;columns&#125; from t_tablename 但是这样对于SQL而言是不安全的。 推荐阅读基于MyBatis实现的JavaWeb项目源码-github 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 9.Palindrome Number]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-9-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[题目翻译求给定的数是否为回文数。 解题方法使用一个新数将原数反转，要是相等就是回文数，注意负数没有回文数。 代码1234567891011121314class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0) return 0; int newnum=0; int temp=x; while(temp)&#123; newnum=newnum*10+temp%10; temp/=10; &#125; return newnum==x; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 8.String to Integer]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-8-String-to-Integer%2F</url>
    <content type="text"><![CDATA[题目翻译实现atoi函数，将字符串变为整数。 输入的开头可能存在许多无用的空格，需要忽视掉。 空格后可能包含代表数正负的 ‘+’ 号和 ‘-‘ 号。 如果遇到不符合的字符就返回0。 如果溢出就按溢出方向返回INT_MAX (2147483647) 或 INT_MIN (-2147483648) 解题方法跳过开头的空格，然后判断是否存在 ‘+’ 号和 ‘-‘ 号。然后按序转换，遇到不符合字符退出。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int myAtoi(string str) &#123; if(str.size()==0) return 0; long long res = 0; int i = 0; for(i = 0;i&lt;str.size();i++)&#123; if(str[i]!=' ') break; &#125; if(i==str.size()) return 0; int flag = str[i]=='-'?-1:1; if(str[i]=='+'||str[i]=='-') i++; for(i;i&lt;str.size();i++)&#123; if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')&#123; res = res*10 + (str[i]-'0'); if(res*flag&gt;INT_MAX||res*flag&lt;INT_MIN) return flag&gt;0?INT_MAX:INT_MIN; &#125;else break; &#125; return res*flag; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 7.Reverse Integer]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个32位有符号整数，将这个数翻转。 例子： 输入：123 输出：321 输入：-80 输出：-8 注意：只考虑32位数，如果翻转后数字溢出返回0。 解题方法将原数每次模10加到输出上然后乘以10。 代码123456789101112class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x)&#123; res = res*10 + x%10; x/=10; &#125; return (res &lt; INT_MIN || res &gt; INT_MAX) ? 0 : res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 6.ZigZag Conversion]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-6-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[题目翻译给定字符串 “PAYPALISHIRING” 与特定数字numRows = 3，字符串实际显示方式为 P A H N A P L S I I G Y I R 从左到右，从上到下输出它们，结果为 “PAHNAPLSIIGYIR”。 解题方法通过找规律可得原字符串 n的值为 2 * (numRows - 1)。 第一行的字符在原字符串的位置为(0, 0+n, 0+2n…)。 第二行为(1, 1+n-2, 1+n, 1+2(n-2), 1+2n…)。 最后一行的值为( numRows-1, numRows-1+n, numRows-1+2n…)。 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows&gt;=s.size()||numRows&lt;=1) return s; string res(s); int flag = (numRows - 1)&lt;&lt;1; int m = flag, n = flag - m; int level = 0; int total = 0; while(m&gt;=0)&#123; int i = level; while(i&lt;s.size())&#123; if(m!=0)&#123; res[total++] = s[i]; i+=m; &#125; if(i&lt;s.size()&amp;&amp;n!=0)&#123; res[total++] = s[i]; i+=n; &#125; &#125; level++; m-=2; n+=2; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>数学规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 2.映射器(一)——select元素]]></title>
    <url>%2F2018%2F12%2F02%2FMyBatis-2-%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%80-%E2%80%94%E2%80%94select%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[映射器MyBatis是针对映射器构造的SQL轻量级框架，通过配置生成对应的JavaBean返回给调用者。 映射器的主要元素映射器的配置 元素名称 描述 备注 select 查询语句 可以自定义参数，返回结果集 insert 插入语句 执行后返回一个整数，代表插入的条数 update 更新语句 执行后返回一个整数，代表更新的条数 delete 删除语句 执行后返回一个整数，代表删除的条数 parameterMap 定义参数映射关系 即将被删除的元素，不建议使用 sql 允许定义一部分的SQL，然后在多个地方引用 例如，一张表列名，可以一次定义，在多个SQL语句中使用 resultMap 用来描述从数据库结果集中加载的对象 提供映射规则 cache 给定命名空间的缓存配置 - cache-ref 其他命名空间缓存配置的引用 - select元素select元素负责从数据库中读出数据，并且组装数据。执行前，需要定义参数，例如int，float等简单参数类型，也可以是JavaBean、Map等复杂类型。执行后，MyBatis提供了自动映射可以把结果集绑定到JavaBean上。select配置如下： 元素 说明 备注 id 它和Mapper的命名空间组合起来是唯一的，提供给MyBatis调用(其实就是Dao中对应的方法名) 如果命名空间和id组合起来不唯一，MyBatis将抛出异常 parameterType 传入参数的类型，例如long，String等(可以给出类的全命名，也可以给出类的别名，但别名必须是MyBatis内部定义或自定义的) 可以选择JavaBean、Map等复杂的参数类型 parameterMap 即将废弃，不建议使用 - resultType 返回的类型。定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射；也可以定义为int、float、double等参数；不能和resultMap同时使用 - resultMap 可以执行强大的映射功能，通过该元素，可以自定义映射，不能与resultType同时使用 可以配置映射规则，typeHandler等 flushCache 调用SQL后，是否要求MyBatis清空之前查询的本地缓存和二级缓存 true/false，默认为false useCache 启动二级缓存的开关，是否要求MyBatis将此次结果缓存 true/false，t默认为true timeout 设置超时参数，等超时的时候将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数 fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数 statementType 告诉MyBatis使用哪个JDBC的Statement工作，取值为STATEMENT(Statement)、CallableStatement 默认值为PREPARED resultSetType 针对JDBCresultSet接口 默认值是数据库厂商提供的JDBC驱动所设置的 databaseId 取决于数据库厂商 - resultOrdered 仅适用于嵌套集select语句。如果为true，就是假设包含了嵌套结果集或者是分组了。当返回一个主结果行的时候，就不能对前面结果集引用。确保了在获取嵌套结果集的时候不会导致内存不够用 true/false，默认为false resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用 简易数据类型的例子例如，想要统计一个姓氏的数量，我们应该把‘姓’作为参数，而将结果(一个整数)作为结果返回123&lt;select id = "countFirstName" parameterType="String" resultType="int"&gt; select count(*) as total from t_userwhere name like #&#123;firstName&#125;&lt;/select&gt; 对应Dao中的方法为1public int countFirstName(String firstName); 每个部分的含义： id：对应的是Dao中的方法名 parameterType：是参数类型，也就是Dao中方法的参数类型 resultType：定义返回类型，也就是Dao中方法的返回类型 #{firstName}：也就是Dao中方法的参数名，#{}符号告诉MyBatis这是一个变量 在完整应用中的使用可以看下面这个例子mapper，Dao，JavaBean 自动映射MyBatis中可以设置参数autoMappingBehavior，当该值不为NONE时，MyBatis会自动根据SQL列名和JavaBean的属性自动映射(前提是他们一致)。大部分的数据库规范要求每个单词用下划线分割，而Java则是用驼峰命名。下面给出一个例子 JavaBean 1234567891011121314151617181920212223242526272829public class Role&#123; private Long id; private String roleName; private String note; public Long getId () &#123; return id; &#125; public void setId (Long id) &#123; this.id = id; &#125; public String getRoleName () &#123; retrun roleName; &#125; public void setRoleName (String roleName) &#123; this.roleName = roleName; &#125; public String getNote () &#123; return note; &#125; public void setNote (String note) &#123; this.note = note; &#125;&#125; 数据库表T_ROLE 字段 类型 说明 ID INT(20) 角色编号，主键，递增 ROLE_NAME VARCHAR(60) 角色名称 NOTE VARCHAR(1024) 备注 Mapper 1234&lt;select id = "getRole" parameterType = "long" resultType = "Role" &gt; select id, role_name as roleName, note from t_role where id = #&#123;id&#125;&lt;/select&gt; Dao 1public Role getRole(Long id); autoMappingBehavior属性包含三个值，可以再settings元素中配置： NONE：取消自动映射 PARTIAL(默认)：只会自动映射没有定义嵌套结果集映射的结果集 FULL：自动映射所有结果集 mapUnderscoreToCamelCase设置为true，可以实现从数据库到POJO的自动映射，前提是命名是规范的。 传递多个参数使用Map传递参数Mapper 12345&lt;select id="findRoleByMap" parameterType="map" resultMap="roleMap"&gt; select id, role_name, note from t_role where role_name like #&#123;roleName&#125; and note like #&#123;note&#125;&lt;/select&gt; Dao 1public List&lt;Role&gt; findRoleByMap (Map&lt;String, String&gt; params); 传递参数123456Map&lt;String, String&gt; paramsMap = new HashMap&lt;String, String&gt; ();paramsMap.put("roleName", "me");paramsMap.put("note", "te");roleMapper.findRoleByMap(paramsMap); 缺点是Map需要键值对应，业务关联性不强，造成可读性下降。 使用注解方式传递参数我们需要使用MyBatis的参数注解@param(org.apache.ibatis.annotations.Param)来实现想要的功能。操作方法是，把RoleDao接口修改为下面的形式。 12public List&lt;Role&gt; findRoleByAnnotation (@Param ("roleName") String rolename, @Param("note") String note); 注解式参数12345&lt;select id="findRoleByAnnotation" resultMap="roleMap"&gt; select id, role_name, note from t_role where role_name like #&#123;role_name&#125; and note like #&#123;note&#125;&lt;/select&gt; 缺点是如果参数过多会很复杂。 使用JavaBean传递参数首先定义一个参数的JavaBean1234567891011121314151617public class RoleParam &#123; private String roleName; private String note; public String getRoleName () &#123; return roleName; &#125; public void setRoleName (String roleName) &#123; this.roleName = roleName; &#125; public String getNote () &#123; return note; &#125; public void setNote (String note) &#123; this.note = note; &#125;&#125; 12345&lt;select id="findRoleByParams" parameterType = "RoleParam" resultMap="roleMap"&gt; select id, role_name, note from t_role where role_name like #&#123;role_name&#125; and note like #&#123;note&#125;&lt;/select&gt; 1public List&lt;Role&gt; findRoleByParams (RoleParam params); 使用resultMap映射结果集例如123456789&lt;resultMap id = "roleResultMap" type="Role"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="roleName" column="role_name"/&gt; &lt;result property="note" column="note"/&gt;&lt;/resultMap&gt;&lt;select parameterType="long" id="getRole" resultMap = "roleResultMap" &gt; select id, role_name, note from t_role where id = #&#123;id&#125;&lt;/select&gt; 解释一下配置： 定义了一个唯一标识(id)为roleResultMap的resultMap，用type属性定义它对应的是哪个JavaBean 通过id元素定义roleResultMap，这个对象代表着使用哪个属性作为其主键。 通过result元素定义普通列的映射关系。例如，把SQL结果返回的列role_name和type属性定义JavaBean的属性roleName等做对应。 推荐阅读基于MyBatis实现的JavaWeb项目源码-github 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 2.Add Two Numbers]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[题目翻译给定两个非空单链表代表两个非负整数。每个结点有一位数字，以倒序保存在链表中。将两数相加，并返回一个代表结果的链表。假设两个数字不含无效的0(即数字不以0开头)，0本身除外。 例子： 输入: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出: 7 -&gt; 0 -&gt; 8 解释: 342 + 465 = 807. 解题方法遍历两个链表把每一位上的数字相加，并用变量记录是否需要进位，该变量初始为0。因为两个数字位数可能不同，所以有四种情况 两个链表中都有这一位数字，且两数与进位变量相加小于10，则直接得到新结点，并且将进位变量置位0. 两个链表中都有这一位数字，但两数与进位变量相加大于等于10，新结点的值为得到的和减10，并且将进位变量置位1. 只有一个链表有这一位数字，且这个数字加进位量小于10，直接得到新结点，变位量置位0. 只有一个链表有这一位数字，且这个数字加进位量大于等于10，新结点的值为得到的和减10，并且将进位变量置位1. 需要考虑到，最后可能两个链表相加完成后，进位量为1，要把这一进位量加到数字前面。 代码1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *p = l1; ListNode *q = l2; ListNode *h = new ListNode(0); ListNode *t = h; int flag = 0; while(p || q || flag&gt;0)&#123; int sump = p?p-&gt;val:0; int sumq = q?q-&gt;val:0; t-&gt;next = new ListNode(sump + sumq + flag); t = t-&gt;next; flag = t-&gt;val&gt;=10?1:0; t-&gt;val = t-&gt;val&gt;=10?t-&gt;val-10:t-&gt;val; p = p?p-&gt;next:NULL; q = q?q-&gt;next:NULL; &#125; t-&gt;next = NULL; return h-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 3.索引(一)——索引的类型]]></title>
    <url>%2F2018%2F12%2F02%2FMySQL-3-%E7%B4%A2%E5%BC%95-%E4%B8%80-%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[索引索引的作用：在MySQL中，想要查找某个行时，首先在索引中找到对应值，然后根据匹配的索引找到对应的数据行。在MySQL中，索引是在存储引擎层而不是服务器层实现的。对于索引的创建和如何使用索引进行查询 推荐阅读：如何理解并正确使用MySQL索引 索引的类型B-Tree索引B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。推荐阅读：什么是B树 B-Tree索引可以加快访问数据的速度，因为存储引擎可以从索引的根节点开始进行搜索，从而取代全表扫描。B-Tree对索引列是顺序组织存储的，所以比较适合查找范围数据 可以对多个列创建索引，索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。例如，定义索引时顺序为 姓名，生日。那么首先按姓名进行排序，只有当两人姓名一样时，才按生日排序。 B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型查询有效： 全值匹配：全值匹配指的是和索引中的所有列进行匹配。 匹配最左前缀：只匹配索引的第一列 匹配列前缀：只匹配第一列的值的开头部分，例如只匹配姓以J为开头的人。 匹配范围值：例如匹配成绩为60-100之间的人，只使用索引第一列 精确匹配某一列并范围匹配另一列：例如匹配所有姓名为张三，成绩在60-100分的人。 只访问索引的查询：查询只访问索引，并不访问数据行。 因为索引树中的节点是有序的，所以除了按值查找外，还可以用于查询中的ORDER BY操作。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。 B-Tree索引的限制： 如果不是按照索引最左列开始查找，则无法使用索引。例如，索引列按顺序为：姓名，生日，该索引无法用于查找某个特定生日的人，因为生日不是最左数据。同样也无法查找姓名以某个字结尾的人。 不能跳过索引中的列。例如，索引按顺序为：姓，名，生日。则无法查找所有在姓张的，且在1月1日生的人，因为不能跳过名。在这个查询中，MySQL只能使用‘姓’这列的索引。 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询(注意：LIKE也属于范围查询条件)。所以对于范围值有限的查询，可以用多个等于条件来代替范围条件。 哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎会对索引的索引列计算一个哈希码，不同键值行的哈希码不同。哈希索引将所有哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。如果哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中 例如，现在数据库表中有姓，名两列数据，且‘姓’列添加了哈希索引。当要查询一个姓为‘张’的数据时。MySQL先计算‘张’的哈希值，并且用该值在哈希表中找到对应的记录指针。 哈希索引自身只需存储对应哈希值，所以非常快。但是也存在限制： 哈希索引只包含哈希值和行指针，而不存储字段值。所以不能使用索引中的值来避免读取行 哈希索引无法用于排序，因为不是按照索引值顺序存储的(按照哈希后的值存储) 哈希索引不支持部分索引列匹配查找。 哈希索引只支持等值比较(包括=、IN()、&lt;=&gt;)。也不支持任何范围查询。 如果有很多哈希冲突，查询/维护代价会变高。 InnoDB有一个特殊功能叫做“自适应哈希索引(adaptive hash index)”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree索引之上在创建一个哈希索引。 创建自定义哈希索引：如果存储引擎不支持哈希索引，则可以在B-Tree基础上创建一个伪哈希索引(本质上还是使用B-Tree查找)。 例如，需要存储大量URL，并且需要根据URL进行搜索查找。如果使用B-Tree直接查找，会很慢，存储内容也会很多。所以，可以给表新增一列，并且使用一个哈希函数，这个新增的列记录对应行URL哈希后的值，并在该列加上索引，这样在查找时，先对给定的URL进行哈希，然后再新增列上查找对应哈希后的值，找到后再返回对应的行就可以了。 全文索引它查找的是文本中的关键词，而不是直接比较索引中的值。在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE操作。 索引的优点索引除了可以让服务器快速地定位到指定位置，还有其他附加作用 对于B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。 优点： 索引减少了服务器需要扫描的数据量。 索引可以帮助服务器避免排序和临时表。 索引可将随机I/O变为顺序I/O 推荐阅读什么是B树 如何理解并正确使用MySQL索引 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>B-Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 2.数据类型及优化]]></title>
    <url>%2F2018%2F12%2F02%2FMySQL-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据类型选择原则 更小的通常更好(占用空间少)：但需要注意，不要低估值的范围 简单的更好：如整形比字符型好 尽量避免NULL：如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较更为复杂，并且会使用更多存储空间。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。尤其是有索引的列，应该避免可以为NULL。InnoDB对于稀疏数据(只有少数行为非NULL)，可以使用可以为NULL的列。 数据类型整数类型： 类型 位数 TINYINT 8 SMALLINT 16 MEDIUMINT 24 INT 32 BIGINT 64 UNSIGNED为可选属性。为整形类型指定宽度，如int(11)，并不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储来说int(1)和int(20)是一样的。 实数类型：不仅只是为了存储小数部分，还可以存储比BIGINT还大的数。MySQL既支持精确类型，也支持不精确类型。 FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。 DECIMAL类型用于存储精确的小数。在5.0版本及之后，支持精确计算。CPU不支持对DECIMAL直接计算，所以在5.0及更高版本中，MySQL服务器自身实现了DECIMAL的高精度计算，所以，浮点运算速度更快。 浮点和DECIMAL类型都可以指定精度。MySQL5.0及更高版本将数字打包保存到一个二进制字符串中。 MySQL5.0和更高版本DECIMAL最多允许65个数字。早期版本限制为254个数字且每个数字为一个字节。但其实并不能在计算中使用这么大的数字，因为早期版本DECIMAL只是一种存储格式，计算时会转换为浮点型。 应该只在对小数进行精确计算时才使用DECIMAL，在数据量比较大时，可以考虑BIGINT代替DECIMAL，将需要的单位根据小数位数乘以相应倍数即可。 字符串类型：VARCHAR和CHAR是两种最主要的字符串类型。 VARCHAR：VARCHAR类型用于存储可变长字符串。比定长类型更节省空间。但如果MySQL表使用ROW_FORMAT = FIXED创建的话，每一行都会使用定长存储，会很浪费空间。VARCHAR需要使用1或两个额外字节记录字符串长度：如果列的最大长度小于或等于255字节，则只需要使用1个字节表示，否则需要两个。 由于行是可变的，UPDATE时可能需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，不同的存储引擎处理方式不一样。例如，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页使行可以放进页内。 在5.0或更高版本，MySQL在存储和检索时，会保留末尾空格。早期版本会剔除。 下面情况使用VARCHAR比较合适： 字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题； 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储； CHAR：CHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。 下面情况使用CHAR比较合适： 很短的字符串； 数据经常变更； 所有值都接近同一个长度。 BLOB类型和TEXT类型：都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。它们分别属于两组不同的数据类型 字符类型 对应二进制类型 TINYTEXT TINYBLOB SMALLTEXT SMALLBLOB TEXT BLOB MEDIUMTEXT MEDIUMBLOB LONGTEXT LONGBLOB MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。这两种类型的排序也和其他类型不同：只对每个列的最前max_sort_length字节而不是整个字符串做排序。 枚举类型：枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL内部会将每个值在列中的位置保存为整数，并在表的.frm文件中保存“数字-字符串”的映射关系。所以实际存储的为整数，而不是字符串。 例如： mysql &gt; CREATE TABLE enum_test( -&gt; e ENUM(&apos;fish&apos;, &apos;apple&apos;, &apos;dog&apos;) NOT NULL); mysql &gt; INSERT INTO enum_test(e) VALUES(&apos;fish&apos;), (&apos;dog&apos;), (&apos;apple&apos;); mysql &gt; SELECT e + 0 FROM enum_test; 结果： | e + 0 | | 1 | | 3 | | 2 | 如果使用数字本身作为枚举常量，会造成混乱，应避免这么做。 同样，枚举字段按照存储的整数而不是预定义的字符串进行排序。 mysql &gt; SELECT e FROM enum_test ORDER BY e; 结果： | e | | fish | | apple | | dog | 可以使用FIELD()函数显式地指定排序顺序，但会导致MySQL无法利用索引消除排序。 mysql &gt; SELECT e FROM enum_test ORDER BY FIELD(e, &apos;apple&apos;,&apos;dog&apos;,&apos;fish&apos;); 结果： | e | | apple | | dog | | fish | 枚举的缺点是，字符串列表固定，添加或删除预定义字符串，必须使用ALTER TABLE会花费许多时间。 优点是可能缩小表的大小。 日期和时间类型： DATETIME：能保存大范围的值，从1001年到9999年，精度为秒，与时区无关。使用8个字节的存储空间。 TIMESTAMP：从1970年1月1日午夜以来的秒数，使用4个字节的存储空间，只能表示1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，及UNIX_TIMESTAMP()函数把日期转换我Unix时间戳。显示值依赖于时区。默认情况下，如果插入时没有指定第一个TIMESTAMP的列的值，MySQL则设置这个列的值为当前时间。在插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值(除非在UPDATE语句中明确指定了值)。可以配置任何TIMESTAMP列的插入和更新行为。TIMESTAMP列默认为NOT NULL。 位数据类型：所有位类型，不管底层存储格式还是处理方式如何，从技术上来说都是字符串类型。在MySQL5.0之前，BIT与TINYINT相同。但在5.0及之后版本中，并不相同。 BIT：可以使用BIT在一列中存储多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)包含两个位，最大长度为64。BIT的行为因存储引擎而异。MyISAM会打包存储所有BIT的列，17个单独的BIT列只需要17个位(假设全都不可为NULL)，这样MyISAM只使用3个字节就足够了。而InnoDB为每个BIT列使用一个足够存储的最小整数类型来存放。 MySQL把BIT当作字符串类型，而不是数字类型。当检索BIT(1)的值时，结果是一个包含二进制0或1值的字符串，而不是ASCII码的“0”或“1”。但是，在数字上下文的场景中检索时，结果将是位字符串转换成的数字。例如，如果存储一个值b‘00111001’(二进制等于57)到BIT(8)的列并且检索，得到的内容是字符码为57的字符串。也就是得到ASCII码为57的字符“9”。但是在数字上下文场景中，得到的是数字57： 12345678mysql &gt; CREATE TABLE bittest(a bit(8));mysql &gt; INSERT INTO bittest VALUE(b &apos;00111001&apos;);mysql &gt; SELECT a, a + 0 FROM bittest;结果为：| a | a + 0|| 9 | 57 | 如果想在一个bit的存储空间中存储一个布尔值，一个可选的方法是创建一个可以为空的CHAR(0)列。该列可以保存空值(NULL)或者长度为零的字符串(空字符串)。 SET：如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，它在MySQL内部以一系列打包的位的集合来表示。缺点是改变列的定义的代价较高，需要ALTER TABLE，并且无法在SET列上通过索引查找。 可选的替代操作是使用一个整数包装一系列的位。例如，可以把8个位包装到一个TINYINT中，并且按位操作来使用(类似于Linux中文件的权限控制) 例如：12345678910mysql &gt; SET @CAN_READ := 1 &lt;&lt; 0, -&gt; @CAN_WRITE := 1 &lt;&lt; 1, -&gt; @CAN_DELETE := 1 &lt;&lt; 2;mysql &gt; CREATE TABLE acl (perms TINYINT UNSIGNED NOT NULL DEFAULT 0);mysql &gt; INSERT INTO acl(perms) VALUE(@CAN_READ + @CAN_DELETE);mysql &gt; SELECT perms FROM acl WHERE perms &amp; @CAN_READ;结果：| perms || 5 | MySQL schema 设计陷阱 太多关联：耗费很长时间查询和缓存。 太多的列：MySQL存储引擎API工作时，会在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列，这个过程代价很高(MyISAM定长行结构与服务器层相匹配，不需要转换)。代价依赖于列的数量 过度使用枚举：每次在枚举列中增加一个新选项，都要做一次ALTER TABLE操作 变相枚举：枚举ENUM列允许在列中存储一组定义值中的单个值，集合SET允许在列中存储一组定义值中的一个或多个值。所以当列中的值不可能同时出现多种情况时(e.g., 同一门成绩的挂科和通过不可能同时存在)，应该使用枚举代替集合。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL数据类型</tag>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 1.MySQL架构与引擎]]></title>
    <url>%2F2018%2F12%2F01%2FMySQL-1-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[基础架构MySQL服务器逻辑架构: 最上层服务负责连接处理、授权认证。安全等。 第二层包含了MySQL的大多核心功能，包括查询解析、分析、优化、缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。 第三层为存储引擎，存储引擎负责MySQL中数据的存储和提取。存储引擎不负责解析SQL(InnoDB是例外，它会解析外键定义)，不同存储引擎也不会相互通信。 并发控制读写锁：读锁也叫共享锁，写锁也叫排它锁。读锁是相互不阻塞的，多个用户在同一时刻可以同时读取同一个资源，而且互不干扰。写锁是排他的，一个写锁会阻塞其他的写锁和读锁，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。 表锁：开销最小的策略，会锁定整张表。一个用户在对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列之前。 行锁：可以最大程度支持并发处理，但同时锁开销最大。行级锁只在存储引擎层实现。 事务 事务是一组原子性的SQL查询。事务内的语句，要么全部执行成功，要么全部失败。 事务具有ACID的特性: Atomicity(原子性)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能执行其中的一部分操作，这就是事务的原子性。 Consistency(一致性)：数据库总是从一个一致性的状态转换到另外一个一致性的状态。 Isolation(隔离性)：通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的。 Durability(持久性)：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。 隔离级别: 未提交读(Read Uncommitted)：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，也被称为脏读(Dirty Read)。一般很少使用 提交读(Read Committed)：一个事务开始时，只能看见已经提交的事务所做的修改。即一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。也叫做不可重复读(nonrepeatable read)，因为两次同样的查询，可能得到不一样的结果。 可重复读(Repeatable Read)：解决了脏读问题，同时保证了在同一个事务中多次读取同样记录的结果是一致的。但无法解决幻读(Phantom Read)问题，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和XtraDB通过多版本并发控制(MVCC)解决了幻读问题。 可串行化(Serializable)：通过强制事务串行执行，避免了幻读。会在读取的每一行数据上都加锁。 隔离级别 脏读 不可重复读 幻读 加锁读 未提交读 √ √ √ × 提交读 × √ √ × 可重复读 × × √ × 可串行读 × × × √ 可以通过SET TRANSACTION ISOLATION LEVEL设置隔离级别。 mysql &gt; SET SESSION TRANSACTION ISOLATION LEVER ***; *** 为相应级别 死锁：锁的行为和顺序是和存储引擎相关的，以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁发生后，只有部分或者完全回滚其中一个事务才能打破死锁。对于事务型系统是无法避免的。 InnoDB解决死锁的方法是，将持有最少行级排他锁的事务进行回滚。 事务日志：事务日志可以帮助提高事务效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快的多。事务日志持久以后，内存中被修改的数据可以慢慢刷回到磁盘。称之为预写式日志(Write-Ahead Logging)，修改数据需要写两次磁盘。 自动提交：MysQL默认采用自动提交事务，如果不显式地开始一个事务，则每个查询都被当做一个事务执行提交操作，可以通过设置AUTOCOMMIT变量来查看。 mysql &gt; SHOW VARIABLES LIKE &apos;AUTOCOMMIT&apos;; mysql &gt; SET AUTOCOMMIT = 1; 1或者on表示启用，0或者off表示禁用。当AUTOCOMMIT= 0时，所有查询在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事务。修改AUTOCOMMIT对非事务型的表，比如MyISAM是无效的，因为对这类表来说，没有COMMIT和ROLLBACK的概念，可以看成一直处于AUTOCOMMIT开启状态。还有些命令，在执行前会强制COMMIT提交当前活动事务，如会导致大量数据改变的操作(e.g., ALTER TABLE) 在同一事务中，使用多种存储引擎是不可靠的(如事务型引擎和非事务引擎，回滚会造成数据不一致) 隐式和显式锁定：InnoDB采用两段锁定协议(two-phase locking protocol)。在事务执行过程中，随时可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。这些都属于隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁 InnoDB也支持显示锁定，但不属于SQL规范，如： SELECT ... LOCK IN SHARE MODE SELECT ... FOR UPDATE 多版本并发控制(MVCC):MVCC是行级锁的一个变种，但是在很多情况下避免了加锁操作，大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC通过保存数据在某个时间点的快照来实现的。不管执行多长时间，每个事务看到的数据都是一致的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。 InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是实际的是兼职，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。 SELECT：InnoDB会根据以下两个条件检查每行记录： InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始前未被删除。只有符合上述两个条件的记录，才能返回作为查询结果。 INSERT：InnoDB为新插入的每一行保存当前系统版本号作为版本号。 DELETE：InnoDB为删除的每一行保存当前系统版本号作为删除标识。 UPDATE：InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。 MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作。其他两个级别不兼容，因为READ UNCOMMITTED总是读取最新数据行，而SERIALIZABLE则会对所有读取的行都加锁。 存储引擎mysql &gt; SHOW TABLE STATUS LIKE &apos;***&apos; 用来查看表的相关信息，***为表名 InnoDB：被设计用来处理大量短期事务(short-lived)事务，短期事务大部分情况是正常提交的，很少被回滚。InnoDB的数据存储在表空间(tablespace)中，表空间是由InnoDB管理的一个黑盒子，由一系列数据文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。也可以使用裸设备作为表空间的存储介质。InnoDB采用MVCC支持高并发，默认隔离级别为可重复读，并且通过间隙锁(next-key locking)策略防止幻读。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。 InnoDB表基于聚簇索引建立，所以对主键查询有很高的性能，不过二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应尽可能的小。 MyISAM：提供了大量特性，包含全文索引、压缩、空间函数。但不支持事务和行级锁，而且没有安全的崩溃恢复。对于只读的数据，或者表比较小、可以容忍修复操作，则可以使用MyISAM。 MyISAM会将表存储在：数据文件和索引文件中。表可以包含动弹或者静态(长度固定)行。MySQL会根据表的定义来决定采用何种行格式。MyISAM表可以存储的行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸. 特性： 加锁与并发：对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也可以往表中插入新的记录。 修复：MySQL可以手工或者自定执行检查和修复操作，这里修复与事务恢复和崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，可以通过CHECK TABLE mytable检查表的错误，如果有错误可以通过执行REPAIR TABLE mytable进行修复。 索引：即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。同时也支持全文索引。 延迟更新索引键：创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。可以提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置。 压缩表：压缩表不能进行修改，支持索引，但索引也是只读的。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>存储引擎</tag>
        <tag>ACID</tag>
        <tag>隔离级别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 3.Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个字符串，找出最长不重复子串。 例子： 输入: &quot;abcabcbb&quot; 输出: 3 解释：&quot;abc&quot; 输入: &quot;bbbbb&quot; 输出: 1 解释：&quot;b&quot; 输入: &quot;pwwkew&quot;&quot; 输出: 3 解释：&quot;wke&quot; 注意子串必须是连续的。 解题方法使用hash保存出现过的字符和位置。使用一个cur变量记录当前子串长度，start变量记录当前子串起始位置。遍历字符串，有三种可能： 如果当前字符没出现过，就将该字符与下标存到hash中，当前子串长度cur加1。 如果当前字符出现过，但是上一次出现的位置不在当前记录的子串中，就把当前长度cur加1，并把该字符在hash中的位置更新。 如果当前字符出现过，并且上一次出现的位置在当前子串中，说明该子串含有重复字符了，就把start变为上一次出现位置的后一个(这样可以保证子串中没有重复字符)。然后将当前子串长度更新，并把当前字符的位置更新。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char,int&gt; H; map&lt;char,int&gt;::iterator it; int max = 0; int start = 0; int cur = 0; for(int i = 0;i&lt;s.size();i++)&#123; it = H.find(s[i]); if(it==H.end())&#123; H.insert(pair&lt;char,int&gt;(s[i],i)); cur++; &#125;else&#123; if(it-&gt;second&lt;start)&#123; cur++; &#125;else&#123; start = it-&gt;second + 1; cur = i - start + 1; &#125; it-&gt;second = i; &#125; max = max&gt;cur?max:cur; &#125; max = max&gt;cur?max:cur; return max; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>哈希</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1.Two Sum]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个整数数组和一个目标值，返回两个相加等于目标值的数的下标。你可以假设每组输入只有一个正确答案，并且你不能使用同一个元素两次。 例子： 输入： nums = [2, 7, 11, 15], target = 9, 输出： [0,1] 解释： 因为num[0] + nums[1] = 2 + 7 = 9 解题方法解法1：使用hash，如果target与当前数的差已经在hash中就返回两个数的下标，否则把当前数加入到hash中。 解法2：将原数组的值和下标放在一个pair中，并组成一个新的数组，将该数组升序排列。从两端向里遍历，若两端的数的和大于target，则将右端向左移动。若两端数的和小于target，则左端向右移动，直到找到和为target的两个数字。 代码123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2); if(nums.size()&lt;=1) return res; map&lt;int,int&gt; H; map&lt;int,int&gt;::iterator it; for(int i = 0;i&lt;nums.size();i++)&#123; it = H.find(target - nums[i]); if(it == H.end())&#123; H.insert(pair&lt;int,int&gt;(nums[i],i)); &#125;else&#123; res[0] = it-&gt;second; res[1] = i; break; &#125; &#125; return res; &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;private: static bool cmp(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) &#123; return A.first &lt; B.first; &#125;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, 0); vector&lt;pair&lt;int, int&gt;&gt; temp; for (int i = 0; i&lt;nums.size(); i++) temp.push_back(pair&lt;int, int&gt;(nums[i], i)); sort(temp.begin(), temp.end(), cmp); int i = 0, j = temp.size() - 1; while (i&lt;j) &#123; if (temp[i].first + temp[j].first&gt;target) j--; else if (temp[i].first + temp[j].first&lt;target) i++; else &#123; res[0] = temp[i].second &lt; temp[j].second ? temp[i].second : temp[j].second; res[1] = temp[i].second &gt;= temp[j].second ? temp[i].second : temp[j].second; return res; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>哈希</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 1.MyBatis基本构成]]></title>
    <url>%2F2018%2F12%2F01%2FMyBatis-1-MyBatis%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[MyBatis核心组件： SqlSessionFactoryBuilder(构造器)：它会根据配置信息或者代码来生成SqlSessionFactory(工厂接口)。 SqlSessionFactory：依靠工厂来生成SqlSession(会话)。 SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口。 SQLMapper：由一个Java接口和XML文件(或注解)构成的，需要给出对应的SQL和映射规则，负责发送SQL去执行，并返回结果。 构建SqlSessionFactory：每个MyBatis应用都是以SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactory是一个工厂接口而不是现实类，它的任务是创建SqlSession。SqlSession类似于JDBC的Connection对象。MyBatis提供了两种模式去创建SqlSessionFactory： XML配置(推荐) 代码 Mybatis中有一个Configuration类存在于整个MyBatis应用的生命期中，以便重复读取和运用。可以解析一次配置的XML文件保存到Configuration类对象中，方便从这个对象中读取配置信息，性能高。单例占用空间小，基本不占用存储空间，而且可以反复使用。Configuration类对象保存着配置在MyBatis的信息。在MyBatis中提供了两个SqlSessionFactory的实现类，DefaultSqlSessionFactory和SqlSessionManager。不过SqlSessionManager目前没有使用。 创建SqlSession：SqlSession是一个接口类，真正工作的是Executor接口。构建了SqlSessionFactory，然后生成SqlSession。SqlSession接口类似于一个JDBC中的Connection接口对象，需要保证每次用完正常关闭，所以正确做法是将关闭SqlSession接口的代码写在finally语句中保证每次都会关闭SqlSession。 123456789101112131415// 定义SqlSession Sqlsession sqlSession = null; try &#123; // 打开SqlSession会话 sqlSession = sqlSessionFactory.openSession(); //... sqlSession.commit(); &#125; catch(Exception ex) &#123; sqlSession.rollback(); &#125;finally &#123; // 确保资源被正确关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; 主要用途有两种： 获取映射器，让映射器通过命名空间和方法名称找到对应的SQL，发送给数据库执行后返回结果。 直接通过命名信息去执行SQL返回结果。在SqlSession层可以通过update、insert、select、delete等方法，带上SQL的id来操作在XML中配置好的SQL。 映射器：由Java接口和XML文件(或注解)共同组成的，它的作用如下。 定义参数类型。 描述缓存。 描述SQL语句。 定义查询结果和POJO的映射关系。同样有XML和代码两种方式生成。 组件的生命周期 SqlSessionFactoryBuilder：一旦构建了SqlSessionFactory，它的作用就已经完结，应该被回收。所以它的生命周期只存在于方法的局部，作用是生成SqlSessionFactory对象。 SqlSessionFactory：作用是创建SqlSession(相当于JDBC的Connection对象)。每次应用程序需要访问数据库，就要通过SqlSessionFactory创建SqlSession，所以SqlSessionFactory存在于应用的整个生命周期中。应该采用单例模式(一般方法为将构造方法私有化，并给出一个静态方法，让其返回唯一单例，在多线程初始化单例时，一般需要加线程锁避免类对象被多次初始化)，以避免创建更多SqlSessionFactory而消耗资源。所以一个数据库只应该对应一个SqlSessionFactory。 SqlSession：一个会话，相当于JDBC一个Connection对象，生命周期是在请求数据库处理事务的过程中。该对象线程不安全，应该属于其隔离级别，数据库锁等特性。每次创建的SqlSession都应及时关闭，避免占用数据库连接池。所以，它存活于一个应用的请求和操作中，可以执行多条SQL。 Mapper：是一个接口，没有任何实现类，作用是发送SQL，并返回需要的结果，或者执行SQL以修改数据库数据。因此应该在一个SqlSession事务方法之内，属于方法级别。类似于JDBC中的一条SQL语句的执行，最大的范围和SqlSession相同。 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
