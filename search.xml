<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[MySQL] 2.数据类型及优化]]></title>
    <url>%2F2018%2F12%2F02%2FMySQL-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据类型选择原则 更小的通常更好(占用空间少)：但需要注意，不要低估值的范围 简单的更好：如整形比字符型好 尽量避免NULL：如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较更为复杂，并且会使用更多存储空间。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。尤其是有索引的列，应该避免可以为NULL。InnoDB对于稀疏数据(只有少数行为非NULL)，可以使用可以为NULL的列。 数据类型整数类型： 类型 位数 TINYINT 8 SMALLINT 16 MEDIUMINT 24 INT 32 BIGINT 64 UNSIGNED为可选属性。为整形类型指定宽度，如int(11)，并不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储来说int(1)和int(20)是一样的。 实数类型：不仅只是为了存储小数部分，还可以存储比BIGINT还大的数。MySQL既支持精确类型，也支持不精确类型。 FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。 DECIMAL类型用于存储精确的小数。在5.0版本及之后，支持精确计算。CPU不支持对DECIMAL直接计算，所以在5.0及更高版本中，MySQL服务器自身实现了DECIMAL的高精度计算，所以，浮点运算速度更快。 浮点和DECIMAL类型都可以指定精度。MySQL5.0及更高版本将数字打包保存到一个二进制字符串中。 MySQL5.0和更高版本DECIMAL最多允许65个数字。早期版本限制为254个数字且每个数字为一个字节。但其实并不能在计算中使用这么大的数字，因为早期版本DECIMAL只是一种存储格式，计算时会转换为浮点型。 应该只在对小数进行精确计算时才使用DECIMAL，在数据量比较大时，可以考虑BIGINT代替DECIMAL，将需要的单位根据小数位数乘以相应倍数即可。 字符串类型：VARCHAR和CHAR是两种最主要的字符串类型。 VARCHAR：VARCHAR类型用于存储可变长字符串。比定长类型更节省空间。但如果MySQL表使用ROW_FORMAT = FIXED创建的话，每一行都会使用定长存储，会很浪费空间。VARCHAR需要使用1或两个额外字节记录字符串长度：如果列的最大长度小于或等于255字节，则只需要使用1个字节表示，否则需要两个。 由于行是可变的，UPDATE时可能需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，不同的存储引擎处理方式不一样。例如，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页使行可以放进页内。 在5.0或更高版本，MySQL在存储和检索时，会保留末尾空格。早期版本会剔除。 下面情况使用VARCHAR比较合适： 字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题； 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储； CHAR：CHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。 下面情况使用CHAR比较合适： 很短的字符串； 数据经常变更； 所有值都接近同一个长度。 BLOB类型和TEXT类型：都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。它们分别属于两组不同的数据类型 字符类型 对应二进制类型 TINYTEXT TINYBLOB SMALLTEXT SMALLBLOB TEXT BLOB MEDIUMTEXT MEDIUMBLOB LONGTEXT LONGBLOB MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。这两种类型的排序也和其他类型不同：只对每个列的最前max_sort_length字节而不是整个字符串做排序。 枚举类型：枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL内部会将每个值在列中的位置保存为整数，并在表的.frm文件中保存“数字-字符串”的映射关系。所以实际存储的为整数，而不是字符串。 例如： mysql &gt; CREATE TABLE enum_test( -&gt; e ENUM(&apos;fish&apos;, &apos;apple&apos;, &apos;dog&apos;) NOT NULL); mysql &gt; INSERT INTO enum_test(e) VALUES(&apos;fish&apos;), (&apos;dog&apos;), (&apos;apple&apos;); mysql &gt; SELECT e + 0 FROM enum_test; 结果： | e + 0 | | 1 | | 3 | | 2 | 如果使用数字本身作为枚举常量，会造成混乱，应避免这么做。 同样，枚举字段按照存储的整数而不是预定义的字符串进行排序。 mysql &gt; SELECT e FROM enum_test ORDER BY e; 结果： | e | | fish | | apple | | dog | 可以使用FIELD()函数显式地指定排序顺序，但会导致MySQL无法利用索引消除排序。 mysql &gt; SELECT e FROM enum_test ORDER BY FIELD(e, &apos;apple&apos;,&apos;dog&apos;,&apos;fish&apos;); 结果： | e | | apple | | dog | | fish | 枚举的缺点是，字符串列表固定，添加或删除预定义字符串，必须使用ALTER TABLE会花费许多时间。 优点是可能缩小表的大小。 日期和时间类型： DATETIME：能保存大范围的值，从1001年到9999年，精度为秒，与时区无关。使用8个字节的存储空间。 TIMESTAMP：从1970年1月1日午夜以来的秒数，使用4个字节的存储空间，只能表示1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，及UNIX_TIMESTAMP()函数把日期转换我Unix时间戳。显示值依赖于时区。默认情况下，如果插入时没有指定第一个TIMESTAMP的列的值，MySQL则设置这个列的值为当前时间。在插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值(除非在UPDATE语句中明确指定了值)。可以配置任何TIMESTAMP列的插入和更新行为。TIMESTAMP列默认为NOT NULL。 位数据类型：所有位类型，不管底层存储格式还是处理方式如何，从技术上来说都是字符串类型。在MySQL5.0之前，BIT与TINYINT相同。但在5.0及之后版本中，并不相同。 BIT：可以使用BIT在一列中存储多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)包含两个位，最大长度为64。BIT的行为因存储引擎而异。MyISAM会打包存储所有BIT的列，17个单独的BIT列只需要17个位(假设全都不可为NULL)，这样MyISAM只使用3个字节就足够了。而InnoDB为每个BIT列使用一个足够存储的最小整数类型来存放。 MySQL把BIT当作字符串类型，而不是数字类型。当检索BIT(1)的值时，结果是一个包含二进制0或1值的字符串，而不是ASCII码的“0”或“1”。但是，在数字上下文的场景中检索时，结果将是位字符串转换成的数字。例如，如果存储一个值b‘00111001’(二进制等于57)到BIT(8)的列并且检索，得到的内容是字符码为57的字符串。也就是得到ASCII码为57的字符“9”。但是在数字上下文场景中，得到的是数字57： 12345678mysql &gt; CREATE TABLE bittest(a bit(8));mysql &gt; INSERT INTO bittest VALUE(b &apos;00111001&apos;);mysql &gt; SELECT a, a + 0 FROM bittest;结果为：| a | a + 0|| 9 | 57 | 如果想在一个bit的存储空间中存储一个布尔值，一个可选的方法是创建一个可以为空的CHAR(0)列。该列可以保存空值(NULL)或者长度为零的字符串(空字符串)。 SET：如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，它在MySQL内部以一系列打包的位的集合来表示。缺点是改变列的定义的代价较高，需要ALTER TABLE，并且无法在SET列上通过索引查找。 可选的替代操作是使用一个整数包装一系列的位。例如，可以把8个位包装到一个TINYINT中，并且按位操作来使用(类似于Linux中文件的权限控制) 例如：12345678910mysql &gt; SET @CAN_READ := 1 &lt;&lt; 0, -&gt; @CAN_WRITE := 1 &lt;&lt; 1, -&gt; @CAN_DELETE := 1 &lt;&lt; 2;mysql &gt; CREATE TABLE acl (perms TINYINT UNSIGNED NOT NULL DEFAULT 0);mysql &gt; INSERT INTO acl(perms) VALUE(@CAN_READ + @CAN_DELETE);mysql &gt; SELECT perms FROM acl WHERE perms &amp; @CAN_READ;结果：| perms || 5 | MySQL schema 设计陷阱 太多关联：耗费很长时间查询和缓存。 太多的列：MySQL存储引擎API工作时，会在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列，这个过程代价很高(MyISAM定长行结构与服务器层相匹配，不需要转换)。代价依赖于列的数量 过度使用枚举：每次在枚举列中增加一个新选项，都要做一次ALTER TABLE操作 变相枚举：枚举ENUM列允许在列中存储一组定义值中的单个值，集合SET允许在列中存储一组定义值中的一个或多个值。所以当列中的值不可能同时出现多种情况时(e.g., 同一门成绩的挂科和通过不可能同时存在)，应该使用枚举代替集合。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL数据类型</tag>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 1.MySQL架构与引擎]]></title>
    <url>%2F2018%2F12%2F01%2FMySQL-1-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[基础架构MySQL服务器逻辑架构: 最上层服务负责连接处理、授权认证。安全等。 第二层包含了MySQL的大多核心功能，包括查询解析、分析、优化、缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。 第三层为存储引擎，存储引擎负责MySQL中数据的存储和提取。存储引擎不负责解析SQL(InnoDB是例外，它会解析外键定义)，不同存储引擎也不会相互通信。 并发控制读写锁：读锁也叫共享锁，写锁也叫排它锁。读锁是相互不阻塞的，多个用户在同一时刻可以同时读取同一个资源，而且互不干扰。写锁是排他的，一个写锁会阻塞其他的写锁和读锁，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。 表锁：开销最小的策略，会锁定整张表。一个用户在对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列之前。 行锁：可以最大程度支持并发处理，但同时锁开销最大。行级锁只在存储引擎层实现。 事务 事务是一组原子性的SQL查询。事务内的语句，要么全部执行成功，要么全部失败。 事务具有ACID的特性: Atomicity(原子性)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能执行其中的一部分操作，这就是事务的原子性。 Consistency(一致性)：数据库总是从一个一致性的状态转换到另外一个一致性的状态。 Isolation(隔离性)：通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的。 Durability(持久性)：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。 隔离级别: 未提交读(Read Uncommitted)：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，也被称为脏读(Dirty Read)。一般很少使用 提交读(Read Committed)：一个事务开始时，只能看见已经提交的事务所做的修改。即一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。也叫做不可重复读(nonrepeatable read)，因为两次同样的查询，可能得到不一样的结果。 可重复读(Repeatable Read)：解决了脏读问题，同时保证了在同一个事务中多次读取同样记录的结果是一致的。但无法解决幻读(Phantom Read)问题，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和XtraDB通过多版本并发控制(MVCC)解决了幻读问题。 可串行化(Serializable)：通过强制事务串行执行，避免了幻读。会在读取的每一行数据上都加锁。 隔离级别 脏读 不可重复读 幻读 加锁读 未提交读 √ √ √ × 提交读 × √ √ × 可重复读 × × √ × 可串行读 × × × √ 可以通过SET TRANSACTION ISOLATION LEVEL设置隔离级别。 mysql &gt; SET SESSION TRANSACTION ISOLATION LEVER ***; *** 为相应级别 死锁：锁的行为和顺序是和存储引擎相关的，以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁发生后，只有部分或者完全回滚其中一个事务才能打破死锁。对于事务型系统是无法避免的。 InnoDB解决死锁的方法是，将持有最少行级排他锁的事务进行回滚。 事务日志：事务日志可以帮助提高事务效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快的多。事务日志持久以后，内存中被修改的数据可以慢慢刷回到磁盘。称之为预写式日志(Write-Ahead Logging)，修改数据需要写两次磁盘。 自动提交：MysQL默认采用自动提交事务，如果不显式地开始一个事务，则每个查询都被当做一个事务执行提交操作，可以通过设置AUTOCOMMIT变量来查看。 mysql &gt; SHOW VARIABLES LIKE &apos;AUTOCOMMIT&apos;; mysql &gt; SET AUTOCOMMIT = 1; 1或者on表示启用，0或者off表示禁用。当AUTOCOMMIT= 0时，所有查询在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事务。修改AUTOCOMMIT对非事务型的表，比如MyISAM是无效的，因为对这类表来说，没有COMMIT和ROLLBACK的概念，可以看成一直处于AUTOCOMMIT开启状态。还有些命令，在执行前会强制COMMIT提交当前活动事务，如会导致大量数据改变的操作(e.g., ALTER TABLE) 在同一事务中，使用多种存储引擎是不可靠的(如事务型引擎和非事务引擎，回滚会造成数据不一致) 隐式和显式锁定：InnoDB采用两段锁定协议(two-phase locking protocol)。在事务执行过程中，随时可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。这些都属于隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁 InnoDB也支持显示锁定，但不属于SQL规范，如： SELECT ... LOCK IN SHARE MODE SELECT ... FOR UPDATE 多版本并发控制(MVCC):MVCC是行级锁的一个变种，但是在很多情况下避免了加锁操作，大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC通过保存数据在某个时间点的快照来实现的。不管执行多长时间，每个事务看到的数据都是一致的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。 InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是实际的是兼职，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。 SELECT：InnoDB会根据以下两个条件检查每行记录： InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始前未被删除。只有符合上述两个条件的记录，才能返回作为查询结果。 INSERT：InnoDB为新插入的每一行保存当前系统版本号作为版本号。 DELETE：InnoDB为删除的每一行保存当前系统版本号作为删除标识。 UPDATE：InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。 MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作。其他两个级别不兼容，因为READ UNCOMMITTED总是读取最新数据行，而SERIALIZABLE则会对所有读取的行都加锁。 存储引擎mysql &gt; SHOW TABLE STATUS LIKE &apos;***&apos; 用来查看表的相关信息，***为表名 InnoDB：被设计用来处理大量短期事务(short-lived)事务，短期事务大部分情况是正常提交的，很少被回滚。InnoDB的数据存储在表空间(tablespace)中，表空间是由InnoDB管理的一个黑盒子，由一系列数据文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。也可以使用裸设备作为表空间的存储介质。InnoDB采用MVCC支持高并发，默认隔离级别为可重复读，并且通过间隙锁(next-key locking)策略防止幻读。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。 InnoDB表基于聚簇索引建立，所以对主键查询有很高的性能，不过二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应尽可能的小。 MyISAM：提供了大量特性，包含全文索引、压缩、空间函数。但不支持事务和行级锁，而且没有安全的崩溃恢复。对于只读的数据，或者表比较小、可以容忍修复操作，则可以使用MyISAM。 MyISAM会将表存储在：数据文件和索引文件中。表可以包含动弹或者静态(长度固定)行。MySQL会根据表的定义来决定采用何种行格式。MyISAM表可以存储的行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸. 特性： 加锁与并发：对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也可以往表中插入新的记录。 修复：MySQL可以手工或者自定执行检查和修复操作，这里修复与事务恢复和崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，可以通过CHECK TABLE mytable检查表的错误，如果有错误可以通过执行REPAIR TABLE mytable进行修复。 索引：即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。同时也支持全文索引。 延迟更新索引键：创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。可以提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置。 压缩表：压缩表不能进行修改，支持索引，但索引也是只读的。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>存储引擎</tag>
        <tag>ACID</tag>
        <tag>隔离级别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 3.Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个字符串，找出最长不重复子串。 例子： 输入: &quot;abcabcbb&quot; 输出: 3 解释：&quot;abc&quot; 输入: &quot;bbbbb&quot; 输出: 1 解释：&quot;b&quot; 输入: &quot;pwwkew&quot;&quot; 输出: 3 解释：&quot;wke&quot; 注意子串必须是连续的。 解题方法使用hash保存出现过的字符和位置。使用一个cur变量记录当前子串长度，start变量记录当前子串起始位置。遍历字符串，有三种可能： 如果当前字符没出现过，就将该字符与下标存到hash中，当前子串长度cur加1。 如果当前字符出现过，但是上一次出现的位置不在当前记录的子串中，就把当前长度cur加1，并把该字符在hash中的位置更新。 如果当前字符出现过，并且上一次出现的位置在当前子串中，说明该子串含有重复字符了，就把start变为上一次出现位置的后一个(这样可以保证子串中没有重复字符)。然后将当前子串长度更新，并把当前字符的位置更新。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char,int&gt; H; map&lt;char,int&gt;::iterator it; int max = 0; int start = 0; int cur = 0; for(int i = 0;i&lt;s.size();i++)&#123; it = H.find(s[i]); if(it==H.end())&#123; H.insert(pair&lt;char,int&gt;(s[i],i)); cur++; &#125;else&#123; if(it-&gt;second&lt;start)&#123; cur++; &#125;else&#123; start = it-&gt;second + 1; cur = i - start + 1; &#125; it-&gt;second = i; &#125; max = max&gt;cur?max:cur; &#125; max = max&gt;cur?max:cur; return max; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1.Two Sum]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个整数数组和一个目标值，返回两个相加等于目标值的数的下标。你可以假设每组输入只有一个正确答案，并且你不能使用同一个元素两次。 例子： 输入： nums = [2, 7, 11, 15], target = 9, 返回： [0,1](因为num[0] + nums[1] = 2 + 7 = 9) 解题方法解法1：使用hash，如果target与当前数的差已经在hash中就返回两个数的下标，否则把当前数加入到hash中。 解法2：将原数组的值和下标放在一个pair中，并组成一个新的数组，将该数组升序排列。从两端向里遍历，若两端的数的和大于target，则将右端向左移动。若两端数的和小于target，则左端向右移动，直到找到和为target的两个数字。 代码123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2); if(nums.size()&lt;=1) return res; map&lt;int,int&gt; H; map&lt;int,int&gt;::iterator it; for(int i = 0;i&lt;nums.size();i++)&#123; it = H.find(target - nums[i]); if(it == H.end())&#123; H.insert(pair&lt;int,int&gt;(nums[i],i)); &#125;else&#123; res[0] = it-&gt;second; res[1] = i; break; &#125; &#125; return res; &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;private: static bool cmp(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) &#123; return A.first &lt; B.first; &#125;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, 0); vector&lt;pair&lt;int, int&gt;&gt; temp; for (int i = 0; i&lt;nums.size(); i++) temp.push_back(pair&lt;int, int&gt;(nums[i], i)); sort(temp.begin(), temp.end(), cmp); int i = 0, j = temp.size() - 1; while (i&lt;j) &#123; if (temp[i].first + temp[j].first&gt;target) j--; else if (temp[i].first + temp[j].first&lt;target) i++; else &#123; res[0] = temp[i].second &lt; temp[j].second ? temp[i].second : temp[j].second; res[1] = temp[i].second &gt;= temp[j].second ? temp[i].second : temp[j].second; return res; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 1.MyBatis基本构成]]></title>
    <url>%2F2018%2F12%2F01%2FMyBatis-1-MyBatis%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[MyBatis核心组件： SqlSessionFactoryBuilder(构造器)：它会根据配置信息或者代码来生成SqlSessionFactory(工厂接口)。 SqlSessionFactory：依靠工厂来生成SqlSession(会话)。 SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口。 SQLMapper：由一个Java接口和XML文件(或注解)构成的，需要给出对应的SQL和映射规则，负责发送SQL去执行，并返回结果。 构建SqlSessionFactory：每个MyBatis应用都是以SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactory是一个工厂接口而不是现实类，它的任务是创建SqlSession。SqlSession类似于JDBC的Connection对象。MyBatis提供了两种模式去创建SqlSessionFactory： XML配置(推荐) 代码 Mybatis中有一个Configuration类存在于整个MyBatis应用的生命期中，以便重复读取和运用。可以解析一次配置的XML文件保存到Configuration类对象中，方便从这个对象中读取配置信息，性能高。单例占用空间小，基本不占用存储空间，而且可以反复使用。Configuration类对象保存着配置在MyBatis的信息。在MyBatis中提供了两个SqlSessionFactory的实现类，DefaultSqlSessionFactory和SqlSessionManager。不过SqlSessionManager目前没有使用。 创建SqlSession：SqlSession是一个接口类，真正工作的是Executor接口。构建了SqlSessionFactory，然后生成SqlSession。SqlSession接口类似于一个JDBC中的Connection接口对象，需要保证每次用完正常关闭，所以正确做法是将关闭SqlSession接口的代码写在finally语句中保证每次都会关闭SqlSession。 123456789101112131415// 定义SqlSession Sqlsession sqlSession = null; try &#123; // 打开SqlSession会话 sqlSession = sqlSessionFactory.openSession(); //... sqlSession.commit(); &#125; catch(Exception ex) &#123; sqlSession.rollback(); &#125;finally &#123; // 确保资源被正确关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; 主要用途有两种： 获取映射器，让映射器通过命名空间和方法名称找到对应的SQL，发送给数据库执行后返回结果。 直接通过命名信息去执行SQL返回结果。在SqlSession层可以通过update、insert、select、delete等方法，带上SQL的id来操作在XML中配置好的SQL。 映射器：由Java接口和XML文件(或注解)共同组成的，它的作用如下。 定义参数类型。 描述缓存。 描述SQL语句。 定义查询结果和POJO的映射关系。同样有XML和代码两种方式生成。 组件的生命周期 SqlSessionFactoryBuilder：一旦构建了SqlSessionFactory，它的作用就已经完结，应该被回收。所以它的生命周期只存在于方法的局部，作用是生成SqlSessionFactory对象。 SqlSessionFactory：作用是创建SqlSession(相当于JDBC的Connection对象)。每次应用程序需要访问数据库，就要通过SqlSessionFactory创建SqlSession，所以SqlSessionFactory存在于应用的整个生命周期中。应该采用单例模式(一般方法为将构造方法私有化，并给出一个静态方法，让其返回唯一单例，在多线程初始化单例时，一般需要加线程锁避免类对象被多次初始化)，以避免创建更多SqlSessionFactory而消耗资源。所以一个数据库只应该对应一个SqlSessionFactory。 SqlSession：一个会话，相当于JDBC一个Connection对象，生命周期是在请求数据库处理事务的过程中。该对象线程不安全，应该属于其隔离级别，数据库锁等特性。每次创建的SqlSession都应及时关闭，避免占用数据库连接池。所以，它存活于一个应用的请求和操作中，可以执行多条SQL。 Mapper：是一个接口，没有任何实现类，作用是发送SQL，并返回需要的结果，或者执行SQL以修改数据库数据。因此应该在一个SqlSession事务方法之内，属于方法级别。类似于JDBC中的一条SQL语句的执行，最大的范围和SqlSession相同。 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
