<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDK源码解析 CountDownLatch]]></title>
    <url>%2F2020%2F02%2F23%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-CountDownLatch%2F</url>
    <content type="text"><![CDATA[本篇文章主要介绍一个比较常用的并发工具类——countDownLatch。名称直译为中文为”倒数闩”，它的作用也和门闩一样，用来阻挡一组线程的运行，只有当这一组线程全部达到“门闩”时，才能通行。举个例子， 5个人参加会议，只有当5个人都到会场时，才能继续下一步开会的动作。这种场景就很适合使用CountDownLatch。 和Java中其他常用的并发工具一样，CountDownLatch的内部也是通过AQS实现的。如果还不了解AQS的原理，可以先看一下这篇文章 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class CountDownLatch &#123; /** * Sync继承了AQS类，用来实现CountDownLatch内部对线程 * 的调度和管理 */ private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; // count用来表示要阻塞的线程数量，当count个数量都达到“门闩”时， // 才能被放行 Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; // 如果当前count为0，就立即返回1，对于AQS来说，如果方法 // 返回1，那么当前线程可以立即获得锁，也就是说可以继续 // 被调度，不会被阻塞。 // 否则，返回-1，即当前线程无法获得锁，需要被阻塞，直到 // count减为0才可以被调度。 protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; // countDown方法会调用该方法，将count-1。当count==0时 // 唤醒阻塞线程的操作会由AQS来执行 protected boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125; &#125; private final Sync sync; /** * 初始化一个CountDownLatch，count代表了要阻塞的线程数量 */ public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count); &#125; /** * 当线程调用该方法时，会被阻塞，直到其他线程调用countDown方法，并将count数量 * 减为0时，才会被唤醒放行。 */ public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125; /** * 当一个线程调用这个方法时，会将count数量减1。 * * 当count数量减为0时，会将阻塞在await的线程放行 */ public void countDown() &#123; sync.releaseShared(1); &#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] ThreadLocal]]></title>
    <url>%2F2020%2F02%2F21%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal提供了基于线程的局部变量。在多线程中，每个线程可以有一份隔离于其他线程的独立的副本。ThreadLocal提供的是线程隔离性，而不是线程间的同步机制，所以不应该被用于线程间的通信来使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402/** * 只要线程一直保持存活，并且ThreadLocal实例可访问，那么每个线程都会隐式的持有一 * 份 thread-local变量的副本。当线程销毁后，所有的副本都会被垃圾回收 */public class ThreadLocal&lt;T&gt; &#123; private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT); &#125; protected T initialValue() &#123; return null; &#125; public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; &#125; /** * 设置当前线程的变量的副本 */ public void set(T value) &#123; Thread t = Thread.currentThread(); // ThreadLocal内部使用ThreadLocalMap来存储数据， // 每个Thread对象，都包含有一个ThreadLocalMap类 // 型的变量threadLocals。用来保存这个线程的所有 // 本地变量。ThreadLocalMap使用每个ThreadLocal // 实例作为key ThreadLocalMap map = getMap(t); // 当第一次为线程设置threadLocal变量时，getMap() // 返回null，需要先为线程初始化保存线程本地变量的 // ThreadLocalMap if (map != null) // 如果线程中 map.set(this, value); else // 新建一个ThreadLocalMap对象，类似于HashMap // 向map中put一条数据，key为该ThreadLocal实例 // 然后将Map对象赋值给线程t createMap(t, value); &#125; public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; private static final int INITIAL_CAPACITY = 16; private Entry[] table; private int size = 0; private int threshold; private void setThreshold(int len) &#123; threshold = len * 2 / 3; &#125; private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1); &#125; /** * 为线程初始化一个ThreadLocalMap，当线程第一次设置ThreadLocal * 变量时，会调用这个方法。 */ ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; // 计算哈希值，确定存放Entry的槽 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; // 如果直接命中hash则快速返回；否则调用getEntryAfterMiss if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); &#125; private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; // 遍历slot，直到找到key或者找到空槽(说明key不存在) while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) // 槽里的key已过期，清除过期key expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null; &#125; private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // 与HashMap一样，使用数组来存储哈希槽 Entry[] tab = table; int len = tab.length; // 计算哈希槽值 int i = key.threadLocalHashCode &amp; (len-1); // 与HashMap不同的是，TheadLocalMap采用的是开放定址法存储各个Entry， // 而不是HashMap用的拉链法 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 如果找到了key就用最新值替换 if (k == key) &#123; e.value = value; return; &#125; // 如果key是null，这说明这个ThreadLocal变量已经被remove // 即这个槽已经无用了，所以可以用该key替换 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; // 如果找到了空槽，那么就把新建的Entry放入到空槽中， // 开发定址解决冲突的原理这里不多说 tab[i] = new Entry(key, value); int sz = ++size; // 如过没有已经过期的Entry，并且Entry数量大于阈值， // 那么就会触发rehash if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; e.clear(); expungeStaleEntry(i); return; &#125; &#125; &#125; /** * 替换一个已经无用的槽，因为使用开放定址法存储Entry，所以不能单纯的替换 */ private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // 向前清理所有过时的Entry，避免太多rehash影响性能 int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // 遇到以下情况之一就退出循环： // 1. 找到了当前key // 2. 找到了staleSlot后的第一个为空的slot for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 如果从找到了该key在hash中是存在的，那么就说明key在设置时因为 // 碰撞(冲突)的原因，没有被放在hashCode所在的位置(staleSlot更靠 // 近hashCode得到的槽)，所以现在应该把这个key重新放置在staleSlot中 if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // 如果i对应的slot已过时，且前面没有过时的slot // 就从i开始清理 if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // 如果hash中不存在这个key，就new一个Entry tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // 如果存在不止一个过时的key，就继续清理 if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; /** * 用来清除已经过时的Entry的方法。 * @param staleSlot 已知的要清除的槽对应的下标 * @return staleSlot的下一个为空的槽(下一个说的是nextIndex * 得到的槽, 而不是物理意义上的下一个，可能存在循环) */ private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // 首先先清除给定的过时的槽 tab[staleSlot].value = null; tab[staleSlot] = null; size--; Entry e; int i; // 遍历所有槽，直到找到一个没有用到的(即tab[i]==null)的槽停止 for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; // 如果这个槽对应的entry也过时了，把value和对entry // 的引用设置为null，帮助GC e.value = null; tab[i] = null; size--; &#125; else &#123; // 这个地方涉及到了开放定址法删除元素的策略，因为 // 开放定址法存放Entry的位置跟得到的hash值并不是 // 完全确定的，可能还会向后探查(probe)。所以如果 // 只是单纯的把过时的槽设置为null，可能相同的key // 两次放置的位置不同。 // 重新计算这个槽的key对应的hash值 int h = k.threadLocalHashCode &amp; (len - 1); // 如果新得到的key和之前的不一致，那么就要 // 重新"定位" if (h != i) &#123; // 先把旧的槽设置为null tab[i] = null; // 开放地址法解决冲突，找到下一个空的槽 while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i; &#125; private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; // i对应的slot一定包含有效的Entry，所以从下一个 // 槽开始检查 i = nextIndex(i, len); Entry e = tab[i]; // 如果这s个槽里的Entry已经过时，就从中间开始下次 // 扫描。 if (e != null &amp;&amp; e.get() == null) &#123; // 把n设置为数组的长度，然后不断把n右移 // 相当于二分查找，时间复杂度为lg(n) n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; private void rehash() &#123; expungeStaleEntries(); if (size &gt;= threshold - threshold / 4) resize(); &#125; /** * 将table的容量*2 */ private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; // 如果旧的数组中槽不为空，对应Entry需要放在新数组中 if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 如果slot中的变量已经过期了，那么就把引用设置为null // 帮助GC if (k == null) &#123; e.value = null; // Help the GC &#125; else &#123; // 重新计算Entry对应的hash值，然后放在新的数组中 int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab; &#125; /** * 清除所有已经过时的Entry */ private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125; &#125; &#125;&#125; ThreadLocal为什么会内存泄漏ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。 其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。 但是这些被动的预防措施并不能保证不会内存泄漏： 使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。 分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] ReentrantReadWriteLock]]></title>
    <url>%2F2019%2F12%2F04%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ReentrantReadWriteLock%2F</url>
    <content type="text"><![CDATA[上一篇文章中降到了ReentrantLock，这篇文章中将要讲到Java中另一种锁ReentrantReadWriteLock。ReentrantLock是一种互斥锁，也就是说同一时间只能有一个线程持有锁。而ReentrantReadWriteLock锁在ReentrantLock的基础上，将锁的粒度划分的更细。分为读锁和写锁。读锁是共享锁，写锁是互斥锁。在读-读竞争的情况下，两个请求都可以获得锁。但是，读-写，写-写竞争的情况下，还是会退化成互斥锁。 另外，ReentrantReadWriteLock在写锁上支持Condition，但是读锁上不支持会抛出UnsupportedOperationException123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable &#123; private static final long serialVersionUID = -6992448646407690164L; abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 6317671515068378041L; /* * ReentrantReadWriteLock与ReentrantLock不同，在ReentrantLock中，使用state * 记录了锁重入的数量。但是在ReentrantReadWriteLock中，使用了state的低16位 * 记录了互斥锁的重入数量。而高16位用来记录持有共享锁的数量。所以在ReentrantReadWriteLock * 最大重入数 或者 最大持有共享锁数量 为 65535 */ static final int SHARED_SHIFT = 16; static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT); static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1; static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125; static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; /** * 通过ThreadLocal记录每个线程持有读锁的数量 */ static final class HoldCounter &#123; int count = 0; // Use id, not reference, to avoid garbage retention final long tid = getThreadId(Thread.currentThread()); &#125; private transient HoldCounter cachedHoldCounter; private transient Thread firstReader = null; private transient int firstReaderHoldCount; Sync() &#123; readHolds = new ThreadLocalHoldCounter(); setState(getState()); // ensures visibility of readHolds &#125; /* * Note that tryRelease and tryAcquire can be called by * Conditions. So it is possible that their arguments contain * both read and write holds that are all released during a * condition wait and re-established in tryAcquire. */ protected final boolean tryRelease(int releases) &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int nextc = getState() - releases; boolean free = exclusiveCount(nextc) == 0; if (free) setExclusiveOwnerThread(null); setState(nextc); return free; &#125; protected final boolean tryAcquire(int acquires) &#123; /* * Walkthrough: * 1. If read count nonzero or write count nonzero * and owner is a different thread, fail. * 2. If count would saturate, fail. (This can only * happen if count is already nonzero.) * 3. Otherwise, this thread is eligible for lock if * it is either a reentrant acquire or * queue policy allows it. If so, update state * and set owner. */ Thread current = Thread.currentThread(); int c = getState(); int w = exclusiveCount(c); if (c != 0) &#123; // (Note: if c != 0 and w == 0 then shared count != 0) if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error("Maximum lock count exceeded"); // Reentrant acquire setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true; &#125; protected final boolean tryReleaseShared(int unused) &#123; Thread current = Thread.currentThread(); if (firstReader == current) &#123; // assert firstReaderHoldCount &gt; 0; if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); int count = rh.count; if (count &lt;= 1) &#123; readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); &#125; --rh.count; &#125; for (;;) &#123; int c = getState(); int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) // Releasing the read lock has no effect on readers, // but it may allow waiting writers to proceed if // both read and write locks are now free. return nextc == 0; &#125; &#125; protected final int tryAcquireShared(int unused) &#123; /* * Walkthrough: * 1. 如果有其他线程正持有写锁，获取锁失败 * 2. 否则，就调用readerShouldBlock方法，检查当前线程是否可以 * 获得锁。如果可以就用CAS改变state状态，并返回是否获取成功 * 3. 如果第二步获取锁失败，会fullTryAcquireShared请求锁 */ Thread current = Thread.currentThread(); int c = getState(); // 如果当前有线程持有写锁，且持有写锁的线程不是当前想要获取锁的线程 // 则返回-1，表示获取锁失败 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; int r = sharedCount(c); /** * 1. 首先检查该线程是否应该被阻塞 * a) 在公平锁模式下，如果队列中有正在等待的线程，则当前线程应该被阻塞 * b) 在非公平模式下，如果队列中第一个等待的线程是想要获得写锁的线程 * 为了预防写饥饿，则要将当前线程阻塞 * 2. 如果线程不应该被阻塞，则检查是否达到最大重入个数，在ReentrantReadWriteLock中 * 是65535 * 3. 如果没有达到最大重入个数，则使用CAS更改state */ if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; // r等于0说明当前没有其他线程持有共享锁，则需要更新 // 下面两个字段 firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; // 如果firstReader是当前线程(即上一次将share state 从0-&gt;1的 // 是当前线程)，则更新字段 firstReaderHoldCount++; &#125; else &#123; // 获取最近一次获取锁的线程 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) // 如果rh为null(因为获取锁与设置cachedHoldCounter的动作不是 // 原子的，所以rh可能为null)或者上一次获得锁的线程不是该线程 // 就从readHold中获得上次设置的HoldCounter(注意readHolds是 // ThreadLocal)，如果这是第一次获得锁，则先初始化readHolds // 然后返回 cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) // 如果rh.count为0，这说明该线程已经将之前的锁全部释放了 // 需要重新设置readHolds readHolds.set(rh); // 更细当前线程持有锁的数量 rh.count++; &#125; return 1; &#125; // 获取锁失败，则尝试一次完成获取锁的版本 return fullTryAcquireShared(current); &#125; final int fullTryAcquireShared(Thread current) &#123; HoldCounter rh = null; for (;;) &#123; int c = getState(); if (exclusiveCount(c) != 0) &#123; // 如果有线程持有写锁 if (getExclusiveOwnerThread() != current) // 如果持有写锁的线程不是当前线程，则获取锁失败，返回-1 return -1; // 注意这里如果是当前线程持有读锁，一定不能直接返回-1， // 因为返回-1后，会由AQS进行调度，可能会将该线程阻塞， // 这样该线程就永远无法释放写锁，造成死锁。 &#125; else if (readerShouldBlock()) &#123; // 如果当前线程应该被阻塞 if (firstReader == current) &#123; // 如果是锁重入，则忽略阻塞 // assert firstReaderHoldCount &gt; 0; &#125; else &#123; if (rh == null) &#123; rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) &#123; // 如果之前没有线程获得锁，或者上一个获得锁的 // 是其他线程，就将rh设置为当前线程 rh = readHolds.get(); // 如果当前线程已经没有持有锁了，就清空ThreadLocal if (rh.count == 0) readHolds.remove(); &#125; &#125; if (rh.count == 0) return -1; &#125; &#125; if (sharedCount(c) == MAX_COUNT) throw new Error("Maximum lock count exceeded"); if (compareAndSetState(c, c + SHARED_UNIT)) &#123; // 如果获得锁成功，参照tryAcquireShared方法 if (sharedCount(c) == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; cachedHoldCounter = rh; // cache for release &#125; return 1; &#125; &#125; &#125; final boolean tryWriteLock() &#123; Thread current = Thread.currentThread(); int c = getState(); if (c != 0) &#123; int w = exclusiveCount(c); if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w == MAX_COUNT) throw new Error("Maximum lock count exceeded"); &#125; if (!compareAndSetState(c, c + 1)) return false; setExclusiveOwnerThread(current); return true; &#125; final boolean tryReadLock() &#123; Thread current = Thread.currentThread(); for (;;) &#123; int c = getState(); // 如果有线程持有互斥锁，并且持有互斥锁的不是当前线程 // 就直接返回false， if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return false; int r = sharedCount(c); if (r == MAX_COUNT) throw new Error("Maximum lock count exceeded"); if (compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return true; &#125; &#125; &#125; final int getReadHoldCount() &#123; if (getReadLockCount() == 0) return 0; Thread current = Thread.currentThread(); if (firstReader == current) return firstReaderHoldCount; HoldCounter rh = cachedHoldCounter; if (rh != null &amp;&amp; rh.tid == getThreadId(current)) return rh.count; int count = readHolds.get().count; if (count == 0) readHolds.remove(); return count; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] ReentrantLock]]></title>
    <url>%2F2019%2F12%2F02%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ReentrantLock%2F</url>
    <content type="text"><![CDATA[之前的文章中，已经详细介绍了AQS相关的源码，这篇文章主要介绍Java中的锁。对于锁的概念和Synchronize关键字之间的区别，这里不做介绍，只讲讲ReentrantLock的内部实现原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238public class ReentrantLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = 7373984872572414699L; /** Synchronizer providing all implementation mechanics */ private final Sync sync; /** * ReentrantLock 分为 公平 和 非公平 模式。 Sync作为抽象类继承了AQS， * 而FairSync和NonfairSync又分别继承了Sync各自实现了lock和unlock方法 */ abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; abstract void lock(); final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); /** * 在ReentrantLock中state字段表明了锁是否被持有，以及持有锁的个数 * state = 0 : 当前锁未被持有 * state &gt; 0 : 当前锁已经被持有，且重入个数为 state */ int c = getState(); if (c == 0) &#123; /* 如果当前锁未被持有，尝试获取锁，如果成功，就将持有锁的线程置为自己 */ if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; /** * 如果当前锁已经被持有了，并且持有锁的线程是自己， * 就可以再次持有锁(锁重入)。需要注意的是state字段 * 是int，也就是说可重入的次数最多为Integer.MAX_VALUE * 即2147483647(只针对ReentrantLock来说)，如果超过这个 * 值就会发生溢出 */ int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; protected final boolean isHeldExclusively() &#123; return getExclusiveOwnerThread() == Thread.currentThread(); &#125; final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; final boolean isLocked() &#123; return getState() != 0; &#125; &#125; /** * 非公平模式 */ static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; final void lock() &#123; /** * 该方法在AQS中实现，使用CAS将state字段从0置为1，在ReentrantLock中 * state字段表明了锁是否被持有，以及持有锁的个数 * state = 0 : 当前锁未被持有 * state &gt; 0 : 当前锁已经被持有，且重入个数为 state */ if (compareAndSetState(0, 1)) /** * 如果CAS成功将state 从0置为1 就说明获取锁成功， 把当前持有 * 锁的线程设置为自己。 */ setExclusiveOwnerThread(Thread.currentThread()); else /** * 如果获取锁失败了，就说明发生了锁竞争，必须让AQS来进行调度了 * AQS调度的第一步，会尝试调用下面的tryAcquire实现，如果失败了 * 才会放入AQS队列中 */ acquire(1); /** * 可以看到，在非公平模式中，并没有判断在AQS队列中是否已经有线程在等待锁了， * 只要能立即获得锁，就先获取，这样可以最大化吞吐率，但是可能造成饥饿 */ &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125; &#125; /** * 公平模式 */ static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; /** * 与非公平模式相比，这里直接采用了AQS的调度，而没有先尝试获取锁 * 因为在公平模式下，如果AQS队列中有等待线程，必须等这些线程先获取 * 锁后，当前线程才能获得锁(重入除外) */ acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; /** * 如果当前没有线程持有锁，那么需要先判断AQS队列中 * 是否有线程在等待锁。 * 如果有，那么只能放弃获取锁，并加入AQS队列中 * 如果没有，那么就尝试获取锁 */ if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; /* 锁重入 */ int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; &#125; /** * 默认构造的是非公平锁 */ public ReentrantLock() &#123; sync = new NonfairSync(); &#125; public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; public void lock() &#123; sync.lock(); &#125; /** * 支持中断的获取锁 */ public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; /** * 尝试获取锁，并且立即返回。 * true-获取锁成功 * false-获取锁失败 * * 需要特别注意的是：如果当前锁没有被持有，该方法会立即持有锁。即使在 * 公平模式下，且有其他线程在队列中等待获取锁，该方法也会成功。即该方法 * 会忽略公平模式的设置 */ public boolean tryLock() &#123; return sync.nonfairTryAcquire(1); &#125; /** * 调用时，如果 * 1. 在timeout时间内，该线程没有被打断，且获取锁成功，则返回true * 2. 在非公平模式下锁未被其他线程持有，则获得锁并立即返回true * 3. 在公平模式下锁未被其他线程持有，则要判断是否有其他线程在队列中等待锁 * 由此可见，与tryLock()不同的是，该方法是支持公平模式的。 */ public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; /** * 尝试释放锁，有3种情况 * 1. 如果当前线程持有锁，那么就将state值-1，如果减完后值为0，则释放成功 * 2. 如果不为0，说明只是减少了一层重入。 * 3. 如果不是当前线程持有锁，那么就抛出IllegalMonitorStateException异常 */ public void unlock() &#123; sync.release(1); &#125; /** * 在锁实例上创建一个条件队列，可见我们常说的创建一个锁的 * 条件队列，其实通过其内置的AQS创建一个条件队列，至于其实现 * 就是AQS中Condition的默认实现，这里不再赘述 */ public Condition newCondition() &#123; return sync.newCondition(); &#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] AbstractQueuedSynchronizer]]></title>
    <url>%2F2019%2F11%2F10%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-AbstractQueuedSynchronizer%2F</url>
    <content type="text"><![CDATA[JDK的concurrent包中提供了许多有用的并发工具，比如说lock，countDownLatch, cyclicBarrier等。而实际上，这些工具类中的内部实现都是依赖于AbstractQueuedSynchronizer的实现。所以这篇文章主要来讲解AQS的内部实现原理。 AQS内部依赖一个队列来达到控制同步的效果。除此之外，还使用了int类型的名为state的字段来保存AQS状态(用来表示是否占有锁等)。在每个依赖AQS的工具类中，state的含义可能都不太相同，并且需要自己实现上层的acquire, release的逻辑(底层的改变state的逻辑是由AQS实现，通过getState, setState, compareAndSetState提供了原子方法)。 我们知道锁有独占锁(exclusive)和共享锁(shared)两种，同样的，AQS中也实现了这两种方式。我们熟知的Condition条件，也是由AQS内部类实现的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * 初始化一个state为0的AQS实例 */protected AbstractQueuedSynchronizer() &#123; &#125;/** * 内部队列中保存的Node。 * * AQS的内部队列是CLH队列的变体，CLH锁通常用于自旋锁。在AQS中使用了与CLH * 相似的策略，在一个Node的前驱(predecessor)中保留了一部分关于这个Node的 * 控制信息(control information)。 * * Node中的status字段用来标识一个线程是否应该被阻塞。当一个Node的前驱 * 节点release时，应该唤醒(signal)该Node。否则，队列的每个Node都充当包含 * 一个等待线程的特定通知样式的监视器。status字段不控制是否授予线程锁等。 * 当线程处于队列中第一个位置时，会去尝试获取锁，但是第一并不能保证成功。 * 因此，当前release的线程可能需要重新等待。 * * 当需要将一个Node入队时，需要一个原子操作把它放在队尾。同样的当想要把 * 一个Node出队时，需要原子性的把它从队头移除。AQS也提供了这样的操作 * * prev字段用来处理被取消(cancellation)的线程，如果一个Node中的线程被 * 取消了，那么它的后继(successor)需要将prev字段关联到Node的上一个未 * 被取消的前驱上。 * * next字段用来实现阻塞机制，每个Node中会保存自己线程的id，所以前驱通过 * 遍历next字段，来决定唤醒哪一个Node。当决定哪一个后继Node需要被唤醒时 * 需要避免某个Node正将其next字段链接到一个刚入队的Node上的竞态条件。 * 所以，当一个Node的节点为null时，可以通过从tail向前查询，来避免这种 * 情况。 * * 由于线程存在取消(Cancellation)机制，所以我们总需要轮询节点是否被取消了。 * 当一个节点被取消时，必须唤醒(unpark)其后继节点，并且将这个后继节点重新 * 绑定至一个新的前驱上。 * * CLH队列需要一个虚拟标头节点才能开始，但是并没有在构造方法中初始化这个节点， * 而是在第一次竞争(使用队列时)才初始化。 * * 在Condition条件下等待的线程，会使用上述队列中的Node，但是会额外增加其他 * 链接(link)。当一个线程等待Condition时，它会从同步中，移动到condition * 队列中。而当这个线程被从Condition上唤醒(signal)时，会重新回到同步队列中。 */static final class Node &#123; /** 标识该节点是处于共享模式下 */ static final Node SHARED = new Node(); /** 标识该节点是处于独占模式下 */ static final Node EXCLUSIVE = null; /** 标识节点保存的线程已经被取消 */ static final int CANCELLED = 1; /** 标识节点的后继需要被唤醒 */ static final int SIGNAL = -1; /** 标识该节点正在condition对队中等待 */ static final int CONDITION = -2; /** 表示后续结点会传播唤醒的操作，只在共享模式下起作用 **/ static final int PROPAGATE = -3; /** * SIGNAL: 后继Node被阻塞(通过park操作)，所以当前Node必须 * 在release或者cancel时，唤醒它的后继结点。为了避 * 免竞态条件，acquire方法必须首先说明他们需要signal， * 然后使用原子性的acquire操作，在失败时，阻塞自己。 * CANCELLED: 该Node因为timeout或者interrupt被取消。当一个Node到 * 达该状态后，就不会再发生变化了。 * CONDITION: 表明该Node正在condition队列中等待condition。直到该 * Node从Condition队列中回到正常队列中时(status变回0)， * 才会被关注。 * PROPAGATE: release信号应该被传播给其他的Node，只有在共享模式下 * doReleaseShared操作时对head Node有用。 * 0: 其他 * * 这种使用数字来标识状态的方式，其实在很多地方都可以用到，可以借鉴。 * 非负数的值表示Node不需要被唤醒。 */ volatile int waitStatus; /** * 链接到前驱节点(需要查看前驱节点的waitStatus)。入队时赋值，并且仅在 * 出队时置为null。当前驱被取消时，需要重新链接至一个未被取消的节点。 * 这种节点(新的前驱)将永远存在，因为head节点永远不会被取消(只有当一个节点 * 成功acquire之后，才能成为head节点) */ volatile Node prev; /** * 链接到后继节点(该节点release时需要唤醒后继节点)。入队时赋值，并且仅在 * 出队时置为null。enq操作最后才分配前任的next字段，因此看到空的next字段 * 并不一定意味着该节点位于队列末尾。如果next字段为空，我们可以从tail遍历 * prev以进行再次检查。被取消节点的next字段设置为指向节点本身而不是null， * 以使isOnSyncQueue的工作更简单。 */ volatile Node next; /** 将该Node入队的线程(即实际要获得锁的线程) **/ volatile Thread thread; /** * 指向在condition等待的下一个节点，或者特殊值SHARED。因为condition * 队列仅在独占模式下有效。 */ Node nextWaiter; /** true-共享模式， false-独占模式 **/ final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** 返回该Node前驱 **/ final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; &#125; Node(Thread thread, Node mode) &#123; this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; this.waitStatus = waitStatus; this.thread = thread; &#125;&#125;/** * 同步队列的头，懒加载模式(第一次获取锁时才会初始化)。除了初始化以外， * 只通过setHead()方法进行修改。如果head存在，它的waitStatus一定不是CANCELLED */private transient volatile Node head;/** * 同步队列的头，懒加载模式。 */private transient volatile Node tail;/** * 同步状态 */private volatile int state; protected final int getState() &#123; return state;&#125;protected final void setState(int newState) &#123; state = newState;&#125;/** * 通过CAD乐观锁来修改state状态。 */protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; AQS的最底层的细节我们已经分析完了，那么AQS实际上做了哪些事情呢。将AQS对外暴露的API分为以下几类 acquire, acquireInterruptibly, tryAcquireNanos release acquireShared, acquireSharedInterruptibly, tryAcquireSharedNanos releaseShared 分类1对应的是独占模式下获取锁的操作，分类2对应的是独占模式下释放锁的操作，分类3中对应的是共享模式下获取锁的操作，分类4是共享模式下释放锁的操作。另外这些方法中分别调用了tryAcquire, tryRelease 这种AQS没有实现的方法。事实上这些方法是真正的获取锁与释放锁的逻辑，AQS将这部分留给实现类自己完成。由此我们也就知道了，AQS实际上并不包含获取锁和释放锁的逻辑，AQS的作用只是帮助调度和管理那些想要获取锁和释放锁的线程而已。真正的如何获取和释放锁还是由实现类完成的。有了这样的共识，那么AQS理解起来就会方便多了。 首先我们先来分析独占模式下获取锁和释放锁的实现，只讲解acquire这个最普通的版本，对应的支持中断的和超时的版本大同小异 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/** * 尝试在独占模式下获取锁，并且忽略中断，tryAcquire由每个实现类完成， * AQS会确保调用一次该方法，如果在执行此方法后获取锁失败，就会将请求放入 * AQS队列中，并由AQS控制，不停的tryAcquire直到获取锁为止 */public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;/** * 创建一个包含当前线程，给定模式的节点Node，然后将其入队等待 */private Node addWaiter(Node mode) &#123; // 首先创建一个包含当前线程的节点，并设置独占/共享模式 Node node = new Node(Thread.currentThread(), mode); Node pred = tail; // pred为null的情况：因为head和tail是懒加载的， // 所以只有第一次发生锁竞争的时候，才会初始化tail // 也就是说第一次锁竞争时tail一定是null的，这个 // 时候需要调用enq对head和tail初始化 if (pred != null) &#123; // 注意这里先将node.prev指向了tail，但是 // 与tail.next-&gt;的操作并不是原子的，也就是说 // 在某一时刻，可能已经新入队了一个node, 但是 // 通过next并不能正确找到后继 node.prev = pred; // 尝试快速入队，如果失败则需要完整的调用enq if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; /** * 将Node入队，并且返回之前的tail */private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; /* 如果tail不存在，则说明之前并不存在竞争，需要第一次初始化 */ /** * head和tail同时初始化为Node，如果初始化失败，这说明在此期间， * 有其他Node入队，并且初始化了head和tail，那就再循环一次重新 * 找到队列的tail */ if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; /** * 如果成功将node插入到队尾则插入成功返回之前的tail */ if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125;final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); // 只有前驱为head的节点才有资格尝试获得锁，因为head // 代表的是已经获得过锁的节点，所以head-&gt;next是有资格 // 下次获得锁的节点，具体获取锁的逻辑由实现类自己实现 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 如果node节点成功获得了锁，就将node设置为头结点 // setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; /** * 如果node没有获得锁，那么会尝试下面两步 * 1. 检查当前线程是否可以被阻塞，如果不能被阻塞那么就循环再次尝试获取锁 * 2. 如果当前线程可以被阻塞，那么就阻塞当前线程。被阻塞的线程迟早会被再次唤醒 * 被唤醒后会检查当前线程是否被中断，在该版本中会尝试在获得锁，而acquireInterruptibly * 版本中会响应中断 * 至于线程可不可以被阻塞，shouldParkAfterFailedAcquire是具体实现 */ if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; // 如果获取锁异常，则取消node尝试 if (failed) cancelAcquire(node); &#125;&#125; /** * 当一个node尝试获取锁失败时会调用该方法检查node自身是否需要阻塞 */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // pred节点是node节点的前驱，前面说过节点的waitStatus状态其实是用来控制其 // 后继节点而不是其自身的 int ws = pred.waitStatus; /* * 如果前驱状态已经为SIGNAL了，则node可以被阻塞 * 因为当前驱离开队列时，AQS会检查前驱状态为SIGNAL，一定会唤醒node * 所以可以放心阻塞node，不用担心队列会丧失活性 */ if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; /* * node的前驱已经被cancelled了，所以跳过所有已经被取消的节点， * 将node重新链接到一个有效的前驱上。并且会再给node一次机会，让 * 他重新获取一次锁，因为有可能node前面的节点都被取消了，直接连接到 * head上了，而head的状态不可能&gt;0 */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * 当代码运行到此处时，前驱的waitStatus一定为0或者PROPAGATE状态， * 所以要将前驱状态置为SIGNAL才能放心阻塞node。至于waitStatus什么 * 时候状态会为0或者PROPAGATE可以先向下看 * * 这里并没有去管CAS是否成功，因为后来还会循环再次尝试获取锁，即使更新失败， * 也还会进到这个方法中。 */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 上面几个方法大概就是独享模式下获取锁的整个过程，总结一下waitStatus和队列中的变化 会将当前线程作为node添加到队列尾，如果是第一次发生锁竞争还会同时初始化head和tail。在这一步需要注意的是node.prev = tail 和 tail.next = node 这两步操作不是原子的。这也就是为什么说在AQS中，node.next无法说明其没有后继节点的原因。 获取锁成功时会将head置为node。 获取锁失败时，会判断当前node是否可以被阻塞，而判断条件是node.prev.waitStatus 是否 等于SIGNAL。如果是就可以阻塞，如果不是则需要先将其设置为SIGNAL，然后再尝试获取一次锁 介绍完独占模式下获取锁的实现，在看下独占模式是如何释放锁的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final boolean release(int arg) &#123; // 具体的释放锁的逻辑还是由实现类自己实现的，如果实现类 // 发现释放锁失败了，那么就不涉及其他线程的调度和控制 // 则直接返回false就可以了 if (tryRelease(arg)) &#123; Node h = head; // 首先考虑下head什么时候可能为null？答案是只有未发生过 // 锁竞争的时候，这个时候队列中还没有node呢，所以自然不 // AQS过多关注。再看下head的waitStatus，除了0以外 // waitStatus还可能是SIGNAL, PROPAGATE和SIGNAL。而上面 // 已经说过head节点一定是已经获得过锁的节点，所以不可能为 // CANCELLED状态。PROPAGATE在独占模式下没有用到，可以暂时 // 理解为SIGNAL, 而SIGNAL本身对应的就是后继节点需要被唤醒 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125;private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; // 当状态为SIGNAL和PROPGATE时，首先先将自身状态设置为初始值0 // 这说明已经唤醒了后继节点 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; // 上面说过因为入队操作不是原子的，所以node.next为null不能说明 // node没有后继了，可能存在节点正在入队，必须从tail查找才是准确的。 if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 到此为止，独占模式下的释放锁的操作就分析完了，很简单 如果队列中有节点需要被唤醒继续竞争锁，则把headwaitStatus置为初始值(0)并唤醒后继节点，以保持队列活性。 下面开始分析共享模式下获取锁的操作，在共享模式下，会比独占模式略微复杂，且加入了一个新状态PROPAGATE。至于这个状态的必要性，最后会有分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public final void acquireShared(int arg) &#123; // 与独占模式一样，具体获得锁的实现是由实现类自己完成的 // 返回这&lt;0 说明获取锁失败，则需要入队由AQS管理获得锁 if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125;private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; // 对比于独占模式下返回值为true，false // 这里r有3种情况： // 1. r&gt;0 该次获取锁成功，且下次如果有线程 // 在共享模式下获取锁还是会成功 // 2. r=0 该次获取锁成功，但下次如果有线程 // 在共享模式下获取锁会失败 // 3. r&lt;0 获取锁失败 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 就是这里引入了PROPAGATE状态，具体 // 可看下面该方法的实现 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; // 这里与独占模式完全一样 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // 这里和独占模式还保持一致 setHead(node); // 后面会详细分析 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125;&#125;/** * 共享模式下 对应的release操作---&gt; signal后继节点，并保证signal的传播 */private void doReleaseShared() &#123; /* * 保证在head被release时，后继节点可以被唤醒，或者将唤醒状态传播 */ for (;;) &#123; Node h = head; // 如果同步队列中有节点 if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; // 如果head状态为SIGNAL，就唤醒下一个节点让其争取锁 // 并将状态设置为0 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; &#125; /** * 注意上述行为修改状态失败后，如果是因为head节点替换了(即上一个 * head已经被release)则会选择重试。否则的话就是head节点自身的状 * 态被其他线程修改了，直接放弃就好 */ if (h == head) break; &#125;&#125;public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 可以看到在共享模式下引入了一个PROPAGATE状态，为什么在共享模式下要多出这个状态呢。首先可以思考下共享模式和独占模式的不同，在共享模式下可以有多个线程同时占有锁，而独占模式不可以。 假设一个锁可以被两个线程同时持有，想象这样一个场景，某一时刻，T1和T2已经持有锁了，此时head状态为SIGNAL，而T3和T4正在等待唤醒， 接下来某个时刻，T1释放锁，将head状态设置为0，并唤醒了T3且T3调用tryAcquireShared返回0(即成功获取锁，但是下一个线程不能获得锁，因为此时已经有两个线程T2和T3持有锁了)。 在T3获取锁成功后，它还要设置head，但是这个过程是非原子的。 这个时候，T2线程获得了控制权，且释放锁成功。 然后，T3重新获得控制权，并设置head成功(新head状态为SIGNAL)。由于T2已经释放锁了，这个时候只有T3一个线程持有锁，所以T4是可以获得锁的，但是T4并没有机会被唤醒。 只有当T3释放锁的时候，T4才可能被唤醒，这样就会对性能产生影响。 而加入PROPGATE如何解决这个问题呢？ 先看上面的步骤4，在T2释放锁的时候，它发现head状态已经为0了，那么就head状态设置为PROPAGATE，然后才算成功释放了。不过在T2释放锁的时候，还有两种情况 如果在T2更改head之前，T3先将head重新设置了，也无所谓，因为T2的CAS失败，会重新走一遍循环，发现head状态为SIGNAL了，直接调用unpark唤醒T4就OK了 第二种情况是，T2将状态设置为PROPGATE之后。T3开始设置head(setHeadAndPropgate方法)，由于head状态已经被T2更改为&lt;0的PROPGATE了，所以要调用一遍doReleaseShared，然后发现由T3设置的新head状态为SIGNAL，就调用unpark唤醒T4。 这篇文章中也介绍了PROPGATE的必要性，可以参见AbstractQueuedSynchronizer源码解读。但我们意见不太相同，大佬可以给下意见。 另外还有取消获取锁的方法，就不详细介绍了，只要知道在其取消时，如果需要会先唤醒它的后继节点，保证活性就可以了。 剩下的关于条件队列的部分，会在下一篇文章中讲解。]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>锁</tag>
        <tag>AbstractQueuedSynchronizer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] CompletionService]]></title>
    <url>%2F2019%2F11%2F03%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-CompletionService%2F</url>
    <content type="text"><![CDATA[Java提供了一种基于生产者/消费者模型的服务，用来将提交异步任务和获得返回值的动作解耦。生产者通过submit方法提交任务，消费者通过take方法按照任务完成的顺序得到结果。CompletionService内部实际上依赖于具体的Executor来完成任务，而CompletionService本身只用来将这些任务放在队列中并进行管理。CompletionService的实现类是ExecutorCompletionService，在该实现类中，实现了这些管理任务的方法。 CompletionService接口很简单，简单地提供了一些提交任务和获得返回值得方法，具体分析下ExecutorCompletionService的实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class ExecutorCompletionService&lt;V&gt; implements CompletionService&lt;V&gt; &#123; /* 实际用来异步执行task的工具 */ private final Executor executor; private final AbstractExecutorService aes; /* 用来管理提交的task的队列 */ private final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue; /** * 初始化一个ExecutorCompletionService，并且使用给定的Executor用于 * 在后来执行task任务。并且初始化一个LinkedBlockingQueue用来管理这 * 些任务 * * @throws NullPointerException if executor is &#123;@code null&#125; */ public ExecutorCompletionService(Executor executor) &#123; if (executor == null) throw new NullPointerException(); this.executor = executor; this.aes = (executor instanceof AbstractExecutorService) ? (AbstractExecutorService) executor : null; this.completionQueue = new LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;(); &#125; /** * 使用给定的队列来管理提交的任务，而不是默认的LinkedBlockingQueue * * @throws NullPointerException if executor or completionQueue are &#123;@code null&#125; */ public ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) &#123; if (executor == null || completionQueue == null) throw new NullPointerException(); this.executor = executor; this.aes = (executor instanceof AbstractExecutorService) ? (AbstractExecutorService) executor : null; this.completionQueue = completionQueue; &#125; private class QueueingFuture extends FutureTask&lt;Void&gt; &#123; QueueingFuture(RunnableFuture&lt;V&gt; task) &#123; super(task, null); this.task = task; &#125; protected void done() &#123; completionQueue.add(task); &#125; private final Future&lt;V&gt; task; &#125; /** * 将task转化为FutureTask，并返回 */ private RunnableFuture&lt;V&gt; newTaskFor(Callable&lt;V&gt; task) &#123; if (aes == null) return new FutureTask&lt;V&gt;(task); else return aes.newTaskFor(task); &#125; /** * 将task转化为FutureTask，并返回 */ private RunnableFuture&lt;V&gt; newTaskFor(Runnable task, V result) &#123; if (aes == null) return new FutureTask&lt;V&gt;(task, result); else return aes.newTaskFor(task, result); &#125; /** * 生产者提交一个任务，由Executor将task转化为FutureTask，并放入 * 队列中，然后由executor来执行任务 */ public Future&lt;V&gt; submit(Callable&lt;V&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;V&gt; f = newTaskFor(task); executor.execute(new QueueingFuture(f)); return f; &#125; public Future&lt;V&gt; submit(Runnable task, V result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;V&gt; f = newTaskFor(task, result); executor.execute(new QueueingFuture(f)); return f; &#125; /** * 消费者从队列头取出一个任务，当队列中没有任务完成时， * 会阻塞直到有任务完成 */ public Future&lt;V&gt; take() throws InterruptedException &#123; return completionQueue.take(); &#125; /** * 消费者从队列头取出一个任务，当队列中没有任务完成时， * 会直接返回null */ public Future&lt;V&gt; poll() &#123; return completionQueue.poll(); &#125; public Future&lt;V&gt; poll(long timeout, TimeUnit unit) throws InterruptedException &#123; return completionQueue.poll(timeout, unit); &#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] Executors]]></title>
    <url>%2F2019%2F10%2F22%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Executors%2F</url>
    <content type="text"><![CDATA[JDK中帮我们实现了一些默认的工厂方法和线程池构造方法，这些方法都是在Executors中实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class Executors &#123; /** * 创建一个线程数目固定的线程池。使用无界限队列。即在任意时刻，线程池内 * 最多存在nThread个线程。当所有线程都在工作中时，如果有新任务被提交时， * 任务会被插入队列中，直到线程有空闲。 * 如果有某个线程抛出异常，会有新的线程作为补充，直到显式的调用了shutdown方法 * * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; /** * 与上面的方法一样，但是会使用用户自定义的ThreadFactory创建线程 * * @param nThreads the number of threads in the pool * @param threadFactory the factory to use when creating new threads * @return the newly created thread pool * @throws NullPointerException if threadFactory is null * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory); &#125; /** * 单一线程线程池，即线程池中最多只有一个线程。与FixedThreadPool * 一样使用无界队列，当有多余请求时，会将请求放在队列中。这种线程 * 池可以保证任务被执行的顺序和提交的顺序相同 */ public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; /** * 允许用户使用自定义ThreadFactory * * @return the newly created single-threaded Executor * @throws NullPointerException if threadFactory is null */ public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory)); &#125; /** * 线程池中线程的数量可以为0-Integer.MAX_VALUE，并且可以复用之前的线程。 * * 当任务被提交时，如果线程池中有空闲的线程，就会被复用来处理任务。如果没 * 有，就会创建一个新的线程。所以，对于大量的短时的任务，这种线程池可以 * 提高处理性能。 * * 为了节省资源，当线程空闲超过60秒时，会被终止并且从线程池中移除。 */ public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; /** * 允许用户使用自定义ThreadFactory */ public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory); &#125; /** * SingleThreadPool的可调度版本。允许任务在给定时间后执行，或周期性运行。 */ public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1)); &#125; public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1, threadFactory)); &#125; /** * 创建一个有corePoolSize个线程的可调度线程池 * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */ public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125; public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory); &#125; /** * 返回默认的创建线程的方法，包括： * 1. 非守护线程 * 2. 优先级为NORM_PRIORITY * 3. 通过getName()命名 */ public static ThreadFactory defaultThreadFactory() &#123; return new DefaultThreadFactory(); &#125; /** * 执行一个给定的task并将返回结果包装在Callable中返回 * @param task the task to run * @param result the result to return * @param &lt;T&gt; the type of the result * @return a callable object * @throws NullPointerException if task null */ public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result); &#125; // Non-public classes supporting the public methods /** * 通过该方法就可以将一个Runnable task转化为Callable结果 */ static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125; &#125; /** * The default thread factory */ static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = "pool-" + poolNumber.getAndIncrement() + "-thread-"; &#125; public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125; /** Cannot instantiate. */ private Executors() &#123;&#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] LinkedBlockingQueue]]></title>
    <url>%2F2019%2F10%2F20%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-LinkedBlockingQueue%2F</url>
    <content type="text"><![CDATA[上一篇文章中我们讲到了ArrayBlockingQueue，这篇文章中将要主要介绍LinkedBlockingQueue。LinkedBlockingQueue底层使用链表实现，大小最大可以为Integer.MAX_VALUE. 链表使用的结点是LinkedBlockingQueue的内部类，先看一下结点的实现方式 12345678910111213static class Node&lt;E&gt; &#123; E item; /** * 可以为下列情况之一 * 1. 后继节点 * 2. 该节点本身，即该节点的后继是head.next * 3. null，即没有后继(该节点为最后的结点) */ Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125; &#125; 结点的实现方式就是这么简单。LinkedBlockingQueue与ArrayBlockingQueue不同的是，LinkedBlockedQueue使用了两个锁来控制并发，而不是一个锁。put lock用来锁住put(offfer操作)，并且有一个关联的puts操作的条件变量。另一个锁take lock也一样。因为这两个锁都共用到了count字段，所以count被设计称atomic类型，以避免要持有锁才能进行修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** 容量限制，如果没有则为Integer.MAX_VAKUE(近似于无界队列) */private final int capacity;/** 当前队列中元素数量 (这里使用了原子类，和ArrayBlockingQueue中的并不一样) */private final AtomicInteger count = new AtomicInteger();/** 链表头，且head.item == null */transient Node&lt;E&gt; head;/** 链表尾，且last.next == null */private transient Node&lt;E&gt; last;/** take, poll等操作需要持有的锁 */private final ReentrantLock takeLock = new ReentrantLock();/** 等待take锁的条件变量 */private final Condition notEmpty = takeLock.newCondition();/** put，offer等操作需要持有的锁 */private final ReentrantLock putLock = new ReentrantLock();/** 等待put锁的条件变量 */private final Condition notFull = putLock.newCondition();/** * signal take操作的条件变量，只有put/offer方法才会调用 */private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125;&#125;/** * signal put条件变量。只会被take和poll调用 */private void signalNotFull() &#123; final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125;&#125;/** 添加元素到队列尾 */private void enqueue(Node&lt;E&gt; node) &#123; // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node;&#125;/** 移除队列头 */private E dequeue() &#123; // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x;&#125;void fullyLock() &#123; putLock.lock(); takeLock.lock();&#125;void fullyUnlock() &#123; takeLock.unlock(); putLock.unlock();&#125; 下面看下LinkedBlockingQueue的构造函数 12345678910111213141516171819202122232425262728293031323334353637383940public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);&#125;/** * @throws IllegalArgumentException 如果 capacity &lt; 0 */public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null);&#125;/** * 初始化一个容量为Integer.MAX_VALUE的队列，然后将给定c的元素初始化 * 到队列中 * @throws NullPointerException if the specified collection or any * of its elements are null */public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) &#123; this(Integer.MAX_VALUE); final ReentrantLock putLock = this.putLock; // 保证可见性 putLock.lock(); try &#123; int n = 0; for (E e : c) &#123; if (e == null) throw new NullPointerException(); if (n == capacity) throw new IllegalStateException("Queue full"); enqueue(new Node&lt;E&gt;(e)); ++n; &#125; count.set(n); &#125; finally &#123; putLock.unlock(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209// 队列中元素的个数 public int size() &#123; return count.get();&#125; public int remainingCapacity() &#123; return capacity - count.get();&#125;/** * 将给定的元素放入到队列尾，如果队列已满，则阻塞直到有空余容量 * @throws InterruptedException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; while (count.get() == capacity) &#123; notFull.await(); &#125; enqueue(node); // 获取插入元素前队列元素的数量，并且将数量+1 c = count.getAndIncrement(); // 如果插入后队列仍有空余容量，则唤醒notFull条件等待的操作 if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; // 如果插入前队列为空，那么唤醒在notEmpty条件等待的操作 if (c == 0) signalNotEmpty();&#125;/** * 将给定的元素放入到队列尾，如果队列已满，则在下面两种情况返回： * 1. 在给定时间内，插入成功，返回True * 2. 在给定时间内，队列仍然没有空余容量，返回False * * @throws InterruptedException * @throws NullPointerException */public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; while (count.get() == capacity) &#123; if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos); &#125; enqueue(new Node&lt;E&gt;(e)); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty(); return true;&#125;/** * 将给定元素插入到队列中，如果队列已满，则返回False；否则， * 返回True * @throws NullPointerException if the specified element is null */public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; // 如果容量已满，则返回false if (count.get() == capacity) return false; int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; // 二次判断，如果未满，则入队 if (count.get() &lt; capacity) &#123; enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty(); return c &gt;= 0;&#125;/** * put的对应版本 */public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; notEmpty.await(); &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125;/** * offer(E e, long timeout, TimeUnit unit)的对应版本 */public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; E x = null; int c = -1; long nanos = unit.toNanos(timeout); final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; if (nanos &lt;= 0) return null; nanos = notEmpty.awaitNanos(nanos); &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125;/** * offer(e)的对应版本 */public E poll() &#123; final AtomicInteger count = this.count; if (count.get() == 0) return null; E x = null; int c = -1; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; if (count.get() &gt; 0) &#123; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125;/** * 与poll方法类似，只不过不移除队头 */public E peek() &#123; if (count.get() == 0) return null; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; Node&lt;E&gt; first = head.next; if (first == null) return null; else return first.item; &#125; finally &#123; takeLock.unlock(); &#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] ArrayBlockingQueue]]></title>
    <url>%2F2019%2F10%2F19%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ArrayBlockingQueue%2F</url>
    <content type="text"><![CDATA[在JDK各个阻塞队列的实现中ArrayBlockingQueue是最简单的，底层是由数组实现的。 ArrayBlockingQueue是最经典的生产者-消费者模型，固定大小的数组维护了一些数据，当生产者向容量已满的队列添加元素时会被阻塞，消费者从一个空队列中取出元素时也会阻塞。 ArrayBlockingQueue同时还提供了可选择的公平模式。会将阻塞的生产者和消费者排队以保证顺序。采用公平模式会降低队列的吞吐率，但是会避免饥饿。 ArrayBlockingQueue底层使用一个ReentrantLock和两个Condition来实现并发和阻塞的控制 我们首先来看ArrayBlockingQueue底层用到了哪些字段和私有方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; private static final long serialVersionUID = -817911632652898426L; /** 底层用来存储元素的数组 */ final Object[] items; /** 下一次take，poll，peek或者remove操作所要操作的元素的下标 */ int takeIndex; /** 下一次put，offer或者add操作要操作的下标 */ int putIndex; /** 队列中元素的个数 */ int count; /** 数据访问的锁，在所有对队列进行更改的操作前，都需要获取该锁 */ final ReentrantLock lock; /** 消费者阻塞条件 */ private final Condition notEmpty; /** 生产者阻塞条件 */ private final Condition notFull; /** * Shared state for currently active iterators, or null if there * are known not to be any. Allows queue operations to update * iterator state. */ transient Itrs itrs = null; final int dec(int i) &#123; return ((i == 0) ? items.length : i) - 1; &#125; @SuppressWarnings("unchecked") final E itemAt(int i) &#123; return (E) items[i]; &#125; /** * 通过该方法可以知道，ArrayBlockingQueue是不接受null值的 * 当传入一个null值时会抛出NPE */ private static void checkNotNull(Object v) &#123; if (v == null) throw new NullPointerException(); &#125; /** * 只有在持有锁的时候才会调用该方法 */ private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal(); &#125; /** * 将takeIndex位置的元素移除，并返回 */ private E dequeue() &#123; // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings("unchecked") E x = (E) items[takeIndex]; items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); notFull.signal(); return x; &#125; /** * Deletes item at array index removeIndex. * Utility for remove(Object) and iterator.remove. * Call only when holding lock. */ void removeAt(final int removeIndex) &#123; // assert lock.getHoldCount() == 1; // assert items[removeIndex] != null; // assert removeIndex &gt;= 0 &amp;&amp; removeIndex &lt; items.length; final Object[] items = this.items; if (removeIndex == takeIndex) &#123; // removing front item; just advance items[takeIndex] = null; if (++takeIndex == items.length) takeIndex = 0; count--; if (itrs != null) itrs.elementDequeued(); &#125; else &#123; // an "interior" remove // slide over all others up through putIndex. final int putIndex = this.putIndex; for (int i = removeIndex;;) &#123; int next = i + 1; if (next == items.length) next = 0; if (next != putIndex) &#123; items[i] = items[next]; i = next; &#125; else &#123; items[i] = null; this.putIndex = i; break; &#125; &#125; count--; if (itrs != null) itrs.removedAt(removeIndex); &#125; notFull.signal(); &#125;&#125; 然后再来看看ArrayBlockingQueue的构造方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 初始化一个固定大小的非公平队列。 * * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125; */public ArrayBlockingQueue(int capacity) &#123; this(capacity, false);&#125;/** * 初始化一个固定大小的ArrayBlockingQueue。如果fair为true那么就是公平 * 的，否则就是默认非公平的。 * * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125; */public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125;/** * 创建一个固定大小的队列，并将给定的集合c中的元素初始化到队列中。如果fair * 为true那么就是公平的，否则就是默认非公平的。 * * @throws IllegalArgumentException if &#123;@code capacity&#125; is less than * &#123;@code c.size()&#125;, or less than 1. * @throws NullPointerException if the specified collection or any * of its elements are null */public ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c) &#123; this(capacity, fair); final ReentrantLock lock = this.lock; /** * 这里的lock是用来保证可见性的而不是用作互斥锁，因为CPU的重排序 * 或其他原因，可能导致在后来调用put，add等操作时，item等字段并 * 初始化完成，所以lock的happens-before特性可以保证可见性 */ lock.lock(); try &#123; int i = 0; try &#123; for (E e : c) &#123; checkNotNull(e); items[i++] = e; &#125; &#125; catch (ArrayIndexOutOfBoundsException ex) &#123; throw new IllegalArgumentException(); &#125; count = i; putIndex = (i == capacity) ? 0 : i; &#125; finally &#123; lock.unlock(); &#125;&#125; BlockingQueue中提供了对队列不同的入队/出队的操作，下面我看看下在ArrayBlocking中是如何实现的 1234567891011121314/** * 将元素插入到队列尾，如果队列已满，会抛出IllegalStateException，否则返回True * * @throws IllegalStateException if this queue is full * @throws NullPointerException if the specified element is null */public boolean add(E e) &#123; /** * 调用AbstractQueue中的add方法。在AbstractQueue中会调用子类的 * offer方法，如果offer方法返回False会抛出IllegalStateException * 否则返回True */ return super.add(e);&#125; offer/poll组合，会在队列已满/为空时阻塞直接返回false/null而不会等待123456789101112131415161718192021222324252627282930313233/** * 将元素插入到队列尾，如果队列已满，会返回False，否则返回True * * @throws NullPointerException if the specified element is null */public boolean offer(E e) &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;/** * offer的对应版本，如果队列为空返回null，否则返回队列头 */public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return (count == 0) ? null : dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; put/take组合，会在队列已满/为空时阻塞123456789101112131415161718192021222324252627282930313233343536/** * 将元素插入到队列尾，如果队列已满，会阻塞直到队列非空 * * @throws InterruptedException * @throws NullPointerException */public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == items.length) // 如果队列已满，则在notFull条件上等待 // 当队列头被移除时，notFull.signal() // 会被调用并唤醒该条件 notFull.await(); enqueue(e); &#125; finally &#123; lock.unlock(); &#125;&#125;/** * put的对应版本，如果队列为空，则等待其他元素插入 */public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; offer/poll带有超时的版本，12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 将元素插入到队列尾，如果队列已满，会阻塞直到下列条件一直发生 * 1. 队列为空：则插入元素，并返回True * 2. 超过timeout时间：返回False * * @throws InterruptedException * @throws NullPointerException */public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; checkNotNull(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == items.length) &#123; if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos); &#125; enqueue(e); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;/** * 与offer(e, timeout, unit)对应 */public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) &#123; if (nanos &lt;= 0) return null; nanos = notEmpty.awaitNanos(nanos); &#125; return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; ArrayBlockingQueue中一些其他的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265// 取出队列头，但是不移除。如果队列为空则返回nullpublic E peek() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return itemAt(takeIndex); // null when queue is empty &#125; finally &#123; lock.unlock(); &#125;&#125;/** * 返回队列中元素个数 */public int size() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return count; &#125; finally &#123; lock.unlock(); &#125;&#125;public int remainingCapacity() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return items.length - count; &#125; finally &#123; lock.unlock(); &#125;&#125;/** * 从队列中移除一个o的实例，如果队列中存在至少一个o则返回true，否则返回false。 * * 对于以循环数组为底层的队列，想要从中中间移除一个元素时缓慢的。所以理想情况下， * 应该保证在执行该操作时，没有其他操作在同时进行 * @param o element to be removed from this queue, if present * @return &#123;@code true&#125; if this queue changed as a result of the call */public boolean remove(Object o) &#123; if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count &gt; 0) &#123; final int putIndex = this.putIndex; int i = takeIndex; do &#123; if (o.equals(items[i])) &#123; removeAt(i); return true; &#125; if (++i == items.length) i = 0; &#125; while (i != putIndex); &#125; return false; &#125; finally &#123; lock.unlock(); &#125;&#125;/** * 如果队列中包含o则返回true * * @param o object to be checked for containment in this queue * @return &#123;@code true&#125; if this queue contains the specified element */public boolean contains(Object o) &#123; if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count &gt; 0) &#123; final int putIndex = this.putIndex; int i = takeIndex; do &#123; if (o.equals(items[i])) return true; if (++i == items.length) i = 0; &#125; while (i != putIndex); &#125; return false; &#125; finally &#123; lock.unlock(); &#125;&#125;public Object[] toArray() &#123; Object[] a; final ReentrantLock lock = this.lock; lock.lock(); try &#123; final int count = this.count; a = new Object[count]; int n = items.length - takeIndex; if (count &lt;= n) System.arraycopy(items, takeIndex, a, 0, count); else &#123; System.arraycopy(items, takeIndex, a, 0, n); System.arraycopy(items, 0, a, n, count - n); &#125; &#125; finally &#123; lock.unlock(); &#125; return a;&#125;/** * 将队列中的元素全部放入给定数组中并返回。如果给定数组大小不够，那么会新分配 * 一个运行时类型与给定数组相同的，大小为队列中元素数量的新数组。并将队列中元 * 素放入数组中。如果给定数组的容量比队列中元素数量大，那么紧跟着的那个下标 * 会被置为null。 * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this queue * @throws NullPointerException if the specified array is null */@SuppressWarnings("unchecked")public &lt;T&gt; T[] toArray(T[] a) &#123; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; final int count = this.count; final int len = a.length; if (len &lt; count) // 新分配一个运行时类型与给定数组相同的，大小为 // 队列中元素数量的新数组 a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), count); int n = items.length - takeIndex; if (count &lt;= n) System.arraycopy(items, takeIndex, a, 0, count); else &#123; System.arraycopy(items, takeIndex, a, 0, n); System.arraycopy(items, 0, a, n, count - n); &#125; if (len &gt; count) a[count] = null; &#125; finally &#123; lock.unlock(); &#125; return a;&#125;public String toString() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; int k = count; if (k == 0) return "[]"; final Object[] items = this.items; StringBuilder sb = new StringBuilder(); sb.append('['); for (int i = takeIndex; ; ) &#123; Object e = items[i]; sb.append(e == this ? "(this Collection)" : e); if (--k == 0) return sb.append(']').toString(); sb.append(',').append(' '); if (++i == items.length) i = 0; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;public void clear() &#123; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; int k = count; if (k &gt; 0) &#123; final int putIndex = this.putIndex; int i = takeIndex; do &#123; items[i] = null; if (++i == items.length) i = 0; &#125; while (i != putIndex); takeIndex = putIndex; count = 0; if (itrs != null) itrs.queueIsEmpty(); for (; k &gt; 0 &amp;&amp; lock.hasWaiters(notFull); k--) notFull.signal(); &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;/** * @throws UnsupportedOperationException * @throws ClassCastException * @throws NullPointerException * @throws IllegalArgumentException */public int drainTo(Collection&lt;? super E&gt; c) &#123; return drainTo(c, Integer.MAX_VALUE);&#125;/** * 从队列中移除最多maxElements个元素，并将他们放入c中 * * @throws UnsupportedOperationException * @throws ClassCastException * @throws NullPointerException * @throws IllegalArgumentException */public int drainTo(Collection&lt;? super E&gt; c, int maxElements) &#123; checkNotNull(c); if (c == this) throw new IllegalArgumentException(); if (maxElements &lt;= 0) return 0; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; int n = Math.min(maxElements, count); int take = takeIndex; int i = 0; try &#123; while (i &lt; n) &#123; @SuppressWarnings("unchecked") E x = (E) items[take]; c.add(x); items[take] = null; if (++take == items.length) take = 0; i++; &#125; return n; &#125; finally &#123; // Restore invariants even if c.add() threw if (i &gt; 0) &#123; count -= i; takeIndex = take; if (itrs != null) &#123; if (count == 0) itrs.queueIsEmpty(); else if (i &gt; take) itrs.takeIndexWrapped(); &#125; for (; i &gt; 0 &amp;&amp; lock.hasWaiters(notFull); i--) notFull.signal(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] BlockingQueue]]></title>
    <url>%2F2019%2F10%2F15%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-BlockingQueue%2F</url>
    <content type="text"><![CDATA[BlockingQueue是concurrent中的一个集合类，它继承了Queue接口。下面是BlockingQueue和它的实现类的类图。 BlockingQueue在Queue的基础上增加了两种功能： 在从队列中获取数据，并且queue为空的时候，等待直到queue非空。 在向队列中添加数据，并且queue已满的时候，等待直到queue有容量。 为了支持以上两种功能，BlockingQueue共提供了4组操作方式 抛出异常 返回特殊值(null或false) 阻塞 超时 插入 add(e) offer(e) put(e) offer(e, time, unit) 删除 remove() poll() take() poll(time, unit) 取值 element() peek() 无 无 BlockingQueue不接受null值，当add(), put(), offer()接受null值会抛出NullPointerException。null被poll方法用来作为指示值。 BlockingQueue的实现是线程安全的。所有的队列操作都通过内部的锁或其他方式实现了并发控制。但是，批量操作，如：addAll、containsAll、retainAll、removeAll不一定是原子性的。所以有可能在调用allAll时，当一部分元素插入成功后，抛出异常。 下面是一个典型使用BlockingQueue实现的生产者-消费者模型示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Producer implements Runnable &#123; private final BlockingQueue queue; Producer(BlockingQueue q) &#123; queue = q; &#125; public void run() &#123; try &#123; while (true) &#123; queue.put(produce()); &#125; &#125; catch (InterruptedException ex) &#123; // ... handle ... &#125; &#125; Object produce() &#123; // ... &#125;&#125; class Consumer implements Runnable &#123; private final BlockingQueue queue; Consumer(BlockingQueue q) &#123; queue = q; &#125; public void run() &#123; try &#123; while (true) &#123; consume(queue.take()); &#125; &#125; catch (InterruptedException ex) &#123; // ... handle ... &#125; &#125; void consume(Object x) &#123; // ... &#125;&#125; class Setup &#123; void main() &#123; BlockingQueue q = new SomeQueueImplementation(); Producer p = new Producer(q); Consumer c1 = new Consumer(q); Consumer c2 = new Consumer(q); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); &#125;&#125; 内存一致性： As with other concurrent collections, actions in a thread prior to placing an object into a BlockingQueue happen-before actions subsequent to the access or removal of that element from the BlockingQueue in another thread. 一个线程向BlockingQueue中插入一个元素的操作，总是发生在另一个线程从BlockingQueue中取出该元素的操作之前 下面对接口中的API进行说明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 将给定的元素添加到队列中。如果队列中没有空余容量就抛出IllegalStateException； * 成功返回true */boolean add(E e);/** * 将给定的元素添加到队列中。如果队列中没有空余容量则返回false；成功返回true */boolean offer(E e);/** * 将给定的元素添加到队列中，如果没有空余容量，则阻塞直到有空余容量 */void put(E e) throws InterruptedException;/** * 将给定的元素添加到队列中，如果没有空余容量，则等待timeout时间。如果在这段 * 时间内仍然添加失败，则返回false；若成功，返回true */boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;/** * 获取并移除队列头元素，如果队列为空，则阻塞直到有元素可以获取。 */E take() throws InterruptedException;/** * 获取并移除队列头元素，如果队列为空，则等待timeout时间。若在这段时间内有元素添加 * 到队列中，则返回该元素，否则返回null； */E poll(long timeout, TimeUnit unit) throws InterruptedException;/** * 返回当前队列的剩余容量。remainingCapacity无法准确的得到这个数量，因为有其 * 他线程可能正在插入或者移除 */int remainingCapacity();/** * 如果给定实例在队列中存在，则移除该元素 */boolean remove(Object o);/** * 如果给定实例在队列中存在，则返回true */public boolean contains(Object o);/** * 移除队列中所有可用的元素，并添加到给定的Collection c中。如果队列和c相等， * 那么会抛出IllegalArgumentException。如果给定的c在添加过程中被修改，那么 * 结果是未知的 */int drainTo(Collection&lt;? super E&gt; c);/** * 移除队列中最多maxElements个元素，并添加到给定的Collection c中。如果队列 * 和c相等，那么会抛出IllegalArgumentException。如果给定的c在添加过程中被修 * 改，那么结果是未知的。 */int drainTo(Collection&lt;? super E&gt; c, int maxElements);]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>阻塞队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] ScheduledThreadPoolExecutor]]></title>
    <url>%2F2019%2F07%2F14%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ScheduledThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[在前面的文章中已经分析过ThreadPoolExecutor的源码，ScheduleThreadPoolExecutor继承ThreadPoolExecutor的同时也实现了ScheduleExecutorService，所以ScheduleThreadPoolExecutor是对ThreadPoolExecutor的进一步扩展，并且提供了在一定延迟后或者定时调度任务的功能，可以看下它的类图。 下面来看下源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService &#123; /** * 如果调用完shutdown后，不在继续运行 periodic(周期性)任务，则设置为False */ private volatile boolean continueExistingPeriodicTasksAfterShutdown; /** * 如果调用shutdown后，要取消非周期性任务，则置为False */ private volatile boolean executeExistingDelayedTasksAfterShutdown = true; /** * 如果该值为True，则当前任务已经取消了，会从任务队列中真正的移除，而不只是 * 仅仅标识其为删除状态； */ private volatile boolean removeOnCancel = false; /** * 该变量记录了当前任务被创建时的任务序号，这个序号的主要用于确认当 * 两个任务开始执行时间相同时具体哪个任务先执行(序号小的先执行) */ private static final AtomicLong sequencer = new AtomicLong(); final long now() &#123; return System.nanoTime(); &#125; /** * 这个内部类封装了提交的Task，并增加一些字段用来记录调度信息等 */ private class ScheduledFutureTask&lt;V&gt; extends FutureTask&lt;V&gt; implements RunnableScheduledFuture&lt;V&gt; &#123; // 当前任务的序号 private final long sequenceNumber; // 任务可以开始执行的时间 private long time; /** * 用来记录周期性任务的间隔(nanoseconds) * 正数：fixed-rate(启动频率固定) 任务 * 负数：fixed-delay(间隔时间固定) 任务 * 0: 非周期性任务 */ private final long period; // 周期性任务，该字段保留了需要重复运行的task RunnableScheduledFuture&lt;V&gt; outerTask = this; // 阻塞队列以堆的形式存在，这个字段保存了task在堆中的位置 int heapIndex; /** * 创建一个只能运行一次的任务，开始时间为ns(nanoTime-based) */ ScheduledFutureTask(Runnable r, V result, long ns) &#123; super(r, result); this.time = ns; this.period = 0; this.sequenceNumber = sequencer.getAndIncrement(); &#125; /** * 创建一个周期性任务，开始时间为ns(nanoTime-based)，周期为period */ ScheduledFutureTask(Runnable r, V result, long ns, long period) &#123; super(r, result); this.time = ns; this.period = period; this.sequenceNumber = sequencer.getAndIncrement(); &#125; /** * 创建一个只能运行一次的任务，开始时间为ns(nanoTime-based) */ ScheduledFutureTask(Callable&lt;V&gt; callable, long ns) &#123; super(callable); this.time = ns; this.period = 0; this.sequenceNumber = sequencer.getAndIncrement(); &#125; // 该内部类实现了Delayed接口，这个方法是Delayed中的方法， // 用来返回距离下次运行的时间 public long getDelay(TimeUnit unit) &#123; return unit.convert(time - now(), NANOSECONDS); &#125; // Delayed接口实现了Comparable接口，通过这个方法，可以比较两个 // task距离下次运行时间的长短 public int compareTo(Delayed other) &#123; if (other == this) // compare zero if same object return 0; if (other instanceof ScheduledFutureTask) &#123; ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;) other; long diff = time - x.time; if (diff &lt; 0) return -1; else if (diff &gt; 0) return 1; else if (sequenceNumber &lt; x.sequenceNumber) return -1; else return 1; &#125; long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS); return (diff &lt; 0) ? -1 : (diff &gt; 0) ? 1 : 0; &#125; /** * @return true - 该任务是个周期性任务 */ public boolean isPeriodic() &#123; return period != 0; &#125; /** * 设置周期性任务的下次运行时间 */ private void setNextRunTime() &#123; long p = period; if (p &gt; 0) time += p; else // p &lt; 0 时下次运行时间，取决于上次任务完成的时间 // 所以需要处理 time = triggerTime(-p); &#125; public boolean cancel(boolean mayInterruptIfRunning) &#123; boolean cancelled = super.cancel(mayInterruptIfRunning); if (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= 0) remove(this); return cancelled; &#125; public void run() &#123; boolean periodic = isPeriodic(); if (!canRunInCurrentRunState(periodic)) // 如果线程池已经关闭 cancel(false); else if (!periodic) // 如果是非周期性任务，直接运行就可以 ScheduledFutureTask.super.run(); else if (ScheduledFutureTask.super.runAndReset()) &#123; // 周期性任务运行并重置状态 setNextRunTime(); reExecutePeriodic(outerTask); &#125; &#125; &#125; /** * @return true - 如果线程池正在RUNNING状态，或者正在SHUTDOWN状态 * 且传入的值为true */ boolean canRunInCurrentRunState(boolean periodic) &#123; return isRunningOrShutdown(periodic ? continueExistingPeriodicTasksAfterShutdown : executeExistingDelayedTasksAfterShutdown); &#125; private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123; if (isShutdown()) reject(task); else &#123; super.getQueue().add(task); // 如果在添加task到队列的过程中，线程池状态发生了改变， // 可能无法运行，必须重新判断 if (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task)) task.cancel(false); else ensurePrestart(); // 创建一个线程，保证有线程能执行任务 &#125; &#125; /** * 重新将周期性任务添加到等待队列中 */ void reExecutePeriodic(RunnableScheduledFuture&lt;?&gt; task) &#123; if (canRunInCurrentRunState(true)) &#123; super.getQueue().add(task); if (!canRunInCurrentRunState(true) &amp;&amp; remove(task)) task.cancel(false); else ensurePrestart(); &#125; &#125; /** * super.shutdown方法成功完成后，会调用onShutDown()方法作为扩展， * 该方法会取消并清除队列中所有任务。 */ @Override void onShutdown() &#123; BlockingQueue&lt;Runnable&gt; q = super.getQueue(); boolean keepDelayed = getExecuteExistingDelayedTasksAfterShutdownPolicy(); boolean keepPeriodic = getContinueExistingPeriodicTasksAfterShutdownPolicy(); // 如果既不保留 Delayed任务，也不保留Periodic任务 if (!keepDelayed &amp;&amp; !keepPeriodic) &#123; // 遍历清空队列中所有任务 for (Object e : q.toArray()) if (e instanceof RunnableScheduledFuture&lt;?&gt;) ((RunnableScheduledFuture&lt;?&gt;) e).cancel(false); q.clear(); &#125; else &#123; // 遍历队列中符合清除条件的任务 for (Object e : q.toArray()) &#123; if (e instanceof RunnableScheduledFuture) &#123; RunnableScheduledFuture&lt;?&gt; t = (RunnableScheduledFuture&lt;?&gt;) e; if ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) || t.isCancelled()) &#123; // also remove if already cancelled if (q.remove(t)) t.cancel(false); &#125; &#125; &#125; &#125; // 尝试Terminate tryTerminate(); &#125; /* decorate方法都可以被子类继承覆写，从而对task进行修改，可以参考装饰模式*/ protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask( Runnable runnable, RunnableScheduledFuture&lt;V&gt; task) &#123; return task; &#125; protected &lt;V&gt; RunnableScheduledFuture&lt;V&gt; decorateTask( Callable&lt;V&gt; callable, RunnableScheduledFuture&lt;V&gt; task) &#123; return task; &#125; /* ScheduledThreadPoolExecutor 使用无界队列，所以MaximumPoolSize没有用处，构造方法都不包含这个参数 */ public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); &#125; public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory); &#125; public ScheduledThreadPoolExecutor(int corePoolSize, RejectedExecutionHandler handler) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), handler); &#125; public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory, handler); &#125; private long triggerTime(long delay, TimeUnit unit) &#123; return triggerTime(unit.toNanos((delay &lt; 0) ? 0 : delay)); &#125; long triggerTime(long delay) &#123; return now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; 1)) ? delay : overflowFree(delay)); &#125; private long overflowFree(long delay) &#123; // 如果这个值溢出了，那么一定是负值在队列的最前面 Delayed head = (Delayed) super.getQueue().peek(); if (head != null) &#123; long headDelay = head.getDelay(NANOSECONDS); // 重新计算delay值 if (headDelay &lt; 0 &amp;&amp; (delay - headDelay &lt; 0)) delay = Long.MAX_VALUE + headDelay; &#125; return delay; &#125; /** * @throws RejectedExecutionException * @throws NullPointerException */ public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); delayedExecute(t); return t; &#125; /** * @throws RejectedExecutionException * @throws NullPointerException */ public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit) &#123; if (callable == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable, new ScheduledFutureTask&lt;V&gt;(callable, triggerTime(delay, unit))); delayedExecute(t); return t; &#125; /** * @throws RejectedExecutionException * @throws NullPointerException * @throws IllegalArgumentException */ public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); if (period &lt;= 0) throw new IllegalArgumentException(); ScheduledFutureTask&lt;Void&gt; sft = new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(initialDelay, unit), unit.toNanos(period)); RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft); sft.outerTask = t; delayedExecute(t); return t; &#125; /** * @throws RejectedExecutionException * @throws NullPointerException * @throws IllegalArgumentException */ public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); if (delay &lt;= 0) throw new IllegalArgumentException(); ScheduledFutureTask&lt;Void&gt; sft = new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(initialDelay, unit), unit.toNanos(-delay)); RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft); sft.outerTask = t; delayedExecute(t); return t; &#125; public void execute(Runnable command) &#123; schedule(command, 0, NANOSECONDS); &#125; /** * @throws RejectedExecutionException * @throws NullPointerException */ public Future&lt;?&gt; submit(Runnable task) &#123; return schedule(task, 0, NANOSECONDS); &#125; /** * @throws RejectedExecutionException * @throws NullPointerException */ public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; return schedule(Executors.callable(task, result), 0, NANOSECONDS); &#125; /** * @throws RejectedExecutionException * @throws NullPointerException */ public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; return schedule(task, 0, NANOSECONDS); &#125; public void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value) &#123; continueExistingPeriodicTasksAfterShutdown = value; if (!value &amp;&amp; isShutdown()) onShutdown(); &#125; public boolean getContinueExistingPeriodicTasksAfterShutdownPolicy() &#123; return continueExistingPeriodicTasksAfterShutdown; &#125; public void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value) &#123; executeExistingDelayedTasksAfterShutdown = value; if (!value &amp;&amp; isShutdown()) onShutdown(); &#125; public boolean getExecuteExistingDelayedTasksAfterShutdownPolicy() &#123; return executeExistingDelayedTasksAfterShutdown; &#125; public void setRemoveOnCancelPolicy(boolean value) &#123; removeOnCancel = value; &#125; public boolean getRemoveOnCancelPolicy() &#123; return removeOnCancel; &#125; public void shutdown() &#123; super.shutdown(); &#125; public List&lt;Runnable&gt; shutdownNow() &#123; return super.shutdownNow(); &#125; public BlockingQueue&lt;Runnable&gt; getQueue() &#123; return super.getQueue(); &#125; // 使用DelayedWorkQueue作为保存任务的阻塞队列 static class DelayedWorkQueue extends AbstractQueue&lt;Runnable&gt; implements BlockingQueue&lt;Runnable&gt; &#123; /* * DelayedWorkQueue使用堆作为数据结构。每个ScheduledFutureTask * 会保存其在堆中的下标，以加快搜索的时间复杂度 */ private static final int INITIAL_CAPACITY = 16; private RunnableScheduledFuture&lt;?&gt;[] queue = new RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY]; private final ReentrantLock lock = new ReentrantLock(); private int size = 0; /** * 采用了Leader-Follower的模式。当一个线程称为leader时，它只 * 等待下一个到期的任务，其他线程会永久等待。所以当leader从take() * 或poll()方法返回时，必须signal其他的线程，除非已经有其他线程 * 成为了临时的leader。 * &lt;p&gt; * 当有一个更早到期的任务到来时，leader会变得无效，并设置为null， * 一些等待的献策和国内会被唤醒，去重新选举leader。所以等待的线程 * 等待过程中必须准备好acquire或者lose领导权 */ private Thread leader = null; /** * Condition signalled when a newer task becomes available at the * head of the queue or a new thread may need to become leader. */ private final Condition available = lock.newCondition(); private void setIndex(RunnableScheduledFuture&lt;?&gt; f, int idx) &#123; if (f instanceof ScheduledFutureTask) ((ScheduledFutureTask) f).heapIndex = idx; &#125; /** * Bottom -&gt; Up * Call only when holding lock. */ private void siftUp(int k, RunnableScheduledFuture&lt;?&gt; key) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; RunnableScheduledFuture&lt;?&gt; e = queue[parent]; if (key.compareTo(e) &gt;= 0) break; queue[k] = e; setIndex(e, k); k = parent; &#125; queue[k] = key; setIndex(key, k); &#125; /** * Top -&gt; Down * Call only when holding lock */ private void siftDown(int k, RunnableScheduledFuture&lt;?&gt; key) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; RunnableScheduledFuture&lt;?&gt; c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo(c) &lt;= 0) break; queue[k] = c; setIndex(c, k); k = child; &#125; queue[k] = key; setIndex(key, k); &#125; /** * 扩容50% * Call only when holding lock. */ private void grow() &#123; int oldCapacity = queue.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // grow 50% if (newCapacity &lt; 0) // overflow newCapacity = Integer.MAX_VALUE; queue = Arrays.copyOf(queue, newCapacity); &#125; private int indexOf(Object x) &#123; if (x != null) &#123; if (x instanceof ScheduledFutureTask) &#123; int i = ((ScheduledFutureTask) x).heapIndex; // Sanity check; x could conceivably be a // ScheduledFutureTask from some other pool. if (i &gt;= 0 &amp;&amp; i &lt; size &amp;&amp; queue[i] == x) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (x.equals(queue[i])) return i; &#125; &#125; return -1; &#125; public boolean contains(Object x) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return indexOf(x) != -1; &#125; finally &#123; lock.unlock(); &#125; &#125; public boolean remove(Object x) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; int i = indexOf(x); if (i &lt; 0) return false; setIndex(queue[i], -1); int s = --size; RunnableScheduledFuture&lt;?&gt; replacement = queue[s]; queue[s] = null; if (s != i) &#123; siftDown(i, replacement); if (queue[i] == replacement) siftUp(i, replacement); &#125; return true; &#125; finally &#123; lock.unlock(); &#125; &#125; public int size() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return size; &#125; finally &#123; lock.unlock(); &#125; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public int remainingCapacity() &#123; return Integer.MAX_VALUE; &#125; public RunnableScheduledFuture&lt;?&gt; peek() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return queue[0]; &#125; finally &#123; lock.unlock(); &#125; &#125; public boolean offer(Runnable x) &#123; if (x == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;) x; final ReentrantLock lock = this.lock; lock.lock(); try &#123; int i = size; if (i &gt;= queue.length) grow(); size = i + 1; if (i == 0) &#123; queue[0] = e; setIndex(e, 0); &#125; else &#123; siftUp(i, e); &#125; if (queue[0] == e) &#123; leader = null; available.signal(); &#125; &#125; finally &#123; lock.unlock(); &#125; return true; &#125; public void put(Runnable e) &#123; offer(e); &#125; public boolean add(Runnable e) &#123; return offer(e); &#125; public boolean offer(Runnable e, long timeout, TimeUnit unit) &#123; return offer(e); &#125; /** * Call only when holding lock. */ private RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123; int s = --size; RunnableScheduledFuture&lt;?&gt; x = queue[s]; queue[s] = null; if (s != 0) siftDown(0, x); setIndex(f, -1); return f; &#125; public RunnableScheduledFuture&lt;?&gt; poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; RunnableScheduledFuture&lt;?&gt; first = queue[0]; if (first == null || first.getDelay(NANOSECONDS) &gt; 0) return null; else return finishPoll(first); &#125; finally &#123; lock.unlock(); &#125; &#125; public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (; ; ) &#123; RunnableScheduledFuture&lt;?&gt; first = queue[0]; if (first == null) available.await(); else &#123; long delay = first.getDelay(NANOSECONDS); if (delay &lt;= 0) return finishPoll(first); first = null; // don't retain ref while waiting if (leader != null) // 如果当前线程不是leader则等待 available.await(); else &#123; // 如果leader未被设置，就将当前线程设置为leader Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; available.awaitNanos(delay); &#125; finally &#123; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; if (leader == null &amp;&amp; queue[0] != null) available.signal(); lock.unlock(); &#125; &#125; public RunnableScheduledFuture&lt;?&gt; poll(long timeout, TimeUnit unit) throws InterruptedException &#123; long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (; ; ) &#123; RunnableScheduledFuture&lt;?&gt; first = queue[0]; if (first == null) &#123; if (nanos &lt;= 0) return null; else nanos = available.awaitNanos(nanos); &#125; else &#123; long delay = first.getDelay(NANOSECONDS); if (delay &lt;= 0) return finishPoll(first); if (nanos &lt;= 0) return null; first = null; // don't retain ref while waiting if (nanos &lt; delay || leader != null) nanos = available.awaitNanos(nanos); else &#123; Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; long timeLeft = available.awaitNanos(delay); nanos -= delay - timeLeft; &#125; finally &#123; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; if (leader == null &amp;&amp; queue[0] != null) available.signal(); lock.unlock(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] FutureTask]]></title>
    <url>%2F2019%2F07%2F13%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-FutureTask%2F</url>
    <content type="text"><![CDATA[FutureTask通过实现RunnableFuture接口包装了异步运算，并为异步运算提供了一附加功能(可以取消、可以返回结果等)。FutureTask的实现关系大概是这个样子的 RunnableRunnable接口中只有一个run方法，提供给Thread类用来启动线程，单纯的调用Runnable的run方法是无法再启动一个线程的，只有通过Thread类的start方法才可以 Future不管是通过显式创建一个Thread类，还是创建Runnable，都是调用Thread的start()方法来启动线程的。start方法是没有返回结果的，也就是说，我们只能run-and-forget，我们如果想要获得一个返回结果，或者知道线程是否完成了。而Future就可以提供这种能力(当然也有其他方法可以知道线程是否启动完成，但Future更适合来做这件事。源代码分析如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public interface Future&lt;V&gt; &#123; /** * 尝试取消任务，如果以下情况之一发生，则取消失败 * 1. 任务已经完成 * 2. 任务已经被取消 * 3. 其他原因 * * 如果取消"成功" * 1. 如果调用cancel时，任务还没开始，则任务永远不会被启动 * 2. 如果调用cancel时，任务已经开始，且mayInterruptIfRunning * 为true，则任务会被中断 * 3. 如果调用cancel时，任务已经开始，但mayInterruptIfRunning * 为false，则任务会正常完成 * * 当该方法返回后，在调用isDone方法会返回true * 当该方法返回true后，在调用isCancelled也会返回true */ boolean cancel(boolean mayInterruptIfRunning); /** * @return 如果任务正常完成前被取消了，则返回true */ boolean isCancelled(); /** * @return 如果任务完成了，就返回true。这里的“完成”指的不仅是正常完成， * 被取消或者抛出异常了，也算完成。 */ boolean isDone(); /** * 当任务完成后，返回结果。如果调用该方法时，任务还没有完成，则调用get方法 * 的线程会被阻塞。 * * @throws CancellationException 如果任务被取消 * @throws ExecutionException 如果任务在执行中抛出异常 * @throws InterruptedException 如果当前线程在等待结果返回时 * 被中断 */ V get() throws InterruptedException, ExecutionException; /** * 在给定的时间内等待结果返回，如果时间到的时还没有得到结果，就抛出 * TimeoutException并停止等待 * @throws CancellationException 如果任务被取消 * @throws ExecutionException 如果任务在执行中抛出异常 * @throws InterruptedException 如果当前线程在等待结果返回时被中断 * @throws TimeoutException 如果等待超时 */ V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 内存一致性： Actions taken by the asynchronous computation happen-before actions following the corresponding Future.get() in another thread task执行与计算，一定发生在Future.get()之前之前。 emmmm说实话不是很明白解释的对不对 RunnableFutureRunnableFuture同时继承了Runnable和Future接口，感觉只是作为一个标记接口而存在，并没有什么特殊能力 FutureTask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; /** * 使用state字段来记录task的状态，当task被创建时状态为NEW。 * * 可能的状态转换 如下： * NEW -&gt; COMPLETING -&gt; NORMAL * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL * NEW -&gt; CANCELLED * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED */ private volatile int state; private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; /** 封装了task任务 */ private Callable&lt;V&gt; callable; /** 调用get()时可能返回的结果会抛出的异常 */ private Object outcome; /** 运行task的线程 */ private volatile Thread runner; /** 等待线程栈顶 */ private volatile WaitNode waiters; /** * 对于完成的任务 返回结果 或者 抛出异常 * * @param s 状态值 */ @SuppressWarnings("unchecked") private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x); &#125; public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125; /** * 传入一个Runnable对象，任务完成调用get()方法时返回result * * @throws NullPointerException if the runnable is null */ public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable &#125; public boolean isCancelled() &#123; return state &gt;= CANCELLED; &#125; public boolean isDone() &#123; return state != NEW; &#125; /** * 如果task已经完成(正常完成，被取消，抛出异常)，则无法再次被取消 * * 如果task还没有开始，那么task被取消后将不会有运行机会 * * 如果task已经开始，但是没有完成，那么要根据mayyInterruptIfRunning * 判断下一个行为 * 1. 如果mayInterruptIfRunning为true，那么运行中的task可以被中断 * 2. 否则，运行中的任务将允许被执行完成 */ public boolean cancel(boolean mayInterruptIfRunning) &#123; /** * 如果task已经完成，则无法再次被取消，否则说明可以被取消 * task的状态全部都是通过CAS来修改的，这里是将state 从 * NEW —&gt; INTERRUPTING或者CANCELLED * INTERRUPTING是一个中间状态，说明任务允许被中断但是还 * 没有被中断 * * 如果状态设置失败(说明在此过程中任务已经完成)，那么依然无法被取消 */ if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try &#123; // 如果mayInterruptIfRunning为true，那么运行中的task可以被中断 if (mayInterruptIfRunning) &#123; try &#123; Thread t = runner; if (t != null) t.interrupt(); &#125; finally &#123; /** * 这里用到了putOrderInt方法实现，是一种懒加载的方式 * 简单来说就是让state的volatile失效，并不需要被其他 * 线程立即看到该状态的转换，只是一种优化手段。可以查看 * https://blog.csdn.net/ITer_ZC/article/details/40744485 */ UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); &#125; &#125; &#125; finally &#123; finishCompletion(); &#125; return true; &#125; /** * @throws CancellationException */ public V get() throws InterruptedException, ExecutionException &#123; int s = state; // 如果task没有运行完成，或者正在设置返回值时 // 那么当前线程阻塞直到task完成 if (s &lt;= COMPLETING) s = awaitDone(false, 0L); // 根据返回的状态决定返回结果，还是抛出异常 return report(s); &#125; /** * @throws CancellationException */ public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; if (unit == null) throw new NullPointerException(); int s = state; if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING) throw new TimeoutException(); return report(s); &#125; /** * 当task运行完成时(正常完成、抛出异常或取消)，会调用该方法。默认实现 * 为空，此类可以通过覆写该方法，做一些扩展 */ protected void done() &#123; &#125; protected void set(V v) &#123; // 先将状态从NEW设置为COMPLETING，避免并发访问 if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = v; UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state // 移除并唤醒等待线程 finishCompletion(); &#125; &#125; /** * 与set类似，只不过set是任务正常结束被调用，而该方法是当任务执行抛出异常时， * 需要调用该方法 */ protected void setException(Throwable t) &#123; // 先将状态从NEW设置为COMPLETING，避免并发访问 if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = t; UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state // 移除并唤醒等待线程 finishCompletion(); &#125; &#125; public void run() &#123; // 如果任务已经完成 或者 已经有线程运行该任务了 // 那么就不再运行 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; // 任务完成后，callable或被设置为null // 这里判断说明任务还未完成 if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // 必须等state被设置为非NEW后，runner才可以被设置为null // 以避免多个线程并发调用该方法 runner = null; // 查询任务是否被中断 int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; /** * 提供给ScheduledThreadPoolExecutor使用，运行任务并且不设置返回结果， * 并且运行成功不去更改state状态。 * * 只有在任务被cancel或者抛出异常了才会设置state状态，这样可以支持task * 运行多次 * * @return true-成功运行了task，并且状态保持在NEW */ protected boolean runAndReset() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return false; boolean ran = false; int s = state; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; s == NEW) &#123; try &#123; c.call(); // don't set result ran = true; &#125; catch (Throwable ex) &#123; setException(ex); &#125; &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; return ran &amp;&amp; s == NEW; &#125; private void handlePossibleCancellationInterrupt(int s) &#123; // It is possible for our interrupter to stall before getting a // chance to interrupt us. Let's spin-wait patiently. if (s == INTERRUPTING) while (state == INTERRUPTING) Thread.yield(); // wait out pending interrupt &#125; /** * 包装等待线程的类 */ static final class WaitNode &#123; volatile Thread thread; volatile WaitNode next; WaitNode() &#123; thread = Thread.currentThread(); &#125; &#125; /** * 移除并唤醒所有正在等待结果的线程，并且将callable对象设置为null, * 即task再也不会被运行 */ private void finishCompletion() &#123; // 这里有一个隐藏的保证， 即该方法被调用时 // state &gt; COMPLETING for (WaitNode q; (q = waiters) != null;) &#123; // waiter字段维护了等待队列的链表头，这里先将waiter设置为null // 即在外界看来等待队列已经被清理 if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123; // 这里通过循环真正清理并唤醒等待线程 for (;;) &#123; Thread t = q.thread; if (t != null) &#123; q.thread = null; LockSupport.unpark(t); &#125; WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; &#125; break; &#125; &#125; // 默认实现为空，子类可以做扩展 done(); callable = null; // to reduce footprint &#125; /** * 等待task完成(正常完成、被取消、中断或者超时) * * 大致的逻辑是轮询task状态: * 1. 如果任务已经完成, 那么就返回当前状态 * 2. 如果任务已经完成，但是正在设置返回结果，那么就将控制 * 权交出，先等待一段时间 * 3. 如果任务未完成，就将当前线程加入等待栈中 * 4. 如果已经任务未完成，且已经加入到了等待栈中并且设置了 * 超时，如果已经超时则返回当前状态，否则阻塞线程一段时间 * 5. 如果已经任务未完成，且已经加入到了等待栈中那么就阻塞 * * @param timed 如果会响应超时，则true * @param nanos 等待事件，如果timed为true才有用 */ private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123; final long deadline = timed ? System.nanoTime() + nanos : 0L; WaitNode q = null; boolean queued = false; for (;;) &#123; if (Thread.interrupted()) &#123; removeWaiter(q); throw new InterruptedException(); &#125; int s = state; if (s &gt; COMPLETING) &#123; // 如果任务已经完成 // 就将该线程从等待线程中移除 if (q != null) q.thread = null; return s; &#125; else if (s == COMPLETING) // 如果正在设置返回结果 Thread.yield(); else if (q == null) // 任务还在运行中，则将当前线程加入等待线程 q = new WaitNode(); else if (!queued) // 如果当前线程没有被加入等待栈，则将其入栈 queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); else if (timed) &#123; // 如果设置了超时时间，则需要判断是否超时 nanos = deadline - System.nanoTime(); // 如果已经超时，则将线程从等待队列中移除，并且 // 返回这时的状态 if (nanos &lt;= 0L) &#123; removeWaiter(q); return state; &#125; // 如果还没超时，则阻塞设置的超时时间 LockSupport.parkNanos(this, nanos); &#125; else // 阻塞当前线线程 LockSupport.park(this); &#125; &#125; /** * 移除一个超时或者被中断的等待线程，其实是移除 * 等待队列中所有获得结果的线程 */ private void removeWaiter(WaitNode node) &#123; if (node != null) &#123; node.thread = null; retry: for (;;) &#123; // restart on removeWaiter race for (WaitNode pred = null, q = waiters, s; q != null; q = s) &#123; s = q.next; if (q.thread != null) pred = q; else if (pred != null) &#123; // q.thread == null, 说明线程已经获得结果，可以被清理 pred.next = s; if (pred.thread == null) // 并发冲突，pred线程也可以被清理 continue retry; &#125; // 如果 栈顶 的等待结点已经获得结果，则重新设置栈顶 else if (!UNSAFE.compareAndSwapObject(this, waitersOffset, q, s)) continue retry; &#125; break; &#125; &#125; &#125; // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long stateOffset; private static final long runnerOffset; private static final long waitersOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = FutureTask.class; stateOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("state")); runnerOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("runner")); waitersOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("waiters")); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] ScheduledExecutorService]]></title>
    <url>%2F2019%2F07%2F08%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ScheduledExecutorService%2F</url>
    <content type="text"><![CDATA[在前面的文章中我们分析了ExecutorService，也说过它是对Executor的扩展，而这篇文章我们要讲的ScheduledExecutorService是对ExecutorService的扩展，通过名字我们也可以看出ScheduleExecutorService在ExecutorService的基础中提供了在一定延迟后或者定时进行任务调度的的功能(An ExecutorService that can schedule commands to run after a given delay, or to execute periodically)。 ScheduledExecutorService只是一个接口，还是非常简单的，我们直接从代码入手吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * ScheduledExecutorService也可以接受delay为0的调度，可以想象成Executor * 中的execute方法和ExecutorService中的submit方法。 * * 需要注意的，所有的schedule方法只接收 【相对时间】和 【时间段】作为参数， * 不接受绝对时间。如果想在某一特定时间运行，可以使用下面语句， * schedule(task,date.getTime()-System.currentTimeMillis(),TimeUnit.MILLISECONDS) * * 另外，当时间到达时，任务也可能没有运行，所以这个时间并不是完全精确地，不能 * 依赖时间的准确性编程 */public interface ScheduledExecutorService extends ExecutorService &#123;/*** 创建一个【一次性任务】，在给定的延迟时间到达后，执行该任务** @return ScheduledFuture对象可以表示任务的挂起和完成状态，任务未* 完成时调用ScheduledFuture的get()方法会返回null** @throws RejectedExecutionException 如果任务无法被调度运行* @throws NullPointerException 任务为null*/public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);/** * 创建一个【一次性任务】，在给定的延迟时间到达后，执行该任务 * * @throws RejectedExecutionException 如果任务无法被调度运行 * @throws NullPointerException 任务为null */public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);/** * 创建一个【周期性任务】，在initialDelay时间到达后，运行第一次，然后 * 每过period时间运行一次，即运行时间为: * * 第一次：now + initialDelay * 第二次: now + initialDelay + period * 第三次: now + initialDelay + 2 * period * ... * * 如果任务执行过程中遇到异常，那么后续的任务就不会执行了。否则，只有在任务 * 被取消或者线程池termination的情况下，任务才会终止。 * * 如果任务的运行时间超过了设置的period间隔，那么后续任务会晚一点运行， * 不会有两个任务并发运行的情况 * * @return ScheduledFuture对象可以表示任务的挂起和完成状态，任务被取消时 * 调用ScheduledFuture的get()方法会抛出异常 * * @throws RejectedExecutionException 如果任务无法被调度运行 * @throws NullPointerException 任务为null * @throws IllegalArgumentException period小于等于0 */public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);/** * scheduleAtFixedRate相对于开始时间，任务启动频率固定。 * * 而该方法是相对于上一次任务执行时间，启动频率固定。即运行时间为: * * 第一次：now + initialDelay * 第二次: 第一次任务完成时间 + delay * 第三次: 第二次任务完成时间 + delay * ... * * 如果任务执行过程中遇到异常，那么后续的任务就不会执行了。否则，只有在任务 * 被取消或者线程池termination的情况下，任务才会终止。 * * @return ScheduledFuture对象可以表示任务的挂起和完成状态，任务被取消时 * 调用ScheduledFuture的get()方法会抛出异常 * * @throws RejectedExecutionException 如果任务无法被调度运行 * @throws NullPointerException 任务为null * @throws IllegalArgumentException delay小于等于0 */public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay,long delay,TimeUnit unit);&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] ThreadPoolExecutor]]></title>
    <url>%2F2019%2F07%2F07%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[本文将要介绍Java线程池部分，最重要的类ThreadPoolExecutor。 在了解线程池是如何工作的之前。首先应该要了解，为什么要使用线程池，线程池与显式的创建一个线程有什么区别： 线程的创建与销毁是有代价的，是需要耗费时间的。通过线程池，可以管理一组线程，实现这些线程的复用。这样当请求到来时，就会减少上下文切换的时间，也可以避免因线程过多，资源不足的问题。 线程池统一管理一组线程，更好维护。可以将业务逻辑与资源分配解耦。 简单概括来说，线程池的作用就两点减少创建/销毁线程的消耗和统一管理。为了达到这个目的，Doug Lea大神为我们提供了许多参数去实现不同的线程池，我们可以先复习一下: CorePoolSize(核心线程数): 当线程池中的线程数小于corePoolSize时，每当有新任务被提交时，线程池总是倾向于创建一个新线程。 BlockingQueue(阻塞队列): 当线程池中的线程数已经等于corePoolSize时，如果提交新任务的时候，没有线程空闲，那么新提交的任务会被放入这个阻塞队列中。 MaximumPoolSize(最大线程数): 当BlockingQueue容量满了的情况下，线程池会创建新的临时线程，但是核心线程数加上这些临时线程的数量不会超过MaximumPoolSize。 ThreadFactory: 可以通过实现ThreadFactory自定义创建线程的逻辑，例如线程的名称，优先级，是否为守护线程等。不指定的情况下，会使用默认的defaultThreadFactory。 KeepAliveTimes和TimeUnit: 为线程设置存活时间，当线程数超过核心线程时，如果超过keepAliveTime还是idle(空闲)状态。那么就会被回收。如果将这个数字设置为Long.MAX_VALUE，并将TimeUnit设置为NANOSECONDS，线程就不会被回收。默认情况下，这个条件只对超过corePoolSize的临时线程有效，可以通过allowCoreThreadTimeOut(true)设置对核心线程有效，并且这个时候KeepAliveTime不应该为0。 RejectedExecutionHandler(拒绝策略): 当线程池已经关闭后，或者当线程数达到MaximumPoolSize，且使用的有界队列已满时。这时向线程池提交任务，线程池会拒绝接受，并通过RejectedExecutionHandler执行拒绝策略，主要有以下几种策略： AbortPolicy：handler会抛出运行时异常(runtime exception) RejectedExecutionException，并抛弃任务。该策略是默认策略 CallerRunsPolicy: 提交任务(调用execute方法)的线程自己去执行task，可以当做一种反馈机制，减缓线程提交速度。 DiscardPolicy: 简单地抛弃任务，不做其他任何事情。 DiscardOldestPolicy: 抛弃最早的任务，并且重试execute动作(可能存在连续失败，多次抛弃任务的情况) 上面的几个概念其实就是ThreadPoolExecutor构建函数中的几个参数 Doug Lea 给出了几种常用的策略，可以参考一下 Direct handoffs(直接提交): 请求到来时直接提交，而不交放入queue中保存。如果提交任务时，没有空闲线程，那么就创建一个新线程。可以使用SynchronizeQueue和无限MaximumPoolSize。需要注意的是，当线程提交速度大于处理速度时，线程数可能无限增长下去 Unbounded Queue(无界队列): 通常使用LinkedBlockingQueue，在这种情况下MaximumPoolSize参数就无效了，因为队列永远不会满。当每个任务完全独立于其他任务时，这种方法比较合适，任务不会影响彼此的执行。当请求数突然增加的时候，这种方法仍然可以保持较好的性能，但是与上面的策略相同，当任务提交的速度一直大于处理的速度时，线程可能无限增长下去。 Bounded Queue(有界队列): 通过设置有限的MaximumPoolSize可以控制有限的线程运行。 下面源码解析的前三个部分都是ThreadPoolExecutor的内部实现，并没有暴露给用户。如果不想看这些内部的实现原理，只想看公共API的解析，可以跳到最后一部分。 辅助字段接下来，我们就源码具体分析，先从一些辅助字段开始，了解了这些字段的含义，基本就了解了ThreadPoolExecutor的机制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 使用AtomicInteger 类型的对象 ctl 同时记录了两种状态 * 1. workerCount: 当前线程池中有效的线程数 * 2. runState: 线程池本身的状态，running，shutdown等 * * 这个字段的最高三位用来记录了runState，也就是说可以存储8种状态 * 剩下的低29位则用来记录有效的线程数量 */private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;/** * 上面说过的runState对应的值就是这些, 对应的二进制是ctl的最高三位 * * 这些状态是有序的，从低状态到高状态是允许的，但是反过来就是 * 禁止的，例如RUNNING可以变成STOP或者SHUTDOWN，但是TERMINATED * 不能再变回其他状态。可能的转换关系如下: * * 1. RUNNING -&gt; SHUTDOWN: 调用shutdown()方法。 * 2. (RUNNING or SHUTDOWN) -&gt; STOP: 调用 shutdownNow()方法。 * 3. SHUTDOWN -&gt; TIDYING: 队列和线程池任务都为空 * 4. STOP -&gt; TIDYING: 线程池任务为空 * 5. TIDYING -&gt; TERMINATED: terminated()方法执行完成 */ // 接收新任务并且处理队列中的任务，二进制为(111)private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;// 不接收新任务了，但是会处理队列中剩余的任务，二进制为(000)private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;// 不接收新任务，也不处理队列中的人物，并且会interrupt正// 在执行的任务，二进制为(001)private static final int STOP = 1 &lt;&lt; COUNT_BITS;// 所有任务已经终止，workerCount为零，线程转换到该状态将// 运行terminated()方法，二进制为(010)private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;// terminated()方法执行完成，二进制为(011)private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;// 返回线程池的运行状态private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY;&#125;// 返回有效线程数private static int workerCountOf(int c) &#123; return c &amp; CAPACITY;&#125;// 返回组合后的ctl，即rs为runState，wt为workerCount// 高3位与低29位取或，对应的就是ctl的值private static int ctlOf(int rs, int wc) &#123; return rs | wc;&#125;// 用来存储任务并移交给worker的阻塞队列private final BlockingQueue&lt;Runnable&gt; workQueue;private final ReentrantLock mainLock = new ReentrantLock();// 保存了所有的worker线程，只有持有了mainLock才可以访问private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();// 用来支持awaitTerminationprivate final Condition termination = mainLock.newCondition();// 用来保存达到过的最大线程数(和MaximumPoolSize不是一个意思)，// 只有持有了mainLock才可以访问private int largestPoolSize;// 记录完成过的task数量，只有当一个worker线程终结时才会更新，// 只有持有了mainLock才可以访问private long completedTaskCount;/* * 下面的变量都使用了volatile进行声明，而不用加锁，因为它们的 * 更新操作不依赖于当前值 */// 线程池中所有线程的创建都是通过这个实例创建的private volatile ThreadFactory threadFactory;private volatile RejectedExecutionHandler handler;private volatile long keepAliveTime;// 如果为false(默认), 核心线程即使空闲也不会被销毁。否则，// 当核心线程空闲超过keepAliveTime时也会被销毁private volatile boolean allowCoreThreadTimeOut;private volatile int corePoolSize;private volatile int maximumPoolSize;private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();// 检查线程是够有权限终止线程池，不是很懂~~~private static final RuntimePermission shutdownPerm = new RuntimePermission("modifyThread");private final AccessControlContext acc; 内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * ThreadPoolExecutor为每个worker线程维护了一个内部类。这个类使用了不可重入锁， * 以避免worker线程在调用setCorePoolSize等池控制方法时能够重新获取锁，否则可能 * 会中断当前线程 * * 另外，为了在线程实际开始运行任务之前禁止中断，将锁状态初始化为负值，并在启动 * 时清除它(在runWorker中)。 */private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; private static final long serialVersionUID = 6138294804551838833L; // worker线程，如果factory创建失败，则为null final Thread thread; // 初始化时运行的任务，可能为null Runnable firstTask; // 该线程完成的任务数 volatile long completedTasks; Worker(Runnable firstTask) &#123; setState(-1); // 任务运行前禁止被中断 this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; // 真正的run方法依赖于外部(ThreadPoolExecutor)的runWorker方法 public void run() &#123; runWorker(this); &#125; // 0 - unlocked状态 // 1 - locked状态 protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; // 尝试获取锁，如果已经锁定，则获取失败 protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; // 释放锁 protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; // 获取锁，直到获得成功才返回 public void lock() &#123; acquire(1); &#125; // 获取锁，并立即返回 public boolean tryLock() &#123; return tryAcquire(1); &#125; // 释放锁 public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; // 如果线程已经开始运行，且没有被中断 // 则中断该线程 void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125;&#125; 线程池状态控制下面是一些设置与控制状态的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163private static final boolean ONLY_ONE = true;// 转移到targetState，如果已经大于targetState了，就停留在该状态// 只用来跳转到STOP和SHUTDOWNprivate void advanceRunState(int targetState) &#123; for (; ; ) &#123; int c = ctl.get(); if (runStateAtLeast(c, targetState) || ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))) break; &#125;&#125;/** * 如果下列条件之一为真，则转移至TERMINATED状态 * 1. 当前状态为SHUTDOWN，且pool和queue都为空 * 2. 当前状态为STOP，且pool已经为空 * * 否则，如果满足了terminate条件，但是workerCount不为0，那就 * 先中断空闲的worker线程保证shutdown信号继续传播。 * * 如果有操作可能造成termination(减少worker个数，调用shutdown时 * 移除队列中的线程等)，那么该操作之后必须调用该方法 */final void tryTerminate() &#123; for (; ; ) &#123; int c = ctl.get(); // 1. 如果该线程仍在运行则直接返回 // 2. 如果已经是TERMINATED或TIDYING状态，说明有其他线程正在清理 // 则直接返回 // 3. 如果是SHUTDOWN状态 且 队列中仍然存在任务，则直接返回 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty())) return; // 到这里说明线程池满足可以terminate的条件，即上方1，2条 // 但仍有仍然有worker存在，那么就尝试中断一个线程就可以了 // 为什么只中断一个就可以了呢，因为每个工作线程都会调用 // runWorker方法，空闲线程会阻塞在getTask方法中，而中断 // 线程会抛出InterruptedException，且runWorker方法没有 // 捕获，则每中断一个空闲线程，就调用一次processWorkerExit // 在这个方法里，也调用了TryTerminate，所以只需中断一个就可以 if (workerCountOf(c) != 0) &#123; interruptIdleWorkers(ONLY_ONE); // ONLY_ONE = true return; &#125; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 将线程池状态设置为 TIDYING; 线程数设置为 0 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; // 默认情况下terminate方法是一个空实现 // 所以如果不去实现这个方法，TIDYING状态 // 和TERMINATED状态是相等的 terminated(); &#125; finally &#123; ctl.set(ctlOf(TERMINATED, 0)); // 唤醒所有在等待线程池terminate的线程 termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // 如果CAS失败，可能是因为有其他线程增加了worker线程的数量 // 或更改了线程池状态，则需要重新遍历 &#125;&#125;/** * 中断所有worker线程，包括正在运行的线程。想也不用想，这么粗暴的方法也 * 只有shutdownNow才能调用了。不过我们上文说过了，刚初始化的worker线程 * 状态设置为负值，也就是还没开始运行，这个是无法中断的。 */private void interruptWorkers() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; for (Worker w : workers) // 只能中断已经开始运行的线程 w.interruptIfStarted(); &#125; finally &#123; mainLock.unlock(); &#125;&#125;private void interruptIdleWorkers() &#123; interruptIdleWorkers(false);&#125;/** * @param onlyOne true: 最多中断一个空闲线程，只有tryTerminate方法才会传入 * true，目的是将线程池置为terminate状态，但是仍有 * worker在运行，所以只要中断一个空闲线程保证shutdown * 信号传播就好了 * * 中断任意线程可确保关闭后新到达的woker最终也将退出。为了保证最终终止，只需要 * 中断一个空闲worker就足够了, 但shutdown()会中断所有空闲worker，以便冗余worker * 立即退出，而不是等待拖延任务完成 */private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; for (Worker w : workers) &#123; Thread t = w.thread; if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; w.unlock(); &#125; &#125; if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125;&#125;final void reject(Runnable command) &#123; handler.rejectedExecution(command, this);&#125;// 提供给ScheduleThreadPoolExecutor使用，这里不用管void onShutdown() &#123;&#125;/** * 清空阻塞队列中所有未执行的任务，并添加到一个新的list中 * 这里调用了BlockingQueue的drainTo方法。因为该方法只会被 * shutdownNow调用，而且在调用之前，已经将线程池状态设置为 * STOP，不会接收新任务，所以使用drainTo方法也不会造成并发 * 问题(如LinkedBlockingQueue读写是两把锁，而drainTo只锁 * 定了读锁)。 * * 但是如果BlockingQueue使用了DelayQueue获取其他类似的 * Queue(poll方法或drainTo方法可能无法成功的移除某些元素) * 那么就要一个个遍历删除 */private List&lt;Runnable&gt; drainQueue() &#123; BlockingQueue&lt;Runnable&gt; q = workQueue; ArrayList&lt;Runnable&gt; taskList = new ArrayList&lt;Runnable&gt;(); q.drainTo(taskList); if (!q.isEmpty()) &#123; for (Runnable r : q.toArray(new Runnable[0])) &#123; if (q.remove(r)) taskList.add(r); &#125; &#125; return taskList;&#125; 线程池worker与队列控制下面是一些设置与控制工作线程和队列中任务的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318/** * @param firstTask 满足下面两个条件之一，firstTask不为null * 1. 当线程数不足核心线程数，或者 * 2. 当队列已满但线程数不足MaximumPoolSize */private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (; ; ) &#123; int c = ctl.get(); int rs = runStateOf(c); /** * 如果线程池已经被SHUTDOWN，并且 * 1. 线程池已经TIDYING或TERMINATED，或 * 2. 有线程提交了新任务，或 * 3. 任务队列为空 * * 那么就不在添加新的worker线程，直接返回false */ if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty())) return false; for (; ; ) &#123; int wc = workerCountOf(c); /** * 如果worker线程已经超过最大容量(2^29)-1 则直接返回false * * 否则，满足下面条件之一就返回false * 1. 要添加的线程为核心线程，worker线程数已经超过核心线数 * 2. 要添加的线程为非核心下城，worker线程数已经超过最大线程数 */ if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; /** * 运行到这里说明可以增加一个新线程, 如果添加成功则直接退出 * 外部循环，否则因为并发冲突则需要继续遍历 */ if (compareAndIncrementWorkerCount(c)) break retry; /** * 重新获取运行状态 * * 1. 如果与之前状态有变化，则需要重新判断是否可以添加新的Worker * 2. 否则，CAS失败的原因是因为有其他线程修改了Worker数量，只需要 * 重新遍历内部循环就可以了 */ c = ctl.get(); if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; // 通过ThreadFactory创建Thread有可能失败， // 失败会返回null if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); /** * 1. 如果线程是运行状态，或者 * 2. 线程被SHUTDOWN，要执行的为遗留任务 */ if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // 如果线程已经执行 throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // 如果成功添加了一个worker线程则启动 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (!workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125;private void addWorkerFailed(Worker w) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (w != null) workers.remove(w); decrementWorkerCount(); // 重新检查状态，防止因为此线程阻止 // terminate过程的情况 tryTerminate(); &#125; finally &#123; mainLock.unlock(); &#125;&#125;/** * 负责清除死去的worker。只能通过worker线程调用。该方法会从woker set去除掉这个 * woker。并根据completedAbrupptly的值决定是否补充新线程 * * 如果不设置completedAbrutly那么就说明已经在正常流程中已经处理过正确的线程数量。 * * @param completedAbruptly 如果是因为异常而退出则为true */private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; // 如果是因为异常而退出，需要手动设置线程数 if (completedAbruptly) decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; completedTaskCount += w.completedTasks; workers.remove(w); &#125; finally &#123; mainLock.unlock(); &#125; // 判断状态，防止因为此线程导致的不可terminate tryTerminate(); int c = ctl.get(); // 如果当前状态为RUNNING或者SHUTDOWN if (runStateLessThan(c, STOP)) &#123; // 如果不是因为异常而退出 if (!completedAbruptly) &#123; int min = allowCoreThreadTimeOut ? 0 : corePoolSize; // 如果阻塞队列中有任务未被执行，则至少该有一个线程负责执行任务 if (min == 0 &amp;&amp; !workQueue.isEmpty()) min = 1; // 如果当前线程数大于所需线程数，则不需要补充线程 if (workerCountOf(c) &gt;= min) return; &#125; // 运行到这里说明因为异常而退出，或者当前线程数不足 // 所需要的线程数，则应该补充一个线程 addWorker(null, false); &#125;&#125;/** * 等待阻塞队列中的任务，如果设置允许空闲线程被销毁，会判断是否有空闲线程可以被 * 销毁。如果因为以下原因之一，线程必须被销毁，会返回null * 1. 存在多于maximumPoolSize的线程数(可能调用了setMaximumPoolSize方法) * 2. 线程池被STOP(可能调用了shutdownNow) * 3. 线程池被SHUTDOWN且队列为空 * 4. 该线程空闲超过keepAliveTime时间 */private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (; ; ) &#123; int c = ctl.get(); int rs = runStateOf(c); /** * 如果满足下列条件之一，那么说明没有任务存在 * * 1. 如果线程池已经(STOP, TIDYING或TERMINATED) * 2. 线程池被SHUTDOWN且队列中没有未执行的任务了 */ if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // 如果核心线程空闲一定时间可以被销毁，或者当前线程大于核心线程数 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; /** * 满足以下条件之一，可以销毁该线程，且说明没有任务要执行 * * 1. 当前线程数大于maximumPoolSize，且当前线程数大于1 * 2. 当前线程数大于maximumPoolSize，且队列中没有未执行的任务 * 3. 允许销毁空闲线程，且超过允许空闲时间，且当前线程数大于1 * 4. 允许销毁空闲线程，且超过允许空闲时间，且队列中没有未执行任务 */ if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; // 获取阻塞队列中的任务，如果允许销毁空闲线程，则使用keepAliveTime Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; // 存在空闲线程 timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; /** * ThreadPoolExecutor中最核心的方法，循环着从队列中取出任务并执行 */final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; // 不要忘记，我们一开始初始化worker的时候，将其状态设置为-1 // 防止任务未开始就被中断，这里调用unlock，则是允许其被中断 w.unlock(); boolean completedAbruptly = true; try &#123; // 如果是新提交的任务，或者队列中有任务需要运行 while (task != null || (task = getTask()) != null) &#123; /** * 任务执行前需要获取锁，这样可以保证除非调用了 * shutdownNow方法否则已经运行的下次讷航不会被中断 */ w.lock(); /** * 如果线程池已经停止，要将worker线程中断； * 如果未被停止，那么要确保woker线程没有被中断； * * 两次检查的目的是为了防止shutdownNow被调用 */ if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; /** * 可以自己实现任务执行前要执行的操作，默认为 * 空实现需要注意该方法可能抛出异常，直接退出 * 循环，导致任务没有被执行 */ beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; /** * 可以自己实现任务完成后要执行 * 的操作，默认为空实现需要注意 * 该方法可能抛出异常，直接退出 * 循环 */ afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; // 任务执行完成，如果此时销毁worker线程，不是因为异常 completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; 公共API(public 方法)ThreadPoolExecutor的构造方法很简单，只需要了解本文开头所列出的几个概念就可以了解，这里不再赘述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); // 如果当前线程数小于核心线程，那么创建一个新线程 // 并让其直接执行提交的任务 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; // worker添加失败，可能是因为线程池状态改变，或者 // 已经达到了核心线程数 c = ctl.get(); &#125; // 如果线程池仍在运行，且任务加入队列成功 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 重新检查状态 int recheck = ctl.get(); // 如果线程池不在运行了并且移除任务成功，则调用拒绝策略 if (!isRunning(recheck) &amp;&amp; remove(command)) reject(command); /** * 运行到这里说明线程池仍在运行 * 如果当前线程数为0，就新建一个线程 */ else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) /** * 运行到这里说明线程池已经不在运行，或者任务无法加 * 入队列(队列已满)且超过MaximumPoolSize，那么就调 * 用拒绝策略 */ reject(command);&#125;public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); // 将状态设置为SHUTDOWN advanceRunState(SHUTDOWN); // 中断所有空闲线程 interruptIdleWorkers(); // 留给ScheduledThreadPoolExecutor // 这里不需要了解 onShutdown(); &#125; finally &#123; mainLock.unlock(); &#125; // 尝试将线程池状态设置为terminate tryTerminate();&#125;/** * 停止所有正在运行的任务，取消等待运行的任务，并返回等待运行的任务list */public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); // 将线程池状态设置为STOP advanceRunState(STOP); // 中断所有线程 interruptWorkers(); // 移除所有阻塞队列中的任务并返回 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; // 将线程池状态设置为TERMINATE tryTerminate(); return tasks;&#125;// 如果在给定时间内线程池已经TERMINAED则返回truepublic boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException &#123; long nanos = unit.toNanos(timeout); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; for (; ; ) &#123; if (runStateAtLeast(ctl.get(), TERMINATED)) return true; if (nanos &lt;= 0) return false; nanos = termination.awaitNanos(nanos); &#125; &#125; finally &#123; mainLock.unlock(); &#125;&#125;public void setCorePoolSize(int corePoolSize) &#123; if (corePoolSize &lt; 0) throw new IllegalArgumentException(); int delta = corePoolSize - this.corePoolSize; this.corePoolSize = corePoolSize; // 如果线程数多于要设置的核心线程，则清楚多余线程 if (workerCountOf(ctl.get()) &gt; corePoolSize) interruptIdleWorkers(); // 如果新核心线程数大于原先的核心线程数 else if (delta &gt; 0) &#123; // 取新核心线程数和队列中等待运行任务的最小值 int k = Math.min(delta, workQueue.size()); while (k-- &gt; 0 &amp;&amp; addWorker(null, true)) &#123; if (workQueue.isEmpty()) break; &#125; &#125;&#125; // 清除队列中被取消的任务，没什么卵用，被取消的任务永远也不会执行，// 节省空间时间吧public void purge() &#123; final BlockingQueue&lt;Runnable&gt; q = workQueue; try &#123; Iterator&lt;Runnable&gt; it = q.iterator(); while (it.hasNext()) &#123; Runnable r = it.next(); if (r instanceof Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;) r).isCancelled()) it.remove(); &#125; &#125; catch (ConcurrentModificationException fallThrough) &#123; // 如果删除的同时也有其他线程在删除，就换一种方法删除。。。 for (Object r : q.toArray()) if (r instanceof Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;) r).isCancelled()) q.remove(r); &#125; tryTerminate(); // In case SHUTDOWN and now empty&#125;public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123;&#125; // 如果线程池没被shutdown，就由提交任务的线程来执行被拒绝的任务 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125; public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123;&#125; // 总是抛出 RejectedExecutionException 然后啥也不干 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException("Task " + r.toString() + " rejected from " +e.toString()); &#125;&#125; public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123;&#125; // 这个是真的啥也不干。。 public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;&#125;&#125; /** * A handler for rejected tasks that discards the oldest unhandled * request and then retries &#123;@code execute&#125;, unless the executor * is shut down, in which case the task is discarded. */public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123;&#125; /** * 如果线程池没有shutdown，就抛弃队列中最老的任务，然后重新 * 执行提交的任务，很可能会连续多次被拒绝 */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] AbstractExecutorService]]></title>
    <url>%2F2019%2F07%2F06%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-AbstractExecutorService%2F</url>
    <content type="text"><![CDATA[上次两篇文章对Executor和ExecutorService接口进行了介绍，这篇文章将主要介绍下它们的默认实现。 JDK中大部分”服务”是以接口暴露给外界的，接口中包含了对应需要对外暴露的方法。然后由一个抽象类实现这个接口，并提供了一些共用的默认实现，而一些“特性”则由实现类独自完成。这是符合设计模式中的开闭原则和依赖倒置原则的，我们编程的时候，也应该学习这种面向接口编程的思想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public abstract class AbstractExecutorService implements ExecutorService &#123; /** * 这里可以先不用管FutureTask和RunnableFuture的细节，只需要知道 * FutureTask封装了一个内部的Callable对象，FutureTask提供了get方法， * 可以获得运行后返回的结果。 * * @return 这个方法中，会把传入的value作为返回值返回。 */ protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value); &#125; protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable); &#125; /** * @throws RejectedExecutionException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; * * @return 该方法会返回null */ public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); // 上篇文章说过ExecutorService实现了 // Executor接口所以实现了ExecutorService // 的类，也实现了Executor接口, 抽象类中 // 并没有实现这个接口，所以具体的实现细节 // 要由每个实现类去完成。 return ftask; &#125; /** * @throws RejectedExecutionException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; * * @return 该方法会返回给定的result */ public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); execute(ftask); return ftask; &#125; /** * @throws RejectedExecutionException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */ public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask; &#125; public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException &#123; try &#123; return doInvokeAny(tasks, false, 0); &#125; catch (TimeoutException cannotHappen) &#123; assert false; return null; &#125; &#125; public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; return doInvokeAny(tasks, true, unit.toNanos(timeout)); &#125; /** * the main mechanics of invokeAny. */ private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, boolean timed, long nanos) throws InterruptedException, ExecutionException, TimeoutException &#123; if (tasks == null) throw new NullPointerException(); int ntasks = tasks.size(); if (ntasks == 0) throw new IllegalArgumentException(); ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(ntasks); ExecutorCompletionService&lt;T&gt; ecs = new ExecutorCompletionService&lt;T&gt;(this); try &#123; ExecutionException ee = null; final long deadline = timed ? System.nanoTime() + nanos : 0L; Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator(); futures.add(ecs.submit(it.next())); // 先启动一个任务，方便下面判断 --ntasks; int active = 1; // 记录当前正在运行的任务数量 for (;;) &#123; Future&lt;T&gt; f = ecs.poll(); // 为了提提高效率，每次提交一个任务时， // 都会检查是否有任务已经完成 if (f == null) &#123; // 如果没有任务完成 if (ntasks &gt; 0) &#123; // 1. 如果仍有任务没有运行，就去执行 --ntasks; futures.add(ecs.submit(it.next())); ++active; &#125; else if (active == 0) // 2. 到这里说明任务都提交完了 // 如果没有任务正在执行了，就退出 // 循环 break; else if (timed) &#123; // 3. 运行这个条件说明，任务都提交完成 // 但是还有任务在执行，如果有采用了超时 // 模式，那么就会判断是否超时 f = ecs.poll(nanos, TimeUnit.NANOSECONDS); if (f == null) throw new TimeoutException(); nanos = deadline - System.nanoTime(); &#125; else // 4. 运行到这里说明所有任务都提交完成了，仍有任务正在 // 执行，并且不支持超时模式，那么就阻塞在这，直到有任务 // 完成再返回 f = ecs.take(); &#125; if (f != null) &#123; --active; // 因为get请求有可能失败，所以这里要减去 // 以方便下一次处理 try &#123; return f.get(); // 如果有任务已经完成了，直接返回任务就好了 &#125; catch (ExecutionException eex) &#123; ee = eex; &#125; catch (RuntimeException rex) &#123; ee = new ExecutionException(rex); &#125; &#125; &#125; if (ee == null) ee = new ExecutionException(); throw ee; &#125; finally &#123; // 取消其他任务 for (int i = 0, size = futures.size(); i &lt; size; i++) futures.get(i).cancel(true); &#125; &#125; public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException &#123; if (tasks == null) throw new NullPointerException(); ArrayList&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size()); boolean done = false; try &#123; for (Callable&lt;T&gt; t : tasks) &#123; RunnableFuture&lt;T&gt; f = newTaskFor(t); futures.add(f); execute(f); &#125; for (int i = 0, size = futures.size(); i &lt; size; i++) &#123; Future&lt;T&gt; f = futures.get(i); if (!f.isDone()) &#123; try &#123; f.get(); // 阻塞一直等到计算完成返回结果为止 &#125; catch (CancellationException ignore) &#123; &#125; catch (ExecutionException ignore) &#123; &#125; &#125; &#125; done = true; return futures; &#125; finally &#123; if (!done) for (int i = 0, size = futures.size(); i &lt; size; i++) futures.get(i).cancel(true); &#125; &#125;&#125; AbstractExecutorService只是对ExecutorService最简单的实现，核心的execute方法，还是需要实现类自己实现。]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] ExecutorService]]></title>
    <url>%2F2019%2F07%2F04%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-ExecutorService%2F</url>
    <content type="text"><![CDATA[上一篇文章我们讲到了Executor接口，ExecutorService继承了Executor接口，也就是说所有ExecutorService的实现类，也要实现Executor接口。ExecutorService可以说是对Executor的扩展。这个扩展提供管理和终止Executor的方法，还提供了返回Future的方法，对结果进行追踪。 下面代码中提到的 线程完成(completed)字样(除invokeAny中特殊标出的)，指的是线程正常退出或者抛出异常时，都可以被叫做”完成”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public interface ExecutorService extends Executor &#123; /** * 这个方法可以使线程池停止接收任务，这个方法比较优雅，因为是有序的， * 在这个方法执行前，提交的任务将会被执行，但是之后的新任务将不会再被接收。 * 如果线程池早就已经关闭，在调用该方法，不会有影响 * * 但是需要注意，该方法不会等待之前提交的任务执行完成。想要完成类似地目的， * 可以使用awaitTermination * * @throws SecurityException 如果caller没有权限终止线程 */ void shutdown(); /** * 强制停止所有执行中的任务，挂起所有正在等待执行的任务，并且返回所有正在 * 等待执行的任务的list * * 但是需要注意，该方法不会等待之前提交的任务执行完成。想要完成类似地目的， * 可以使用awaitTermination * * 并不能保证一定会停止正在执行的任务！因为调用的是Thread.interrupt方法 * * @return 返回所有正在等待执行的任务的list * @throws SecurityException 如果caller没有权限终止线程 */ List&lt;Runnable&gt; shutdownNow(); /** * @return 如果线程池已经被关闭返回true */ boolean isShutdown(); /** * @return 当线程池已经被关闭的情况下，如果所有任务都执行完成则返回true。 * 注意前提条件是线程池已经关闭，所以只有在shutdown或者shutdownNow * 先被调用的情况下，该方法才可能返回true */ boolean isTerminated(); /** * 当调用shutdown后，调用该方法时会阻塞，直到下列情况之一发生： * 1. 所有任务执行完成 * 2. 或者当前线程被中断 * 3. 或者超时 * * @return 如果所有任务完成后，则返回true；如果超时，则返回false * * @throws InterruptedException 当前线程被中断 */ boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; /** * 该方法与execute类似，不过提供了Future类型作为返回值，调用者可以 * 根据需要得到返回结果。 * * 可以看到这里的参数是Callable，而不是Runnable。一般情况下使用的 * Callable实现类是Executors中的RunnableAdapter，它只是一个内部类， * 包含了一个类型为Runnable的字段，还有一个result字段保存返回结果， * 具体内容可以去Executors中查看。 * * @throws RejectedExecutionException 如果任务不能被接收，如使用了 * AbortPolicy * * @throws NullPointerException 如果task为null */ &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); /** * 提交一个task，并且执行完成后返回一个Future。如果执行成功调用Future * 的get方法，会返回给定的result * * @throws RejectedExecutionException 如果任务不能被接收，如使用了 * AbortPolicy * * @throws NullPointerException 如果task为null */ &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); /** * 提交一个task，并且执行完成后返回一个Future。如果执行成功调用Future * 的get方法，会返回null * * @throws RejectedExecutionException 如果任务不能被接收，如使用了 * AbortPolicy * * @throws NullPointerException 如果task为null */ Future&lt;?&gt; submit(Runnable task); /** * 可以看成是批量提交一批任务，然后去执行这些任务。并返回一个Future * 的List，对应这些任务的返回结果 * * 当所有任务都执行完成(包括正常中断，或者抛出异常)的时候才会返回 * * 如果在任务执行的过程中，对参数进行了修改，那么返回的结果可能是 * 未定义(undefined)的。 * * @return 返回结果的顺序与提交时候的顺序是相等的。 * * @throws InterruptedException 等待过程中，有线程被中断 * @throws NullPointerException 参数列表中存在为null的任务 * @throws RejectedExecutionException 如果任务不能被接收，如使用了 * AbortPolicy */ &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; /** * 与上面方法类似，多了一个超时机制 * * 当所有任务都执行完成(包括正常中断，或者抛出异常)的时候，或者超时的时候 * 才会返回 * * 当时间到达时，如果有任务仍未完成，没完成的任务将会被取消。 * * @throws InterruptedException 等待过程中，线程被中断 * @throws NullPointerException 参数列表中存在为null的任务 * @throws RejectedExecutionException 如果任务不能被接收，如使用了 * AbortPolicy */ &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; /** * 通过名称我们就可以看出来，与invokeAll一样都是批量提交一批任务， * 但是会返回 【任意一个】【正常】执行完成(即正常退出，而不是抛出异常) * 的任务的结果。 * * 当有任意一个任务完成时，其他任务将会被取消(cancelled) * * @throws InterruptedException 等待过程中，线程被中断 * @throws NullPointerException 参数列表中存在为null的任务 * @throws RejectedExecutionException 如果任务不能被接收，如使用了 * AbortPolicy * * @throws IllegalArgumentException 提交的tasks是Empty的Collection * @throws ExecutionException 没有任务正常完成 */ &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; /** * 与上面方法类似，只不过是在给定timeout时间之前，有任意一个任务正常执行 * 完成(正常退出，不抛出异常)，会返回这个任务，其他任务会被取消(cancelled) * * @throws InterruptedException 等待过程中，线程被中断 * @throws NullPointerException 参数列表中存在为null的任务 * @throws RejectedExecutionException 如果任务不能被接收，如使用了 * AbortPolicy * * @throws ExecutionException 没有任务正常完成 * @throws TimeoutException 给定时间到达时，仍未有任务正常执行完成 */ &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 通过上面的代码，可以看出ExecutorService对Executor的扩展主要体现在以下几个方面： 允许关闭线程池，并对线程池状态进行追踪 当线程池关闭时，可以对其中的任务状态进行追踪 submit方法对execute进行了扩展，可以得到想要的返回结果 提供了批量提交一批任务到线程池的功能 内存一致性： Actions in a thread prior to the submission of a Runnable or Callable task to an ExecutorService happen-before any actions taken by that task, which in turn happen-before the result is retrieved via Future.get(). 一个线程提交Runnable或Callable至ExecutorService之前所发生的的动作，一定发生在这个Runnable或Callable本身执行之前。这两个动作一定发生在Future.get()返回结果之前。 emmmm说实话不是很明白解释的对不对]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] Executor]]></title>
    <url>%2F2019%2F07%2F04%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Executor%2F</url>
    <content type="text"><![CDATA[这是JDK源码系列的第一篇文章，想先从并发包开始讲起。这一系列的文章只是用来记录学习的过程，可能有很多错误的理解。 在Java源码中，并发包的路径为java-&gt;util-&gt;concurrent，我认为主要可以分为5个部分： 线程池部分。 使用CAS实现的各种原子类型。 使用AQS作为底层实现的各种并发工具类，包括lock, countDownLatch, cylicBarrier等。 阻塞队列，这些队列会配合线程池一起使用。 还有一些其他零散的类。 这篇文章先从使用最广泛的线程池开始说起吧，可以先看一下下面的类关系图 先介绍一下这些类/接口最主要的作用是什么，然后在从每一个类的源码着手分析。 最顶层的Executor是一个接口，接口中只有一个方法。 1234567891011/** * 提交的任务(command)会在未来的某一时刻运行。这个command可能会运行在新的线程中 * 可能运行在线程池中，也可能会在提交任务的线程中。取决于具体实现，从这可以看出 * Doug Lea大神的解耦思想。 * * @param command the runnable task * @throws RejectedExecutionException 任务不能被执行。例如采用了AbortPolicy 的线程池抛弃任务时，就会抛出该异常 * @throws NullPointerException command为空会抛出NPE */void execute(Runnable command); 通过此方法可以代替手动创建线程1new Thread(new(RunnableTask())).start(); Doug Lea 大神在文档中解释说，这个接口的作用是用来将 任务提交 与 任务运行(运行细节，调度等) 解耦。 Executor是基于生产者-消费者模式的，提交的过程就是生产者，任务的执行就是消费者。通过参数的命名也能看出来，这是符合设计模式-命令模式的。 JDK源码中实现Executor的类同样都实现了ExecutorService接口(见下文解释)。 内存一致性： Actions in a thread prior to submitting a Runnable object to an Executor happen-before its execution begins, perhaps in another thread. 一个线程在提交Runnable至Executor之前的动作，一定发生在这个 Runnable本身执行之前。 emmmm说实话不是很明白解释的对不对]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JDK源码解析] 目录]]></title>
    <url>%2F2019%2F07%2F04%2FJDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[目录 java util concurrent atomic locks AbstractOwnableSynchronizer AbstractQueuedLongSynchronizer AbstractQueuedSynchronizer Condition Lock LockSupport ReadWriteLock ReentrantLock ReentrantReadWriteLock StampedLockCompletableFuture AbstractExecutorService ArrayBlockingQueue BlockingDeque BlockingQueue BrokenBarrierException Callable CancellationException CompletableFuture CompletionException CompletionService CompletionStage ConcurrentHashMap ConcurrentLinkedDeque ConcurrentLinkedQueue ConcurrentMap ConcurrentNavigableMap ConcurrentSkipListMap ConcurrentSkipListSet CopyOnWriteArrayList CopyOnWriteArraySet CountDownLatch CountedCompleter CyclicBarrier DelayQueue Delayed Exchanger ExecutionException Executor ExecutorCompletionService Executors ExecutorService ForkJoinPool ForkJoinTask ForkJoinWorkerThread Future FutureTask LinkedBlockingDeque LinkedBlockingQueue LinkedTransferQueue Phaser PriorityBlockingQueue RecursiveAction RecursiveTask RejectedExecutionException RejectedExecutionHandler RunnableFuture RunnableScheduledFuture ScheduledExecutorService ScheduledFuture ScheduledThreadPoolExecutor Semaphore ThreadFactory SynchronousQueue ThreadLocalRandom ThreadPoolExecutor TimeoutException TimeUnit TransferQueue]]></content>
      <categories>
        <category>JDK源码解析</category>
      </categories>
      <tags>
        <tag>JDK源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 16.门面模式]]></title>
    <url>%2F2019%2F04%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-16-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Provide a unified interface to a set of interfaces in a subsystem.Facade defines a higher-level interface that makes the subsystem easier to use.(要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。 门面模式提供一个高层次的接口， 使得子系统更易于使用)。 再简单地说， 门面对象是外界访问子系统内部的唯一通道。 门面模式角色： Facade门面角色： 客户端可以调用这个角色的方法。 此角色知晓子系统的所有功能和责任。 subsystem子系统角色： 可以同时有一个或者多个子系统。 每一个子系统都不是一个单独的类， 而是一个类的集合。 子系统并不知道门面的存在。 对于子系统而言， 门面仅仅是另外一个客户端而已。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 子系统，这3个类属于近邻， 处理相关的业务， * 因此应该被认为是一个子系统的不同逻辑处理模块， * 对于此子系统的访问需要通过门面进行 */public class ClassA &#123; public void doSomethingA() &#123; // 业务逻辑 &#125;&#125;public class ClassB &#123; public void doSomethingB() &#123; //业务逻辑 &#125;&#125;public class ClassC &#123; public void doSomethingC() &#123; //业务逻辑 &#125;&#125;/** * 门面对象 */public class Facade &#123; // 被委托的对象 private ClassA a = new ClassA(); private ClassB b = new ClassB(); private ClassC c = new ClassC(); // 提供给外部访问的方法 public void methodA() &#123; this.a.doSomethingA(); &#125; public void methodB() &#123; this.b.doSomethingB(); &#125; public void methodC() &#123; this.c.doSomethingC(); &#125;&#125; 门面模式的优点 减少系统的相互依赖：所有的以来都是对门面对象的依赖，而与子系统无关。 提高安全性 门面模式的缺点违反开闭原则 门面模式的使用场景 为一个复杂的模块或子系统提供一个供外界访问的接口 子系统相对独立——外界对子系统的访问只要黑箱操作即可。比如利息的计算问题， 没有深厚的业务知识和扎实的技术水平是不可能开发出该子系统的， 但是对于使用该系统的开发人员来说， 他需要做的就是输入金额以及存期， 其他的都不用关心， 返回的结果就是利息， 这时候， 门面模式是非使用不可了。 预防低水平人员带来的风险扩散比如一个低水平的技术人员参与项目开发， 为降低个人代码质量对整体项目的影响风险， 一般的做法是“画地为牢”， 只能在指定的子系统中开发， 然后再提供门面接口进行访问操作。 注意事项 门面不参与子系统内部的业务逻辑，子系统的设计不应该依赖于门面。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 15.观察者模式]]></title>
    <url>%2F2019%2F04%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-15-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.(定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新)。 观察者模式的角色： Subject被观察者 管理观察者(动态地增加或者删除)，并通知观察者 Observer观察者 观察者接收到消息后，进行update，对接收到的信息进行处理 ConcreteSubject具体的被观察者 定义被观察者自己的业务逻辑，同事定义对哪些事件进行通知。 ConcreteObserver具体观察者 每个观察者接收到消息后自己的逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 被观察者 */ public abstract class Subject &#123; // 定义一个观察者数组 private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;(); // 增加一个观察者 public void addObserver(Observer o) &#123; this.obsVector.add(o); &#125; // 删除一个观察者 public void delObserver(Observer o) &#123; this.obsVector.remove(o); &#125; // 通知所有观察者 public void notifyObservers() &#123; for(Observer o:this.obsVector )&#123; o.update(); &#125; &#125;&#125;/** * 具体被观察者 */public class ConcreteSubject extends Subject &#123; // 具体的业务 public void doSomething() &#123; /* * do something */ super.notifyObservers(); &#125;&#125;/** * 观察者 */public interface Observer &#123; // 更新方法 public void update();&#125; /** * 具体观察者 */public class ConcreteObserver implements Observer &#123; // 实现更新方法 public void update() &#123; System.out.println("接收到信息， 并进行处理！ "); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; // 创建一个被观察者 ConcreteSubject subject = new ConcreteSubject(); // 定义一个观察者 Observer obs= new ConcreteObserver(); // 观察者观察被观察者 subject.addObserver(obs); // 观察者开始活动了 subject.doSomething(); &#125;&#125; 观察者模式的优点 观察者和被观察者之间是抽象耦合 建立一套触发机制 观察者模式的缺点多级触发机制较复杂，要防止广播链的存在。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 14.适配器模式]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-14-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Convert the interface of a class into another interfaces clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.(将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作)。 适配器模式的三个角色： Target目标角色：期望接口 Adaptee源角色：想把谁转换成目标角色 Adapter适配器角色：把源角色转换成为目标角色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 目标角色 */public interface Target &#123; // 目标角色有自己的方法 public void request();&#125;/** * 目标角色的实现类 */public class ConcreteTarget implements Target &#123; @Override public void request() &#123; // 业务逻辑 &#125;&#125;/** * 源角色 */public class Adaptee &#123; // 原有的业务逻辑 public void doSomething() &#123; // 业务逻辑 &#125;&#125;/** * 适配器角色 */public class Adapter extends Adaptee implements Target &#123; public void request() &#123; super.doSomething(); &#125;&#125;/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; // 原有业务逻辑 Target target = new ConcreteTarget(); target.request(); // 增加了适配器角色后的业务逻辑 Target target2 = new Adapter(); target2.request(); &#125;&#125; 适配器的优点 可以让两个没有任何关系的类在一起运行。 增加了类的透明性。 提高了源角色的复用度。 灵活性比较好。 使用场景系统扩展，需要使用一个已有或者新建立的类，但这个类不符合系统的接口。 注意事项不要再设计阶段考虑这种设计模式，它是为了扩展应用而存在的。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 13.策略模式]]></title>
    <url>%2F2019%2F04%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-13-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Define a family of algorithms, encapsulate each one, and make them interchangeable.(定义一组算法，将每个算法都封装起来，并且使他们之间可以互换)。 策略模式的三个角色： Context封装角色：也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 Strategy抽象策略角色：通常为接口，定义每个策略或算法必须具有的方法和属性。 ConcreteStrategy具体策略角色：实现抽象策略中的操作。 策略模式的重点是封装角色，借用了代理模式的思路。它与代理模式不同的是，策略模式的封装角色和被封装的策略无需是同一个接口。 123456789101112131415161718192021222324252627282930313233343536373839/** * 抽象的策略角色 */public interface Strategy &#123; // 策略模式的运算法则 public void doSomething();&#125;/** * 具体策略角色 */public class ConcreteStrategy1 implements Strategy &#123; public void doSomething() &#123; System.out.println("具体策略1的运算法则"); &#125;&#125;public class ConcreteStrategy2 implements Strategy &#123; public void doSomething() &#123; System.out.println("具体策略2的运算法则"); &#125;&#125;/** * 封装角色 */public class Context &#123; // 抽象策略 private Strategy strategy = null; // 构造函数设置具体策略 public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; // 封装后的策略方法 public void doAnything() &#123; this.strategy.doSomething(); &#125;&#125; 策略模式的优点 算法可以自由切换 避免使用多重条件判断 扩展性良好 策略模式的缺点 策略类数量增多：每一个策略都是一个类，可复用性比较小 所有策略类都需要对外暴露 策略模式使用场景 多各类只有在算法或行为上有所不同 算法需要自由切换 需要屏蔽算法规则，只需要传递一个名字或数字就可以选择相应算法 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 12.命令模式]]></title>
    <url>%2F2019%2F04%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-12-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.(将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能)。 在该类图中，有三个角色： Receiver接收者角色： 命令传递到这里会被执行 Command命令角色： 需要执行的所有命令都在这里声明。 Invoker调用者角色： 接收到命令，并执行命令。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 调用Receiver类 */public abstract class Receiver &#123; // 抽象接收者，定义每个接收者都必须完成的业务 public abstract void doSomething();&#125;/** * 具体的Receiver类 */ public class ConcreteReceiver1 extends Receiver &#123; // 每个接收者都必须处理一定的业务逻辑 public void doSomething() &#123;&#125;&#125;public class ConcreteReceiver2 extends Receiver &#123; public void doSomething() &#123;&#125;&#125;/** * 抽象的Command类 */public abstract class Command &#123; // 定义一个子类的全局共享变量 protected final Receiver receiver; // 实现类必须定义一个接收者 public Command(Receiver receiver) &#123; this.receiver = receiver; &#125; // 每个命令都必须有一个执行命令的方法 public abstract void execute();&#125;/** * 具体的Command类 */ public class ConcreteCommand1 extends Command &#123; // 声明自己的默认接受者 public ConcreteCommand1() &#123; super(new ConcreteReceiver1()); &#125; public ConcreteCommand1(Receiver receiver) &#123; super(receiver) &#125; // 必须实现一个命令 public void execute() &#123; // 业务处理 this.receiver.doSomething(); &#125;&#125;public class ConcreteCommand2 extends Command &#123; // 声明自己的默认接受者 public ConcreteCommand2() &#123; super(new ConcreteReceiver2()); &#125; public ConcreteCommand2(Receiver receiver) &#123; super(receiver) &#125; // 必须实现一个命令 public void execute() &#123; // 业务处理 this.receiver.doSomething(); &#125;&#125;/** * 调用者Invoker类 */public class Invoker &#123; private Command command; // 受气包，接受命令 public void setCommand(Command command) &#123; this.command = command; &#125; // 执行命令 public void action() &#123; this.command.execute(); &#125;&#125;/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; // 首先声明调用者Invoker Invoker invoker = new Invoker(); // 定义一个发送给接收者的命令 Command command = new ConcreteCommand1(); // 把命令交给调用者去执行 invoker.setCommand(command); invoker.action(); &#125;&#125; 命令模式的优点 类间解耦 调用者角色与接收者角色之间没有任何依赖关系。 可扩展性 Command子类非常容易扩展 命令模式的缺点如果有N个命令，那么类会膨胀的非常大。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 11.中介者模式]]></title>
    <url>%2F2019%2F04%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-11-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Define an object that encapsulates how a set of objects interact Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and lets you vary their interaction independently.(用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互)。 中介者模式由以下几部分构成： Mediator抽象中介者角色： 抽象中介者角色定义统一的接口，用于各同事角色之间的通信。 Concrete Mediator具体中介者角色： 具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。 Colleague同事角色： 每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为(Self-Method)，与其他的同时类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法(Dep—Method)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 通用抽象中介者，在Mediator抽象类中我们只定义了同事类的注入， * 使用同事类的原因是，虽然是抽象但是没有每个同事类必须要完成 * 的业务方法。 */public abstract class Mediator &#123; // 定义同事类 protected ConcreteColleague1 c1; protected ConcreteColleague2 c2; // 通过getter/setter方法把同事类注入进来 public ConcreteColleague1 getC1() &#123; return c1; &#125; public void setC1(ConcreteColleague c1) &#123; this.c1 = c1; &#125; public ConcreteColleague2 getC2() &#123; return c2; &#125; public void setC2(ConcreteColleague c2) &#123; this.c2 = c2; &#125; // 中介者模式的业务逻辑 public abstract void doSomething1(); public abstract void doSomething2();&#125;/** * 通用中介者 */public class ConcreteMediator extends Mediator &#123; @Override public void doSomething1() &#123; // 调用同事类的方法，只要是public方法都可以调用 super.c1.selfMethod1(); super.c2.selfMethod2(); &#125; public void doSomething2() &#123; super.c1.selfMethod1(); super.c2.selfMethod2(); &#125;&#125;/** * 抽象同事类 */public abstract class Colleague &#123; protected Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125;/** * 具体同事类 */public class ConcreteColleague1 extends Colleague &#123; // 通过构造函数传递中介者 public ConcreteColleague1(Mediator mediator) &#123; super(mediator); &#125; // 自有方法 self-method public void selfMethod1() &#123; // 处理自己的业务逻辑 &#125; // 依赖方法 dep-method public void depMethod1() &#123; // 处理自己的业务逻辑 // 自己不能处理的业务逻辑，委托给中介者处理 super.mediator.doSomething(); &#125;&#125;public class ConcreteColleague2 extends Colleague &#123; // 通过构造函数传递中介者 public ConcreteColleague2(Mediator mediator) &#123; super(mediator); &#125; // 自有方法 self-method public void selfMethod2() &#123; // 处理自己的业务逻辑 &#125; // 依赖方法 dep-method public void depMethod2() &#123; // 处理自己的业务逻辑 // 自己不能处理的业务逻辑，委托给中介者处理 super.mediator.doSomething2(); &#125;&#125; 中介者模式的优点中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。 中介者模式的缺点中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。 中介者模式的实际应用在以下情况下尝试使用中介者模式： N个对象之间产生了相互的依赖关系(N&gt;2) 多个对象有依赖关系，但是依赖的行为尚不确定或者没有发生改变的可能，在这种情况下一般建议采用中介者模式，降低变更引起的风险扩散。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 10.代理模式]]></title>
    <url>%2F2019%2F04%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Provide a surrogate or placeholder for another object to control access to it.(为其他对象提供一种代理以控制对这个对象的访问)。 三个角色定义： Subject抽象主题角色： 抽象主题类可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求。 RealSubject具体主题角色： 也叫做被委托角色、被代理角色，是业务逻辑的具体执行者。 Proxy代理主题角色： 也叫做代理类，负责对真实角色的应用，把所有的抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 抽象主题类 */public interface Subject &#123; // 定义一个方法 void request();&#125;/** * 真实主题类 */public class RealSubject implements Subject &#123; // 实现方法 public void request() &#123; // 业务逻辑处理 &#125;&#125;/** * 代理类 */public class Proxy implements Subject &#123; // 要代理哪个实现类 private Subject subject = null; // 默认被代理者 public Proxy() &#123; this.subject = new Proxy(); &#125; // 通过构造函数传递代理者 public Proxy(Subject subject)&#123; this.subject = subject &#125; // 实现接口中定义的方法 public void request() &#123; this.before(); this.subject().request(); this.after(); &#125; // 预处理 private void before() &#123; // do Something &#125; // 善后处理 private void after() &#123; // do Something &#125;&#125; 代理模式的优点 职责清晰：真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务。 高扩展性：具体主题角色可以随时变化，但是代理类可以不做修改。 代理是有个性的：一个类可以实现多个接口，完成不同任务的整合。也就是说代理类不仅仅可以实现主题接口，也可以实现其他接口完成不同的任务，而且代理的目的是在目标对象方法的基础上做增强，这种增强的本质通常是对目标对象的拦截和过滤。 代理模式使用场景Spring AOP 代理模式的扩展普通代理需要知道代理的存在，只能访问代理角色，而不能访问真实角色。调用者只知道代理，而不用知道真实的角色是谁。真实角色由代理类进行创建。 实际项目中，一般是通过团队内的编程规范来禁止new一个真实角色，而不是通过技术手段。 强制代理调用者直接调用真实角色，不需要知道代理存在。 动态代理在实现阶段不用关系代理谁，而是在运行阶段才指定代理哪一个对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 抽象主题 */public interface Subject &#123; // 业务操作 public void doSomething(String str);&#125;/** * 动态代理的Handler类，必须实现InvocationHandler接口 */public class MyInvocationHandler implements InvocationHandler &#123; // 被代理的对象 private Object target = null; // 通过构造函数传递一个对象 public MyInvocationHandler(Object object) &#123; this.target = object; &#125; // 代理方法 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 执行被代理的方法 return method.invoke(this.target, args); &#125;&#125;/** * 动态代理类 */public class DynamicProxy&lt;T&gt; &#123; public static &lt;T&gt; T newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) &#123; // 寻找JointPoint连接点，AOP框架使用元数据定义 if(true) &#123; // 执行一个前置通知 (new BeforeAdvice()).exec(); &#125; // 执行目标，并返回结果 return (T)Proxy.newProxyInstance(loader, interfaces, h); &#125;&#125;/** * 具体业务的动态代理 */ public class SubjectDynamicProxy extends DynamicProxy &#123; public static &lt;T&gt; T newProxyInstance(Subject subject) &#123; // 获得ClassLoader ClassLoader loader = subject.getClass().getClassLoader(); // 获得接口数组 Class&lt;?&gt;[] classes = subject.getClass().getInterfaces(); // 获得Handler InvocationHandler handler = new MyInvocationHandler(subject); return newProxyInstance(loader, classes, handler); &#125;&#125;/** * 通知接口及实现 */public interface IAdvice &#123; // 通知只有一个方法，执行即可 public void exec();&#125;public class BeforeAdvice implements IAdvice &#123; public void exec() &#123; System.out.println("我是前置通知，我被执行了！"); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; // 定义一个主题 Subject subject = new RealSubject(); // 定义主题的代理 Subject proxy = SubjectDynamicProxy.newProxyInstance(subject); // 代理的行为 proxy.doSomething("Finish"); &#125;&#125; 123输出结果：我是前置通知，我被执行了！do Something! ----&gt; Finish 注意： 实现动态代理的首要条件是，被代理类必须要实现一个接口(如果不想实现接口，可以看下CGLIB代理) 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 9.迭代器模式]]></title>
    <url>%2F2019%2F04%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.(它提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节)。 迭代器模式提供了遍历容器的方便性，容器只要管理增减元素就可以了，需要遍历时交由迭代器进行。迭代器模式中的各个角色： Iterator抽象迭代器：抽象迭代器负责定义访问和遍历元素的接口，而且基本上是有固定的3个方法： first()获得第一个元素； next()访问下一个元素； hasNext()是否已经访问到底部。 ConcreteIterator具体迭代器：具体迭代器角色要实现迭代器接口，完成容器元素的遍历。 Aggregate抽象容器：容器角色负责提供创建具体迭代器角色的接口，必然提供一个类似createIterator()这样的方法，在Java中一般是iterator()方法。 Concrete Aggregate具体容器：具体容器实现容器接口定义的方法，创建出容纳迭代器的对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 抽象迭代器 */public interface Iterator &#123; // 遍历到下一个元素 Object next(); // 是否已经遍历到尾部 boolean hasNext(); // 删除当前指向的元素 boolean remove();&#125;/** * 具体迭代器 */public class ConcreteIterator implements Iterator &#123; private Vector vector = new Vector(); // 当前当前游标 public int cursor = 0; public ConcreteIterator(Vector vector)&#123; this.vector = vector; &#125; // 判断是否到达尾部 public boolean hasNext() &#123; return this.cursor != this.vector.size(); &#125; // 返回下一个元素 public Object next() &#123; Object result = null; if(this.hasNext()) &#123; result = this.vector.get(this.cursor++); &#125;else &#123; result = null; &#125; return result; &#125; // 删除当前元素 public boolean remove() &#123; this.vector.remove(this.cursor); return true; &#125;&#125;/** * 抽象容器 */public interface Aggregate &#123; public void add(Object object); public void remove(Object object); public Iterator iterator();&#125;/** * 具体容器 */public class ConcreteAggregate implements Aggregate &#123; // 容纳对象的容器 private Vector vector = new Vector(); // 增加一个元素 public void add(Object object) &#123; this.vector.add(object); &#125; // 返回迭代器对象 public Iterator iterator() &#123; return new ConcreteIterator(this.vector); &#125; // 删除一个元素 public void remove(Object object) &#123; this.remove(object); &#125;&#125;/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; // 声明容器 Aggregate agg = new ConcreteAggregate(); // 产生对象数据放进去 agg.add("abc"); agg.add("aaa"); agg.add("1234"); Iterator iterator = agg.iterator(); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 迭代模式的应用Java中继承了Iterable接口的类，已经帮我们实现了这个模式。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 8.原型模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.(用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象)。 原型模式的核心是一个clone方法，通过该方法进行对象的拷贝。 12345678910111213141516/** * 原型模式通用源码 */public class PrototypeClass implements Cloneable &#123; // 覆写父类Object方法 @Override public PrototypeClass clone() &#123; PrototypeClass prototypeClass = null; try &#123; prototypeClass = (PrototypeClass)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // 异常处理 &#125; return prototypeClass; &#125;&#125; 原型模式的优点 性能优良：原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好得多。 逃避构造函数的约束 使用场景 资源优化场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源。 性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑用原型模式拷贝多个对象供调用者使用。 注意事项 构造函数不会被执行 一个实现了Cloneable并重写了clone方法的类A，有一个无参构造或有参构造B，通过new关键字产生一个对象S，再然后通过S.clone()方式产生了一个新的对象T，那么在对象拷贝时，构造函数B是不会执行的。 12345678910111213141516171819202122232425262728293031/** * 简单的可拷贝对象 */public class Thing implements Cloneable &#123; public Thing() &#123; System.out.println("构造函数被执行了..."); &#125; @Override public Thing clone() &#123; Thing thing = null; try &#123; thing = (Thing)super.clone(); &#125; catch (CloneNotSupportException e) &#123; e.printStackTrace(;) &#125; return thing; &#125;&#125;/** * 简单的场景类 */public class Client &#123; public static void main(String[] args) &#123; // 产生一个对象 Thing thing = new Thing(); // 拷贝一个对象 Thing cloneThing = thing.clone(); &#125;&#125; 12输出结果:构造函数被执行了... 对象拷贝时构造函数确实没有被执行，这点从原理来讲也是可以讲的通的，Object类的clone方法的原理是从内存中(具体地说就是堆内存)以二进制流的方法进行拷贝，重新分配一个内存块，那构造函数没有被执行也是非常正常的了。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[踩坑指南] 1.Lists.transform修改无效问题]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97-1-Lists-transform%E4%BF%AE%E6%94%B9%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前段时间在工作中，发现了关于Lists.transform()方法的一些坑点。在一些情况下，会造成对Lists.transform返回的值更改无效的情况。 准备工作首先先创建一个Bean用来测试1234567891011121314151617// 这两个注解是lombok插件提供的，相当于手写Getter和Setter方法@Getter@Setterpublic class TestBean &#123; Integer testA; String testB; int testC; public TestBean() &#123; &#125; public TestBean(Integer testA, String testB, int testC) &#123; this.testA = testA; this.testB = testB; this.testC = testC; &#125;&#125; 测试首先，先看一下最简单的情况。创建一个ArrayList，然后将其中的Element加入到Lists.transform返回的集合中。12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String[] args) &#123; /** * 首先先创建几个bean进行测试 */ TestBean testBean1 = new TestBean(1, "1", 1); TestBean testBean2 = new TestBean(2, "2", 2); TestBean testBean3 = new TestBean(3, "3", 3); List&lt;TestBean&gt; testBeanList = Lists.newArrayList(testBean1, testBean2, testBean3); /** * 然后使用Lists.transform，这里只是简单的将testBeanList中的Element加到transFormList中 */ List&lt;TestBean&gt; transformList = Lists.transform(testBeanList, testBean -&gt; testBean); System.out.println("Transform List(第一次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); testBean.setTestA(999); testBean.setTestB("999"); testBean.setTestC(999); &#125;); System.out.println("\n-------------------------------------------\n"); System.out.println("Transform List(第二次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); &#125;); &#125;&#125; 123456789101112输出结果为Transform List(第一次):testBean Address :TestBean@27bc2616 testA:1 testB:1 testC:1testBean Address :TestBean@3941a79c testA:2 testB:2 testC:2testBean Address :TestBean@506e1b77 testA:3 testB:3 testC:3-------------------------------------------Transform List(第二次):testBean Address :TestBean@27bc2616 testA:999 testB:999 testC:999testBean Address :TestBean@3941a79c testA:999 testB:999 testC:999testBean Address :TestBean@506e1b77 testA:999 testB:999 testC:999 可以发现，在这个例子中对lists.transform元素进行修改是成功的。 接下来再看下面的例子。在将testBeanList中的字段添加到transformList中时，新建一个Bean并加入到transform集合中，而不是加入原有的Bean。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test &#123; public static void main(String[] args) &#123; /** * 首先我们先创建几个bean进行测试 */ TestBean testBean1 = new TestBean(1, "1", 1); TestBean testBean2 = new TestBean(2, "2", 2); TestBean testBean3 = new TestBean(3, "3", 3); List&lt;TestBean&gt; testBeanList = Lists.newArrayList(testBean1, testBean2, testBean3); /** * 然后使用Lists.transform */ List&lt;TestBean&gt; transformList = Lists.transform(testBeanList, testBean -&gt; &#123; TestBean tempTestBean = new TestBean(); tempTestBean.setTestA(testBean.getTestA()); tempTestBean.setTestB(testBean.getTestB()); tempTestBean.setTestC(testBean.getTestC()); return tempTestBean; &#125;); System.out.println("Transform List(第一次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); testBean.setTestA(999); testBean.setTestB("999"); testBean.setTestC(999); &#125;); System.out.println("\n-------------------------------------------\n"); System.out.println("Transform List(第二次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); &#125;); &#125;&#125; 123456789101112输出结果为：Transform List(第一次):testBean Address :TestBean@27bc2616 testA:1 testB:1 testC:1testBean Address :TestBean@3941a79c testA:2 testB:2 testC:2testBean Address :TestBean@506e1b77 testA:3 testB:3 testC:3-------------------------------------------Transform List(第二次):testBean Address :TestBean@9807454 testA:1 testB:1 testC:1testBean Address :TestBean@3d494fbf testA:2 testB:2 testC:2testBean Address :TestBean@1ddc4ec2 testA:3 testB:3 testC:3 可以发现修改失败了。通过打印的日志，可以看出， 两次遍历transformList的过程中，遍历到的Bean的地址是不同的第一次为：27bc2616，3941a79c，506e1b77第二次为：9807454，3d494fbf，1ddc4ec2两次遍历的地址都不一样，那结果不一样当然是可能的。但是为什么对于同一个List，两次遍历会是不同的地址。再看下面的代码，这次我们将赋值的过程也打印出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Test &#123; public static void main(String[] args) &#123; /** * 首先我们先创建几个bean进行测试 */ TestBean testBean1 = new TestBean(1, "1", 1); TestBean testBean2 = new TestBean(2, "2", 2); TestBean testBean3 = new TestBean(3, "3", 3); List&lt;TestBean&gt; testBeanList = Lists.newArrayList(testBean1, testBean2, testBean3); /** * 然后使用Lists.transform */ List&lt;TestBean&gt; transformList = Lists.transform(testBeanList, testBean -&gt; &#123; TestBean tempTestBean = new TestBean(); tempTestBean.setTestA(testBean.getTestA()); tempTestBean.setTestB(testBean.getTestB()); tempTestBean.setTestC(testBean.getTestC()); System.out.print("---tempTestBean Address :" + tempTestBean.toString() + " "); System.out.print("---testA:" + tempTestBean.getTestA() + " "); System.out.print("---testB:" + tempTestBean.getTestB() + " "); System.out.println("---testC:" + tempTestBean.getTestC()); return tempTestBean; &#125;); System.out.println("Transform List(第一次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); testBean.setTestA(999); testBean.setTestB("999"); testBean.setTestC(999); &#125;); System.out.println("\n-------------------------------------------\n"); System.out.println("Transform List(第二次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); &#125;); &#125;&#125; 123456789101112131415161718输出结果Transform List(第一次):---tempTestBean Address :TestBean@3dd3bcd ---testA:1 ---testB:1 ---testC:1testBean Address :TestBean@3dd3bcd testA:1 testB:1 testC:1---tempTestBean Address :TestBean@97e1986 ---testA:2 ---testB:2 ---testC:2testBean Address :TestBean@97e1986 testA:2 testB:2 testC:2---tempTestBean Address :TestBean@26f67b76 ---testA:3 ---testB:3 ---testC:3testBean Address :TestBean@26f67b76 testA:3 testB:3 testC:3-------------------------------------------Transform List(第二次):---tempTestBean Address :TestBean@7f560810 ---testA:1 ---testB:1 ---testC:1testBean Address :TestBean@7f560810 testA:1 testB:1 testC:1---tempTestBean Address :TestBean@69d9c55 ---testA:2 ---testB:2 ---testC:2testBean Address :TestBean@69d9c55 testA:2 testB:2 testC:2---tempTestBean Address :TestBean@13a57a3b ---testA:3 ---testB:3 ---testC:3testBean Address :TestBean@13a57a3b testA:3 testB:3 testC:3 发现输出结果非常奇怪，为什么复制过程执行了两次，而且没有按顺序执行，好像也不是异步执行。 可以发现每次复制操作后，都会跟着一个后来的遍历操作，而且复制操作打印出来的Bean的地址和遍历时Bean的地址是一模一样的。出现这种现象的原因就是因为Guava中常用的懒加载导致的(具体原理可见Guava懒加载原理)。所以Lists.transform()方法并不是在调用处执行，而是在每次使用它返回的结果，也就是例子中transformList的时候，才会执行，这样就解释了为什么会有这种输出结果，而且改动不生效的原因了。 那么为什么本文中的第一个示例成功了呢。因为，只是直接返回了一个原始的Bean，并没有返回新建的Bean。那么虽然是懒加载，但是每次返回的都是同样的Bean也就不存在地址不同的问题了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; /** * 首先我们先创建几个bean进行测试 */ TestBean testBean1 = new TestBean(1, "1", 1); TestBean testBean2 = new TestBean(2, "2", 2); TestBean testBean3 = new TestBean(3, "3", 3); List&lt;TestBean&gt; testBeanList = Lists.newArrayList(testBean1, testBean2, testBean3); /** * 然后使用Lists.transform */ List&lt;TestBean&gt; transformList = Lists.transform(testBeanList, testBean -&gt; &#123; System.out.print("---testBean Address :" + testBean.toString() + " "); System.out.print("---testA:" + testBean.getTestA() + " "); System.out.print("---testB:" + testBean.getTestB() + " "); System.out.println("---testC:" + testBean.getTestC()); return testBean; &#125;); System.out.println("Transform List(第一次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); testBean.setTestA(999); testBean.setTestB("999"); testBean.setTestC(999); &#125;); System.out.println("\n-------------------------------------------\n"); System.out.println("Transform List(第二次):"); transformList.forEach(testBean -&gt; &#123; System.out.print("testBean Address :" + testBean.toString() + " "); System.out.print("testA:" + testBean.getTestA() + " "); System.out.print("testB:" + testBean.getTestB() + " "); System.out.println("testC:" + testBean.getTestC()); &#125;); &#125;&#125; 1234567891011121314151617Transform List(第一次):---testBean Address :TestBean@27bc2616 ---testA:1 ---testB:1 ---testC:1testBean Address :TestBean@27bc2616 testA:1 testB:1 testC:1---testBean Address :TestBean@3941a79c ---testA:2 ---testB:2 ---testC:2testBean Address :TestBean@3941a79c testA:2 testB:2 testC:2---testBean Address :TestBean@506e1b77 ---testA:3 ---testB:3 ---testC:3testBean Address :TestBean@506e1b77 testA:3 testB:3 testC:3-------------------------------------------Transform List(第二次):---testBean Address :TestBean@27bc2616 ---testA:999 ---testB:999 ---testC:999testBean Address :TestBean@27bc2616 testA:999 testB:999 testC:999---testBean Address :TestBean@3941a79c ---testA:999 ---testB:999 ---testC:999testBean Address :TestBean@3941a79c testA:999 testB:999 testC:999---testBean Address :TestBean@506e1b77 ---testA:999 ---testB:999 ---testC:999testBean Address :TestBean@506e1b77 testA:999 testB:999 testC:999 可以发现正如猜想的一样，每次返回的都是同样的地址。 推荐阅读Guava懒加载原理]]></content>
      <categories>
        <category>踩坑指南</category>
      </categories>
      <tags>
        <tag>踩坑指南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 7.模板方法模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redifine certain steps of an algorithm without changing the algorithm’s structure.(定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤)。 其中AbstractClass叫做抽象模板，它的方法分两类： 基本方法：也叫基本操作，是由子类实现的方法，在模板方法被调用。 模板方法：可以有多个，实现对基本方法的调度。 一般模板方法被加上final防止被覆写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 抽象模板类 */public abstract class AbstractClass &#123; // 基本方法 protected abstract void doSomething(); // 基本方法 protected abstract void doAnything(); // 模板方法 public void templateMethod() &#123; /** * 调用基本方法，完成相关的逻辑 */ this.doAnything(); this.doSomething(); &#125;&#125;/** * 具体模板类 */public class ConcreteClass1 extends AbstractClass &#123; // 实现基本方法 protected void doAnthing() &#123; // 业务逻辑处理 &#125; protected void doSomething() &#123; // 业务逻辑处理 &#125;&#125;public class ConcreteClass2 extends AbstractClass &#123; // 实现基本方法 protected void doAnthing() &#123; // 业务逻辑处理 &#125; protected void doSomething() &#123; // 业务逻辑处理 &#125;&#125;/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; AbstractClass class1 = new ConcreteClass1(); AbstractClass class2 = new ConcreteClass2(); // 调用模板方法 class1.templateMethod(); class2.templateMethod(); &#125;&#125; 优点 封装不变部分，扩展可变部分 提取公共代码，便于维护 行为由父类控制，子类实现 缺点 子类对父类造成了影响(子类执行的结果影响了父类的结果) 使用场景 多个子类有共有的方法，且逻辑基本相同时 复杂算法，核心逻辑可设计为模板方法 相同代码抽取到父类中，然后通过钩子函数约束行为 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 6.装饰模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Attach additional responsibilities to an object dynamically keeping the same interface. Decorators procide a flexible alternative to subclassing for extending functionaility.(动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活)。 有四个角色需要说明： Component抽象构件：Component是一个接口或者是抽象类，就是最原始的对象。 ConcreteComponent具体构件：是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。 Decorator装饰角色：一般是一个抽象类，实现接口或者抽象方法，它属性里必然有一个private变量指向Component抽象构件。 ConcreteDecorator具体装饰角色：把最核心的，最原始的，最基本的东西装饰成其他东西。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 抽象构件 */ public abstract class Component &#123; // 抽象方法 public abstract void operate();&#125;/** * 具体构件 */public class ConcreteComponent extends Component &#123; // 具体实现 @Override public void operate() &#123; System.out.println("do Something"); &#125;&#125;/** * 抽象装饰者 */public abstract class Decorator extends Component &#123; private Component component = null; // 通过构造函数传递被修饰者 public Decorator (Component component) &#123; this.component = component; &#125; // 委托给被修饰者执行 @Override public void operate() &#123; this.component.operate(); &#125;&#125;/** * 具体的装饰类 */public class ConcreteDecorator1 extends Decorator &#123; // 定义被修饰者 public ConcreteDecorator1(Component component)&#123; super(component); &#125; //定义自己的修饰方法 private void method1()&#123; System.out.println("method1 修饰"); &#125;//重写父类的Operation方法 public void operate()&#123; this.method1(); super.operate(); &#125;&#125;public class ConcreteDecorator2 extends Decorator &#123; // 定义被修饰者 public ConcreteDecorator2(Component component)&#123; super(component); &#125; // 定义自己的修饰方法 private void method2()&#123; System.out.println("method2修饰"); &#125; // 重写父类的Operation方法 public void operate()&#123; super.operate(); this.method2(); &#125;&#125; 1234567891011121314/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; Component component = new Component(); // 第一次装饰 component = new ConcreteDecorator1(component); // 第二次装饰 component = new ConcreteDecorator2(component); // 修饰后运行 component.operate(); &#125;&#125; 装饰模式优点 装饰类和被装饰类可以独立发展，不会耦合。 是继承关系的替代方案。 可以动态地扩展一个实现类的功能。 装饰模式缺点 多层装饰比较复杂。 使用场景 需要扩展一个类的功能，或给一个类增加附加功能。 需要动态地给一个对象增加功能，这些功能可以在动态的撤销。 需要为一批的兄弟类进行改装或加装功能。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 5.责任链模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Avoid coupling the sender of a request to its receiver by giving more than one object by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handle it.(使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止)。 123456789101112131415161718192021222324252627282930313233343536/** * 抽象处理者 */public abstract class Handler &#123; private Handler nextHandler; // 每个处理者都必须对请求做出处理 public final Response handleMessage(Request request) &#123; Response response = null; // 判断是否是自己的处理级别 if(this.getHandlerLevel().equals(request.getRequestLevel()) &#123; response = this.echo(request); &#125; else &#123; // 不属于自己的处理级别 // 判断是否有下一个处理者 if (this.nextHandler != null) &#123; response = this.nextHandler.handleMessage(request); &#125; else &#123; // 没有适当的处理者， 业务自行处理 &#125; &#125; return response; &#125; // 设置下一个处理者是谁 public void setNext(Handler _handler) &#123; this.nextHandler = _handler; &#125; // 每个处理者都有一个处理级别 protected abstract Level getHandlerLevel(); // 每个处理者都必须实现处理任务 protected abstract Response echo(Request request);&#125; 抽象处理着实现三个职责： 定义一个请求的处理方法handleMessage，唯一对外开放的方法； 定义一个链的编排方法setNext，设置下一个处理者； 定义了具体请求者必须实现的两个方法：定义自己能够处理的级别getHandlerLevel和具体的处理任务echo； 注意handleMessage方法的final关键字 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 具体处理者 */public class ConcreteHandler1 extends Handler &#123; // 定义自己的处理逻辑 protected Response echo(Request request) &#123; // 完成处理逻辑 return null; &#125; // 设置自己的处理级别 protected Level getHandlerLevel() &#123; // 设置自己的处理级别 return null; &#125;&#125; public class ConcreteHandler2 extends Handler &#123; // 定义自己的处理逻辑 protected Response echo(Request request) &#123; // 完成处理逻辑 return null; &#125; // 设置自己的处理级别 protected Level getHandlerLevel() &#123; // 设置自己的处理级别 return null; &#125;&#125;public class ConcreteHandler3 extends Handler &#123; // 定义自己的处理逻辑 protected Response echo(Request request) &#123; //完成处理逻辑 return null; &#125; // 设置自己的处理级别 protected Level getHandlerLevel() &#123; // 设置自己的处理级别 return null; &#125;&#125; 123456789101112131415161718/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; // 声明所有的处理节点 Handler handler1 = new ConcreteHandler1(); Handler handler2 = new ConcreteHandler2(); Handler handler3 = new ConcreteHandler3(); // 设置链中的阶段顺序1--&gt;2--&gt;3 handler1.setNext(handler2); handler2.setNext(handler3); // 提交请求， 返回结果 Response response = handler1.handlerMessage(new Request()); &#125;&#125; 责任链的优点 将请求和处理分开。请求者不必知道是谁处理的。 责任链的缺点 性能问题，每个请求都从链头到链尾遍历。 责任链的注意事项 限制结点数量，避免出现超长链。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 4.建造者模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Separate the construction of a complex object from its representation so that the same construction process can create different representations.(将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示) Product产品类：通常是实现类模板方法模式。 Builder抽象建造者：规范产品的组建，一般是由子类实现。 ConcreteBuilder具体建造者：实现抽象类定义的所有方法，并且返回一个组建好的对象。 Director导演类：负责安排已有模块的顺序，然后告诉Builder开始建造。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 产品类 */public class Product &#123; public void doSomething() &#123; // 独立业务处理 &#125;&#125;/** * 抽象建造者 */public abstract class Builder &#123; // 设置产品的不同部分，以获得不同的产品 public abstract void setPart(); // 建造产品 public abstract Product buildProduct();&#125;/** * 具体建造者 */public class ConcreteProduct extends Builder &#123; private Product product = new Product(); // 设置产品零件 public void setPart() &#123; /** * 产品类的逻辑处理 */ &#125; // 组建一个产品 public Product buildProduct() &#123; return product; &#125;&#125;/** * 导演类 */public class Director &#123; private Builder builder = new ConcreteBuilder(); // 构造不同的产品 public Product getAProduct() &#123; builder.setPart(); /** * 设置不同的零件，产生不同的产品 */ return builder.buildProduct(); &#125;&#125; 建造者模式的优点 封装性：使用建造者模式可以使客户端不必知道产品内部的组成细节。 建造者独立，容易扩展。 建造者模式使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。 多个零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，可以使用建造者模式。 注意事项建造者模式关注的是零件类型和顺序。 事例生产不同车辆，不同车辆的启动顺序不同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 相当于Product，只不过对其又进行了一次抽象public abstract class CarModel &#123; // 这个参数是各个基本方法执行的顺序 private ArrayList&lt;String&gt; sequence = new ArrayList&lt;String&gt;(); // 模型是启动开始跑了 protected abstract void start(); // 能发动， 还要能停下来， 那才是真本事 protected abstract void stop(); // 喇叭会出声音， 是滴滴叫， 还是哔哔叫 protected abstract void alarm(); // 引擎会轰隆隆地响， 不响那是假的 protected abstract void engineBoom(); // 那模型应该会跑吧， 别管是人推的， 还是电力驱动， 总之要会跑 final public void run() &#123; //循环一遍， 谁在前， 就先执行谁 for(int i=0;i&lt;this.sequence.size();i++)&#123; String actionName = this.sequence.get(i); if (actionName.equalsIgnoreCase("start")) &#123; this.start(); // 启动汽车 &#125; else if (actionName.equalsIgnoreCase("stop")) &#123; this.stop(); // 停止汽车 &#125; else if (actionName.equalsIgnoreCase("alarm")) &#123; this.alarm(); // 喇叭开始叫了 &#125; else if (actionName.equalsIgnoreCase("engine boom")) &#123; // 如果是engine boom关键 this.engineBoom(); // 引擎开始轰鸣 &#125; &#125; &#125; //把传递过来的值传递到类内 final public void setSequence(ArrayList sequence) &#123; this.sequence = sequence; &#125;&#125;// 产品类public class BenzModel extends CarModel &#123; protected void alarm() &#123; System.out.println("奔驰车的喇叭声音是这个样子的..."); &#125; protected void engineBoom() &#123; System.out.println("奔驰车的引擎是这个声音的..."); &#125; protected void start() &#123; System.out.println("奔驰车跑起来是这个样子的..."); &#125; protected void stop() &#123; System.out.println("奔驰车应该这样停车..."); &#125; &#125;// 产品类public class BMWModel extends CarModel &#123; protected void alarm() &#123; System.out.println("宝马车的喇叭声音是这个样子的..."); &#125; protected void engineBoom() &#123; System.out.println("宝马车的引擎是这个声音的..."); &#125; protected void start() &#123; System.out.println("宝马车跑起来是这个样子的..."); &#125; protected void stop() &#123; System.out.println("宝马车应该这样停车..."); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/** * 抽象建造者 */public abstract class CarBuilder &#123; // 建造一个模型， 你要给我一个顺序要求， 就是组装顺序 public abstract void setSequence(ArrayList&lt;String&gt; sequence); // 设置完毕顺序后， 就可以直接拿到这个车辆模型 public abstract CarModel getCarModel();&#125;/** * 具体建造者 */public class BenzBuilder extends CarBuilder &#123; private BenzModel benz = new BenzModel(); public CarModel getCarModel() &#123; return this.benz; &#125; public void setSequence(ArrayList&lt;String&gt; sequence) &#123; this.benz.setSequence(sequence); &#125;&#125;/** * 具体建造者 */public class BMWBuilder extends CarBuilder &#123; private BMWModel bmw = new BMWModel(); public CarModel getCarModel() &#123; return this.bmw; &#125; public void setSequence(ArrayList&lt;String&gt; sequence) &#123; this.bmw.setSequence(sequence); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 导演类 */ public class Director &#123; private ArrayList&lt;String&gt; sequence = new ArrayList(); private BenzBuilder benzBuilder = new BenzBuilder(); private BMWBuilder bmwBuilder = new BMWBuilder(); /* * A类型的奔驰车模型， 先start， 然后stop， 其他什么引擎、 喇叭一概没有 */ public BenzModel getABenzModel() &#123; // 清理场景， 这里是一些初级程序员不注意的地方 this.sequence.clear(); // ABenzModel的执行顺序 this.sequence.add("start"); this.sequence.add("stop"); // 按照顺序返回一个奔驰车 this.benzBuilder.setSequence(this.sequence); return (BenzModel) this.benzBuilder.getCarModel(); &#125; /** * B型号的奔驰车模型，是先发动引擎，然后启动，然后停止，没有喇叭 */ public BenzModel getBBenzModel() &#123; this.sequence.clear(); this.sequence.add("engine boom"); this.sequence.add("start"); this.sequence.add("stop"); this.benzBuilder.setSequence(this.sequence); return (BenzModel) this.benzBuilder.getCarModel(); &#125; /** * C型号的宝马车是先按下喇叭（炫耀嘛） ，然后启动，然后停止 */ public BMWModel getCBMWModel() &#123; this.sequence.clear(); this.sequence.add("alarm"); this.sequence.add("start"); this.sequence.add("stop"); this.bmwBuilder.setSequence(this.sequence); return (BMWModel) this.bmwBuilder.getCarModel(); &#125; /** * D类型的宝马车只有一个功能，就是跑，启动起来就跑，永远不停止 */ public BMWModel getDBMWModel() &#123; this.sequence.clear(); this.sequence.add("start"); this.bmwBuilder.setSequence(this.sequence); return (BMWModel) this.benzBuilder.getCarModel(); &#125;&#125; 1234567891011121314151617181920/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; Director director = new Director(); // 1万辆A类型的奔驰车 for (int i = 0; i &lt; 10000; i++) &#123; director.getABenzModel().run(); &#125; // 100万辆B类型的奔驰车 for (int i = 0; i &lt; 1000000; i++) &#123; director.getBBenzModel().run(); &#125; // 1000万辆C类型的宝马车 for (int i = 0; i &lt; 10000000; i++) &#123; director.getCBMWModel().run(); &#125; &#125;&#125; 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 3.抽象工厂模式]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Provide an interface for creating families of related or dependent objects without specifying their concrete classes.(为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 抽象产品类 */public abstract class AbstractProductA &#123; // 每个产品共有的方法 public void shareMethod() &#123;&#125; // 每个产品相同方法，不同实现 public abstract void doSomething();&#125;/** * 产品A1的实现类 */ public class ProductA1 extends AbstractProductA &#123; public void doSomething() &#123; System.out.println("产品A1的实现方法"); &#125;&#125;/** * 产品A2的实现类 */public class ProductA2 extends AbstractProduct &#123; public void doSomething() &#123; System.out.println("产品A2的实现方法"); &#125;&#125;/** * 抽象工厂类，有N个产品族，在抽象工厂类中就应该有N个创建方法 */public abstract class AbstractCreator &#123; // 创建A产品家族 public abstract AbstractProductA createProductA(); // 创建B产品家族 public abstract AbstractProductB createProductB();&#125;/** * 产品等级1的实现类，有M个产品等级就应该有M个实现工厂类，在每个实现工厂中， * 实现不同产品族的生产任务 */public class Creator1 extends AbstractCreator &#123; // 只生产产品等级为1的产品 public AbstractProductA creatorProductA() &#123; return new ProductA1(); &#125; // 只生产产品等级为2的产品 public AbstractProductB creatorProductB() &#123; return new ProductA2(); &#125;&#125;/** * 产品等级2的实现类 */public class Creator2 extends AbstractCreator &#123; // 只生产产品等级为2的A产品 public AbstractProductA createProductA() &#123; return new ProductA2(); &#125; // 只生产产品等级为2的B产品 public AbstractProductB createProductB() &#123; return new ProductB2(); &#125;&#125;/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; // 定义两个工厂 AbstractCreator creator1 = new Creator1(); AbstractCreator creator2 = new Creator2(); // 产生A1对象 AbstractProductA a1 = creator1.createProductA(); // 产生A2对象 AbstractProductA a2 = creator2.createProductA(); // 产生B1对象 AbstractProductB b1 = creator1.createProductB(); // 产生B2对象 AbstractProductB b2 = creator2.createProductB(); &#125;&#125; 抽象工厂模式的缺点产品族扩展非常困难 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 2.工厂方法模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Define an interface for creating an object, but let subclassed decide with class to instantiate. Factory Method lets a class defer instantiation to subclasses.(定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类)。 抽象产品类Product负责定义产品的共性，实现对事务最抽象的定义; 抽象创建类Creator也就是抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。 12345678910/** * 抽象产品类 */public abstract class Product &#123; // 产品类的公共方法 public void method1() &#123;&#125; // 抽象方法 public abstract void method2() &#123;&#125;&#125; 1234567891011121314/** * 具体产品类 */public class ConcreteProduct1 extends Product &#123; public void method2() &#123; // 业务逻辑处理 &#125;&#125;public class ConcreteProduct2 extends Product &#123; public void method2() &#123; // 业务逻辑处理 &#125;&#125; 1234567/** * 抽象工厂类 */public abstract class Creator &#123; // 创建一个产品对象，其输入参数类型可以自行设置 public abstract &lt;T extends Product&gt; T createProduct (Class&lt;T&gt; c);&#125; 1234567891011121314/** * 具体工厂类，具体如何产生一个产品对象 */public class ConcreteCreator extends Creator &#123; public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c)&#123; Product product = null; try &#123; product = (Product) Class.forName (c.getName()).newInstance(); &#125;catch (Exception e)&#123; // 异常处理 &#125; return (T) product; &#125;&#125; 123456789101112/** * 场景类 */public class Client &#123; public static void main(String[] args) &#123; Creator creator = new ConcreteCreator(); Product product = creator.createProduct(ConcreteProduct1.class); /** * 继续业务处理 */ &#125;&#125; 工厂方法模式的优点： 工厂类不用任何修改就可以完成系统扩展。 屏蔽产品类，产品类实现如何变化，调用者都不需要关心。 工厂模式使用场景： 在所有需要生成对象的地方都可以使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码复杂度。 需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。例如，设计一个邮件服务器，有3中网络协议：POP3、IMAP、HTTP，我们可以把这三种方法作为产品类 工厂模式的扩展： 简单工厂模式：一个模块仅需要一个工厂类，没必要把它生产出来，可以使用静态方法。缺点是扩展困难。 12345678910111213141516/** * 工厂类 */ public class HumanFactory &#123; public static &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c) &#123; // 定义一个生产出的人种 Human human = null; try &#123; // 产生一个人种 human = (Human) Class.forname(c.getName()).newInstance(); &#125; catch (Exception e) &#123; System.out.println("人种生成错误"); &#125; return (T)human; &#125;&#125; 12345678910/** * 场景类 */public class NvWa &#123; public static void main(String[] args) &#123; Human whiteHuman = HumanFactory.createHuman(WhiteHuman.class); Human blackHuman = HumanFactory.createHuman(BlackHuman.class); Human yellowHuman = HumanFactory.createHuman(YellowHuman.class); &#125;&#125; 多个工厂类：为每个产品定义一个创造者，然后由调用者去选择与哪个工厂方法关联 1234567/** * 多工厂模式的抽象工厂类, 抽象方法中已经不再需要传递相关参数了，因为每一个具体的 * 的工厂都已经非常明确自己的职责，创建自己负责的产品类对象。 */ public abstract class AbstractHumanFactory &#123; public abstract Human createHuman();&#125; 12345678/** * 黑色人种创建工厂实现 */public class BlackHumanFactory extentds AbstractHumanFactory &#123; public Human createHuman() &#123; return new BlackHuman(); &#125;&#125; 12345678/** * 黄色人种创建工厂实现 */ public class YellowHumanFactory extends AbstractHumanFactory &#123; public Human createHuman() &#123; return new YellowHuman(); &#125;&#125; 12345678/** * 白色人种创建工厂实现 */public class WhiteHumanFactroy extends AbstractHumanFactory &#123; public Human createHuman() &#123; return new WhiteHuman(); &#125;&#125; 12345678910/** * 场景类 */public class NvWa &#123; public static void main(String[] args)&#123; Human whiteHuman = (new WhiteHumanFactory()).createHuman(); Human blackHuman = (new BlackHumanFactory()).createHuman(); Human yellowHuman = (new YellowHumanFactory()).createHuman(); &#125;&#125; 替代单例模式 12345678910/** * 单例类 */public class Singleton &#123; // 不允许通过new产生一个对象 private Singleton() &#123;&#125; public void doSomething() &#123; 业务处理 &#125;&#125; 1234567891011121314151617181920212223/** * 负责生成单例的工厂类 */public class SingletonFactory &#123; private static Singleton singleton; static &#123; try &#123; Class clazz = Class.forName(Singleton.class.getName()); // 获得无参构造 Constructor constructor = clazz.getDeclaredConstructor(); // 设置无参构造是可访问的 constructor.setAccessible(true); // 产生一个实例对象 singletion = (Singleton) constructor.newInstance(); &#125; catch (Exection e)&#123; // 异常 &#125; &#125; public static Singleton getSingleton() &#123; return singleton; &#125;&#125; 延迟初始化一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。ProductFactory负责产品类对象的创建工作，并且通过prMap变量产生一个缓存，对需要再次被重用的对象保留，Product和ConcreteProduct是一个示例代码。 {% asset_img 延迟初始化通用类图.png 延迟初始化通用类图 %} 1234567891011121314151617public class ProductFactory &#123; private static final Map&lt;String, String&gt; prMap = new HashMap(); public static synchronized Product createProduct(String type) throws Exception &#123; Product product = null; // 如果Map中已经有这个对象 if (prMap.containsKey(type))&#123; product = prMap.get(type); &#125;else &#123; if (type.equals("Product1")) &#123; product = new ConcreteProduct1(); &#125;else&#123; product = new ConcreteProduct2(); &#125; &#125; return product; &#125;&#125; 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[设计模式] 1.单例模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一个类只能生成一个对象，所有对象对它的依赖都是相同的。通过定义一个私有访问权限的构造函数，避免被其他类new出一个对象，而该类自己可以new出一个对象，其他类可以通过getInstance获得同一个对象 Ensure a class has only one instance, and provide a global point of access to it.(确保某一个类只有一个实例，并且自行实例化并向整个系统提供这个实例)。 饿汉式单例：第一次引用该类的时候就创建对象实例，无法延迟加载。12345678910111213public class Singleton &#123; private static final Singleton singleton = new Singleton(); // 限制产生多个对象 private Singletion () &#123;&#125; // 通过该方法获得实例对象 public static Singleton getSingleton() &#123; return singleton; &#125; // 类中其他方法，尽量使static public static void doSomething() &#123; &#125;&#125; 懒汉式单例：可以做到延迟加载，但是线程不安全。如果有两条线程同时调用getSingleton()方法，就有可能导致重复创建对象。 123456789101112131415/** * 懒汉式单例。 */ public class Singleton &#123; private static Singleton singleton = null; // 限制产生多个对象 private Sigleton()&#123;&#125; // 通过该方法获得实例对象 public static synchronized Singleton getSingleton() &#123; if (singleton == null)&#123; singleton = new Singleton(); &#125; return singleton; &#125; &#125; 考虑线程安全, 缺点是效率低下，无法实际应用。 123456789101112public class Singleton &#123; private static volatile Singleton singleton = null; private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; return singleton; &#125;&#125; 兼顾线程安全和效率的写法, 缺点是在jdk1.5之前，volatile无法避免重排序所导致的问题。 1234567891011121314public class Singleton &#123; private static volatile Singleton singleton = null; private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null)&#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 静态内部类法, 需要额外的工作(Serializable、transient、readResolve)来实现序列化，否则每次反序列化一个序列化的对象实例时都会创建一个新的实例。可能会有人使用反射强行调用私有构造器(如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常)。 1234567891011public class Singleton &#123; private static class Holder &#123; private static Singleton singleton = new Singleton(); &#125; private Singleton() &#123;&#125;; public static Singleton getSingleton() &#123; return Holder.singleton; &#125;&#125; 枚举写法：使用枚举除了线程安全和防止反射强行调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。 12345678910public enum Singleton &#123; INSTANCE; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 单例模式的优点 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建，销毁时，而且创建或销毁时性能又无法优化，单例模式就很好。 由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用驻留内存的方式来解决(在JAava EE中采用单例模式时需要注意JVM垃圾回收机制)。 单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。 单例模式可以在系统设置全局的访问点，优化和共享资源访问。 Bean为单例模式，可以方便的管理生命周期。 单例模式的缺点 单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。 单例与单一职责原则有冲突。 使用场景在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现”不良反应”。可以采用单例模式，例如： 生成唯一系列号。 在整个项目需要一个共享访问点或共享数据，例如一个web页面上的计数器。 创建一个对象需要消耗的资源过多，例如IO和访问数据库。 需要定义大量的静态常量和静态方法的环境。 注意事项 要考虑对象复制，在Java中，对象默认是不可以被复制的，若实现Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象复制是不可调用类的构造函数，因此即使是私有的构造函数，对象仍然可以被复制。最好解决方法是单例类不要实现Cloneable接口。 1参考内容 &gt;&gt; 设计模式之禅]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 16.3Sum Closest]]></title>
    <url>%2F2018%2F12%2F15%2FLeetCode-16-3Sum-Closest%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个包含n个整数的数组和一个target数，找出数组中3个和与target数最接近的数，并返回它们的和。你可以假设只有一种特定的答案。 例子： 输入: [-1, 2, 1, -4], target = 1. 输出：2 解释: -1 + 2 + 1 = 2 最接近 解题方法首先将nums数组排序，然后使用一个指针i从头遍历数组，对于元素i有以下两种可能： 如果i = 0或者nums[i] != nums[i-1]：使用两个指针left，right分别指向i+1和数组最后一个元素，然后用nums[left] + nums[right]和-nums[i]相比。 使用一个temp记录最接近的和是多少 i元素与i-1元素相等，则i向后移，避免选取重复三元组。最后返回和为temp对应的三个数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution&#123; public: int threeSumClosest(vector&lt;int&gt; &amp;nums, int target) &#123; int close = 2147483647; int output = 0; if (nums.size() &lt;= 2) return 0; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size() - 2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123; int sum = target - nums[i]; int left = i + 1, right = nums.size() - 1; while (left &lt; right) &#123; int temp = abs(sum - nums[left] - nums[right]); if (temp == 0) return target; else if (temp &lt; close) &#123; close = temp; output = nums[i] + nums[left] + nums[right]; &#125; if (nums[left] + nums[right] == sum) &#123; while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; left++; right--; &#125; else if (nums[left] + nums[right] &gt; sum) right--; else left++; &#125; &#125; &#125; return output; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 15.3Sum]]></title>
    <url>%2F2018%2F12%2F15%2FLeetCode-15-3Sum%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个包含n个整数的数组，从数组中找出三个元素a, b, c使a + b + c = 0。找出数组中所有可能的组合。 注意：返回的集合中不能有重复的三元组 例子: 输入: [-1, 0, 1, 2, -1, -4], 输出: [ [-1, 0, 1], [-1, -1, 2] ] 解题方法首先将数组nums排序，然后使用一个指针i从头遍历数组，对于元素i有以下两种可能： 如果i = 0或者nums[i] != nums[i-1]：使用两个指针left，right分别指向i+1和数组最后一个元素，然后用nums[left] + nums[right]和-nums[i]相比。 如果nums[left] + nums[right] = -nums[i]，就将三个数加入到输出中。 如果nums[left] + nums[right] &gt; -nums[i]，就将right左移。 如果nums[left] + nums[right] &lt; -nums[i]，就将left右移。 i元素与i-1元素相等，则i向后移，避免选取重复三元组。直到所有输出都被找到 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution&#123; public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; &amp;nums) &#123; vector&lt;int&gt; A; vector&lt;vector&lt;int&gt;&gt; B; if (nums.size() &lt;= 2) return B; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size() - 2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123; int sum = 0 - nums[i]; int left = i + 1, right = nums.size() - 1; while (left &lt; right) &#123; if (nums[left] + nums[right] == sum) &#123; A.push_back(nums[i]); A.push_back(nums[left]); A.push_back(nums[right]); B.push_back(A); A.clear(); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++; while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--; left++; right--; &#125; else if (nums[left] + nums[right] &gt; sum) right--; else left++; &#125; &#125; &#125; return B; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 13.Roman to Integer]]></title>
    <url>%2F2018%2F12%2F14%2FLeetCode-13-Roman-to-Integer%2F</url>
    <content type="text"><![CDATA[题目翻译罗马数字是用以下7种字符表示的：I, V, X, L, C, D 和 M. 字符 值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 举例来说，2在罗马数字中用II表示，12用XII表示，27写作XXVII 罗马数字通常将最大数写在最左，较小数写在右面。但是数字4的写法并不是IIII而是IV。因为1在5之前，我们就用5减去它，变成4。同样，这个规则对9也适用，9被写作IX 有六个使用减法的实例： I 可以被放在 V (5) 和 X (10) 之前就变成了 4 和 9. X 可以被放在 L (50) 和 C (100) 之前就变成了 40 和 90. C 可以被放在 D (500) 和 M (1000) 之前就变成了 400 and 900. 给定一个罗马数字，将其转换为整数。输入保证在1到3999的范围内。 例子： 输入: “III” 输出: 3 输入: &quot;IV&quot; 输出: 4 输入: &quot;IX&quot; 输出: 9 输入: &quot;LVIII&quot; 输出: 58 解释: L = 50, V = 5, III = 3. 输入: &quot;MCMXCIV&quot; 输出: 1994 解释: M = 1000, CM = 900, XC = 90 and IV = 4. 解题方法从头遍历输入字符串，对于’I’，’X’，’C’，判断后面的字符，是否是4或者9这种特殊情况。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384int romanToInt(char *s)&#123; int i, count = 0; for (i = 0; i &lt; strlen(s) - 1; i++) &#123; switch (s[i]) &#123; case 'I': if (s[i + 1] == 'V') &#123; count += 4; i++; &#125; else if (s[i + 1] == 'X') &#123; count += 9; i++; &#125; else count++; break; case 'V': count += 5; break; case 'X': if (s[i + 1] == 'L') &#123; count += 40; i++; &#125; else if (s[i + 1] == 'C') &#123; count += 90; i++; &#125; else count += 10; break; case 'L': count += 50; break; case 'C': if (s[i + 1] == 'D') &#123; count += 400; i++; &#125; else if (s[i + 1] == 'M') &#123; count += 900; i++; &#125; else count += 100; break; case 'D': count += 500; break; case 'M': count += 1000; break; default: break; &#125; &#125; if (i == strlen(s) - 1) &#123; if (s[i] == 'I') count += 1; else if (s[i] == 'X') count += 10; else if (s[i] == 'C') count += 100; else if (s[i] == 'V') count += 5; else if (s[i] == 'L') count += 50; else if (s[i] == 'D') count += 500; else count += 1000; &#125; return count;&#125;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 12.Integer to Roman]]></title>
    <url>%2F2018%2F12%2F14%2FLeetCode-12-Integer-to-Roman%2F</url>
    <content type="text"><![CDATA[题目翻译罗马数字是用以下7种字符表示的：I, V, X, L, C, D 和 M. 字符 值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 举例来说，2在罗马数字中用II表示，12用XII表示，27写作XXVII 罗马数字通常将最大数写在最左，较小数写在右面。但是数字4的写法并不是IIII而是IV。因为1在5之前，我们就用5减去它，变成4。同样，这个规则对9也适用，9被写作IX 有六个使用减法的实例： I 可以被放在 V (5) 和 X (10) 之前就变成了 4 和 9. X 可以被放在 L (50) 和 C (100) 之前就变成了 40 和 90. C 可以被放在 D (500) 和 M (1000) 之前就变成了 400 and 900. 给定一个整数，将其转换为罗马数字。输入保证在1到3999的范围内。 例子： 输入: 3 输出: &quot;III&quot; 输入: 4 输出: &quot;IV&quot; 输入: 9 输出: &quot;IX&quot; 输入: 58 输出: &quot;LVIII&quot; 解释: L = 50, V = 5, III = 3. 输入: 1994 输出: &quot;MCMXCIV&quot; 解释: M = 1000, CM = 900, XC = 90 and IV = 4. 解题方法先分别求出给定数字的个、十、百、千位。因为千位不能大于4，所以只用判断个、十、百位的数字。对于这三位的数字有以下几种可能 值等于4或9：直接算出相应的字符，然后加到字符串尾就可以。 值小于4：字符串加上n个相应的字符(例如，个位为3，就加3个’I’；十位为2，就加2个’X’)。 值大于等于5：字符串加上相应位为5的字符(例如，个位加’V’，十位加’L’)，然后重复上一步骤。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution&#123; public: string intToRoman(int num) &#123; int tho = num / 1000; int hun = (num / 100) % 10; int ten = (num / 10) % 10; int one = num % 10; string s = ""; for (int i = 0; i &lt; tho; i++) s += "M"; if (hun == 9) s += "CM"; else if (hun == 4) s += "CD"; else &#123; if (hun &gt;= 5) s += "D"; for (int i = 0; i &lt; hun % 5; i++) s += "C"; &#125; if (ten == 9) s += "XC"; else if (ten == 4) s += "XL"; else &#123; if (ten &gt;= 5) s += "L"; for (int i = 0; i &lt; ten % 5; i++) s += "X"; &#125; if (one == 9) s += "IX"; else if (one == 4) s += "IV"; else &#123; if (one &gt;= 5) s += "V"; for (int i = 0; i &lt; one % 5; i++) s += "I"; &#125; return s; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 6.索引(四)——覆盖索引、索引排序、冗余索引]]></title>
    <url>%2F2018%2F12%2F13%2FMySQL-6-%E7%B4%A2%E5%BC%95-%E5%9B%9B-%E2%80%94%E2%80%94%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E3%80%81%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F%E3%80%81%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[覆盖索引如果一个索引包含(或者说覆盖)所有需要查询的字段的值，就称之为“覆盖索引”。B-Tree索引存放的是字段的值，如果key中包含所有需要查询字段的值，就是覆盖索引。 覆盖索引可以极大地提高性能。因为只需要扫描索引，而无须返回表，有以下好处： 索引条目远小于数据行大小，所以只读取索引可以减少数据访问量。这对缓存的负载很重要，对于I/O密集型应用很有帮助，因为索引比数据小，更容易全部放入内存中。 因为索引是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随即从磁盘读取每一行数据的I/O要少的多。 由于InnoDB的聚簇索引，覆盖索引对于InnoDB很有用。InnoDB的二级索引在叶子节点中保存了行的主键值，如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。 覆盖索引必须要存储索引类的值，所以MySQL只能使用B-Tree索引做覆盖索引。 使用索引扫描来做排序只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向(倒序或正序)都一样时，MySQL才能使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求。 当前导列为常量时，ORDER BY子句可以不满足索引的最左前缀的要求。 下面是一个例子：123456789101112131415161718192021222324252627CREATE TABLE rental ( ... PRIMARY KEY (rental_id), UNIQUE KEY rental_date (rental_date, inventory_id, customer_id), ...);mysql &gt; SELECT ... FROM rental WHERE rental_date = '2005-05-25' ORDER BY inventory_id DESC;-- 可以使用索引排序，因为查询为索引第一列提供了常量条件，而使用第二列进行排序。合在一起便形成了索引最左前缀。mysql &gt; ... WHERE rental_date &gt; '2005-05-25' ORDER BY rental_date, inventory_id;-- 可以使用索引排序，因为ORDER BY使用的两列就是索引的最左前缀。mysql &gt; ... WHERE rental_date = '2005-05-25' ORDER BY inventory_id DESC, customer_id ASC;-- 不可以使用索引排序，因为查询使用了两种不同的排序方向。mysql &gt; WHERE rental_date = '2005-05-25' ORDER BY inventory_id, staff_id;-- 不可以使用索引排序，因为ORDER BY中有不在索引中的列。mysql &gt; WHERE rental_date = '2005-05-25' ORDER BY customer_id;-- 不可以使用索引排序，因为WHERE子句和ORDER BY子句中的列无法组合成索引的最左前缀。mysql &gt; ... WHERE rental_date &gt; '2005-05-25' ORDER BY inventory_id, customer_id;-- 不可以使用索引排序，因为在索引列第一列上是范围条件。mysql &gt; ... WHERE rantal_date = '2005-05-25' AND inventory_id IN (1, 2) ORDER BY customer_id;-- 不可以使用索引排序，因为查询在inventory_id列上有多个等于条件，相当于范围查询。 冗余和重复索引MySQL允许在相同列上创建多个索引，MySQL需要单独维护重复的索引，会影响性能。 重复索引是指相同的列上按照相同的顺序创建的相同类型的索引，应该避免这种索引(如果索引类型不同，不算重复索引)。 冗余索引和重复索引有些不同，如果创建了索引(A，B)，再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引。但是如果创建了(A，B)，再创建索引(B，A)或者(B)就不是冗余索引。因为这两个不是(A，B)的最左前缀索引。不同类型的索引也不会是冗余索引。 大多数情况下不需要冗余索引，但有的时候，如果要扩展索引，可能需要在当前索引上加上一个很长的列(如很长的VARCHAR)，会影响性能，冗余索引可能是较好的选择。 索引下推可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉。 例如执行下列语句，从图中可知索引下推的作用(绿色虚线代表回表) mysql&gt; select * from tuser where name like &apos;张 %&apos; and age=10 and ismale=1; 推荐阅读极客时间：MySQL实战45讲 —— 05深入浅出索引(下) 12参考内容 &gt;&gt; 高性能MySQL第三版 &gt;&gt; 极客时间：MySQL实战45讲 —— 05深入浅出索引(下)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>MySQL性能</tag>
        <tag>覆盖索引</tag>
        <tag>索引排序</tag>
        <tag>冗余索引</tag>
        <tag>索引下推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 6.动态SQL]]></title>
    <url>%2F2018%2F12%2F13%2FMyBatis-6-%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[动态SQLMyBatis的动态SQL包括以下几种元素 元素 作用 备注 if 判断语句 单条件分支判断 choose(when、otherwise) 相当于Java中的case 多条件分支判断 trim(where、set) 辅助元素 用于处理一些SQL拼装问题 foreach 循环语句 在in语句等列举条件常用 if元素例如，根据角色名称(roleName)去查找角色，但角色名称是一个可填可不填的条件，不填写的时候则它不作为查询条件。 123456&lt;select id = "findRoles" parameterType = "string" resultMap = "roleResultMap"&gt; select role_no, role_name, note from t_role where 1=1 &lt;if test = "roleName != null and roleName != ''"&gt; and role_name like #&#123;roleName&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise元素例如， 当角色编号不为空，则只用角色编号作为条件查询。 当角色编号为空，而角色名称不为空，则角色名称作为条件进行模糊查询。 当角色编号和角色名称都为空，则要求角色备注不为空。 123456789101112131415&lt;select id = "findRoles" parameterType = "role" resultMap = "roleResultMap"&gt; select role_no, role_name, note from t_role where 1=1 &lt;choose&gt; &lt;when test = "roleNo != null and roleNo != ''"&gt; AND role_no = #&#123;roleNo&#125; &lt;/when&gt; &lt;when test = "roleName != null and roleName != ''"&gt; AND role_name like #&#123;roleName&#125; &lt;/when&gt; &lt;otherwise&gt; AND note is not null &lt;/otherwise&gt; &lt;/choose&gt;&lt;select&gt; trim、where、set元素前面的例子中，都存在一个条件“1=1”，因为若是没有这个条件，语句就会产生错误(where and)。如果觉得“1=1”显得很奇怪，可以使用where元素。12345678&lt;select id = "findRoles" parameterType = "string" resultMap = "roleResultMap"&gt; select role_no, role_name, note from t_role &lt;where&gt; &lt;if test = "roleName != null and roleName != ''"&gt; and role_name like #&#123;roleName&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这样当where元素里面的条件成立时，才会加入where关键字到SQL语句中。 有时需要去掉一些SQL特殊语法，例如，and、or。可以使用trim来达到目的。12345678&lt;select id = "findRoles" parameterType = "string" resultMap = "roleResultMap"&gt; select role_no, role_name, note from t_role &lt;trim prefix = "where" prefixOverrides = "and"&gt; &lt;if test = "roleName != null and roleName != ''"&gt; and role_name like #&#123;roleName&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; trim元素意味着要去掉一些特殊字符，prefix代表语句前缀，prefixOverrides则是要去掉的那串字符串。 现实场景中，经常存在更新一行数据其中一个字段的可能。可以使用set元素实现123456789101112&lt;update id = "updateRole" parameterType = "role"&gt; update t_role &lt;set&gt; &lt;if test = "roleName != null and roleName != ''"&gt; role_name = #&#123;roleName&#125;, &lt;/if&gt; &lt;if test = "note != null and note != ''"&gt; note = #&#123;note&#125; &lt;/if&gt; &lt;/set&gt; where role_no = #&#123;roleNo&#125;&lt;/update&gt; foreach元素作用是遍历集合，例如 1234567&lt;select id = "findUserBySex" resultType = "user"&gt; select * from t_user where sex in &lt;foreach item = "sex" index = "index" collection = "sexList" open = "(" separator ="," close = ")"&gt; #&#123;sex&#125; &lt;/foreach&gt;&lt;/select&gt; collection：配置的sexList是传递进来的参数名称，可以是一个数组或者List、Set等集合。 item：配置的是循环中当前的元素。 index：配置的是当前元素在集合的位置下标。 open和close：以什么符号将这些集合元素包装起来。 separator：各个元素的间隔符。 bind元素方便进行模糊查询，与数据库无关。例如，想要按角色名进行模糊查询123456&lt;select id = "findRole" resultType = "RoleBean"&gt; &lt;bind name = "pattern" value = "'%' + _parameter + '%'"/&gt; SELECT id, role_name as roleName, create_date as createDate, end_date as endDate, end_flag as endFlag, note FROM t_role where role_name like #&#123;pattern&#125;&lt;/select&gt; 这里的“_parameter”代表的就是传递进来的参数，它和通配符连接后，赋给了pattern，然后就可以在select语句中使用这个变量进行模糊查询 还可以传递多个参数123456789/** * 查询角色 * @param roleName 角色名称 * @param note 备注 * @return 符合条件的角色 */public List&lt;RoleBean&gt; findRole(@Param("roleName") String roleName, @Param("note") String note); 1234567&lt;select id = "findRole" resultType = "RoleBean"&gt; &lt;bind name = "pattern_roleName" value = "'%' + roleName + '%'"/&gt; &lt;bind name ="pattern_note" value = "'%' + note + '%"/&gt; SELECT id, role_name as roleName, create_date as createDate, end_date as endDate, end_flag as endFlag, note FROM t_role where role_name like #&#123;pattern_roleName&#125; and note like #&#123;pattern_note&#125;&lt;/select&gt; 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>动态SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 5.映射器(四)——级联]]></title>
    <url>%2F2018%2F12%2F08%2FMyBatis-5-%E6%98%A0%E5%B0%84%E5%99%A8-%E5%9B%9B-%E2%80%94%E2%80%94%E7%BA%A7%E8%81%94%2F</url>
    <content type="text"><![CDATA[级联在数据库中有许多一对多和一对一的关系，例如一个角色可以分配给多个用户，也可以只分配给一个用户。我们通常需要一个单独的表保存所有角色，一个表保存用户和角色的关系，当我们想把用户信息和角色信息同时显示时，我们同行使用这样的SQL1234select r.*, u.* from t_role as r join t_user_role as ur on r.id = ur.role_id inner join t_user as u on ur.user_id = u.id where r.id = #&#123;id&#125; 通过这个语句我们可以查询到角色和他的用户信息，并希望将结果集存储到user(JavaBean)的集合中。但是user中又没有role这一属性(因为JavaBean和数据库表对应)。我们就需要用到级联。 级联中存在三种对应关系： 一对一的关系：在MyBatis中表示为association 一对多的关系：在MyBatis中表示为collection 多对多的关系：在MyBatis中表示为discriminator 使用如下的关系模型来解释 其中学生证和学生是一对一关系；学生和课程成绩是一对多的关系，一个学生可以有多门课程；课程和成绩也是一对多的关系；健康表是一对多的关系 一对一级联(association)：学生(Student)与学生证(Selfcard)应该是一对一关系。所以我们一般会创建StudentBean和StudentSelfcardBean两个POJO对象。并且Student的POJO中有一个类型为StudentSelfcardBean的属性studentSelfcard，这样便形成了级联。 然后需要建立Student的映射器StudentMapper和StudentSelfcard的映射器StudentSelfcardMapper。并且在StudentSelfcardMapper中提供一个findStudentSelfcardByStudentId的方法，代码如下所示 12345678910111213141516&lt;mapper namespace = "StudentSelfcardMapper"&gt; &lt;resultMap id = "studentSelfcardMap" type = "StudentSelfcardBean"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "studentId" column = "student_id"/&gt; &lt;result property = "native_" column = "native"/&gt; &lt;result property = "issueDate" column = "issue_date"/&gt; &lt;result property = "endDate" column = "end_date"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;/resultMap&gt; &lt;select id = "findStudentSelfcardByStudentId" parameterType = "int" resultType = "studentSelfcardMap"&gt; select id, student_id, native, issue_data, end_date, note from t_student_selfcard where student_id = #&#123;student_id&#125; &lt;/select&gt;&lt;/mapper&gt; 这样配置完后，就可以在StudentMapper中使用StudentSelfcardMapper进行级联，代码如下 12345678910111213141516&lt;mapper namespace = "StudentMapper"&gt; &lt;resultMap id = "studentMap" type = "StudentBean"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "cnname" column = "cnname"/&gt; &lt;result property = "sex" column = "sex"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;association property ="studentSelefCard" column = "id" select = "StudentSelefcardMapper.findStudentSelfcardByStudentId"/&gt; &lt;/resultMap&gt; &lt;select id = "getStudent" parameterType = "int" resultType = "studentMap"&gt; select id, cnname, sex, note from t_student where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 这样，MyBatis中的association语句，就将column指定的参数(这里是student.id)传递给了select属性定义的方法(这里是findStudentSelfcardByStudentId)。如果多个参数，使用逗号分隔。 getStudent实际查找过程为：根据传进来的id，先查到Student信息，然后根据其id，查询出学生证信息，并将结果级联。 一对多级联(collection)：例如，每个学生都可能有多门课程，而在学生确定的前提下，该学生的一门成绩只对应一门课程。所以有两个级联，一个是学生和成绩的级联，是一对多的关系；还有课程成绩和课程的级联，是一对一的关系(注意是在学生确定的前提下)。 这个时候，我们需要建立一个LectureBean来记录课程，再建立一个StudentLectureBean来记录成绩，并且StudentLectureBean有一个类型为LectureBean属性的lecture。代码如下：1234567891011121314151617public class LectureBean &#123; private Integer id; private String lectureName; private String note; //... setter and getter ...&#125;public class StudentLectureBean &#123; private int id; private Integer studentId; private LectureBean lecture; private BigDecimal grade; private String note; //... setter and getter ...&#125; 为了能读到成绩，在上文提到的StudentBean中添加一个类型为List的属性，studentLectureList。12345678910111213141516171819202122232425262728293031323334353637&lt;mapper namespace = "StudentMapper"&gt; &lt;resultMap id = "studentMap" type = "StudentBean"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "cnname" column = "cnname"/&gt; &lt;result property = "sex" column = "sex"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;association property = "studentSelfcard" column = "id" select = "StudentSelfcardMapper.findStudentSelfcardByStudentId"/&gt; &lt;collection property = "studentLectureList" column = "id" select = "StudentLectureMapper.findStudentLectureByStudentId"/&gt; &lt;/resultMap&gt; &lt;select id = "getStudent" parameterType = "int" resultMap = "studentMap"&gt; select id, cnname, sex, note from t_student where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;&lt;mapper namespace = "StudentLectureMapper"&gt; &lt;resultMap id = "studentLectureMap" type = "StudentLectureBean"&gt; &lt;id property = "id" column ="id"/&gt; &lt;result property = "studentId" column = "student_id"/&gt; &lt;result property = "grade" column = "grade"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;association property = "lecture" column = "lecture_id" select = "LectureMapper.getLecture"/&gt; &lt;/resultMap&gt; &lt;select id = "findStudentLectureByStudentId" parameterType = "int" resultMap = "studentLectureMAp"&gt; select id, student_id, lecture_id, grade, note from t_student_lecture where student_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;&lt;mapper namespace = "LectureMapper"&gt; &lt;select id = "getLecture" parameterType = "int" resultType = "LectureBean"&gt; select id, lecture_name as lectureName, note from t_lecture where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 多对多级联(discriminator)：也叫鉴别器级联，在特定条件下使用不同的POJO。比如例子中的健康情况表。可以根据学生的性别属性，决定关联男性/女性健康表，相当于Java中的switch语句。 首先需要两个健康情况POJO，分别存储男性和女性健康表的基础信息。123456789public class MaleStudentBean extends StudentBean &#123; private List&lt;StudentHealthMaleBean&gt; studentHealthMaleList = null; //... setter and getter ...&#125;public class FemaleStudentBean extends StudentBean &#123; private List&lt;StudentHealthFemaleBean&gt; studentHealthFemaleList = null; //... setter and getter ...&#125; 这样就可以根据StudentBean中的sex属性，来判断使用MaleStudentBean还是FemaleStudentBean的对象了。注意这里存储时，使用int类型的1，2代替男女。 123456789101112131415161718192021222324252627282930&lt;mapper namespace = "StudentBean"&gt; &lt;resultMap id = "studentMap" type = "StudentBean"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "cnname" column = "cnname"/&gt; &lt;result property = "sex" column = "sex"/&gt; &lt;result property = "note" column = "note"/&gt; &lt;association property = "studentSelfcard" column = "id" select = "StudentSelfcardMapper.findStudentSelfcardByStudentId"/&gt; &lt;collection property = "studentLectureList" column = "id" select = "StudentLectureMapper.findStudentLectureByStudentId"/&gt; &lt;discriminator javaType = "int" column = "sex"&gt; &lt;case value = "1" resultMap = "maleStudentMap"/&gt; &lt;case value = "2" resultMap = "femaleStudentMap"/&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;select id = "getStudent" parameterType = "int" resultMap = "studentMap"&gt; select id, cnname, sex, note from t_student where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id = "maleStudentMap" type = "MaleStudentBean" extends = "studentMap"&gt; &lt;collection property = "studentHealthMaleList" column = "id" select = "StudentHealthMaleMapper.findStudentHealthMaleByStudentId"/&gt; &lt;/resultMap&gt; &lt;resultMap id = "femaleStudentMap" type = "FemaleStudentBean" extends = "studentMap"&gt; &lt;collection property = "studentHealthMaleList" column = "id" select = "StudentHealthFemaleMapper.findStudentHealthMaleByStudentId"/&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 级联的优点与缺点：优点： 可以方便快捷的获取数据 缺点： 多层关联的可读性差 有时不需要获取所有数据，例如只想获得成绩，不想查看健康情况。或造成性能下降。 表很多时，级联关系可能很复杂。会产生N+1问题(例如，每次取一个Student，都要查看n个成绩)。 延迟加载：MyBatis引入该功能来处理 N+1 问题。一开始并不取出级联数据，只有当使用了它才发送SQL去取回数据。例如一开始只取出学生的基本情况，使用成绩时，MyBatis才发送SQL去查看学生成绩。由于一直没有使用健康情况，所以MyBatis也不会去查看健康情况。 MyBatis属性中通过设置lazyLoadingEnabled和aggressiveLazyLoading来配置该功能： lazyLoadingEnabled：是否开启延迟加载功能。 aggressiveLazyLoading：对任意延迟属性的调用会使带有延迟加载属性的对象完整加载。当它为“true”时，会按层级加载，当它为“false”时，则按需加载(默认为true)。 默认情况下，开启lazyLoadingEnabled后，是按层级延迟加载的，如图可视，当访问课程成绩时，学生证信息也会被加载。要改变这个特性，需要用到aggressiveLazyLoading，当它为“true”时，会按层级加载，当它为“false”时，则按需加载。 1234567891011&lt;!-- 全局设置 --&gt;&lt;setting name = "aggressiveLazyLoading" value = "false"/&gt;&lt;!-- 局部设置 --&gt;&lt;!-- fetchType = "lazy"为按需加载 --&gt;&lt;association property = "studentSelfcard" column = "id" fetchType = "lazy" select = "StudentSelfcardMapper.findStudentSelfcardByStudentId"/&gt;&lt;!-- fetchType = "eager"为按层级加载 --&gt;&lt;association property = "studentSelfcard" column = "id" fetchType = "eager" select = "StudentSelfcardMapper.findStudentSelfcardByStudentId"/&gt; 延迟加载的原理是通过动态代理实现的。 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
        <tag>级联</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 4.映射器(三)——sql/resultMap元素]]></title>
    <url>%2F2018%2F12%2F08%2FMyBatis-4-%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%89-%E2%80%94%E2%80%94sql-resultMap%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[sql元素可以定义一串SQL语句，在其他语句(e.g., select)中可以引用。 例如， 1234567891011&lt;sql id = "role_columns"&gt; id, role_name, note&lt;/sql&gt;&lt;select parameterType = "long" id = "getRole" resultMap = "roleMap"&gt; select &lt;include refid = "role_columns"/&gt; from t_role where id = #&#123;id&#125;&lt;/select&gt;&lt;select parameterType = "map" id = "findRoles"&gt; select id, role_name, note from t_role where rold_name like #&#123;roleName&#125; and note like #&#123;note&#125;&lt;/select&gt; 这个例子中，用sql元素定义了role_columns，并使用refid元素进行引用。 也可以制定参数来使用1234567891011&lt;sql id = "role_columns"&gt; #&#123;prefix&#125;.role_no, #&#123;prefix&#125;.role_name, #&#123;prefix&#125;.note&lt;/sql&gt;&lt;select parameterType = "string" id = "getRole" resultMap = "roleResultMap"&gt; select &lt;include refix = "role_columns"&gt; &lt;property name = "prefix" value = "r"/&gt; &lt;/include&gt; from t_role r where role_no = #&#123;roleNo&#125;&lt;/select&gt; 还可以给refid一个参数值，由程序制定引入SQL123&lt;sql id = "someinclude"&gt; select * from &lt;include refid = "$&#123;tableName&#125;"/&gt;&lt;/sql&gt; resultMap结果映射集resultMap 元素的构成resultMap元素里的元素 12345678910111213&lt;resultMap&gt; &lt;constructor&gt; &lt;idArg/&gt; &lt;arg/&gt; &lt;/constructor&gt; &lt;id/&gt; &lt;result/&gt; &lt;association/&gt; &lt;collection/&gt; &lt;discriminator&gt; &lt;case/&gt; &lt;discriminator/&gt;&lt;/resultMap&gt; constructor：用来配置构造方法，一个POJO可能可能不存在没有参数的构造方法，这个时候可以用constructor进行配置。例如， 1234&lt;constructor&gt; &lt;idArg column = "id" javaType = "int"/&gt; &lt;arg column = "role_name" javaType = "string"/&gt;&lt;/constructor&gt; id：表示哪个列是主键，允许多个主键，多个主键称为联合主键。 result：配置POJO到SQL列名的映射关系。 result元素和id元素的属性 元素名称 说明 备注 property 映射到列结果的字段或属性。如果POJO的属性匹配是存在的，和给定SQL列名(column元素)相同的，那么MyBatis就会映射到POJO上 可以使用导航式字段，比如访问一个学生对象(Student)需访问学生证(selfcard)的发证日期(issueDate),那么我们可以写成selfcard.issueDate column 这里对应的是SQL的列 - javaType 配置Java的类型 可以是特定的类完全限定名或者MyBatis上下文的别名 jdbcType 配置数据库类型 JDBC的类型 typeHandler 类型处理器 允许使用特定的处理器来覆盖MyBatis默认处理器，需要制定jdbcType和javaType的相互转化规则 使用map存储结果集123&lt;select id = "findColorByNote" parameterType = "string" resultType = "map"&gt; select id, color, note from t_color where note like #&#123;note&#125;&lt;/select&gt; 可读性比较差，并不推荐 使用POJO存储结果集配置代码如图 12345&lt;resultMap id = "roleResultMap" type = "Role"&gt; &lt;id property = "id" column = "id"/&gt; &lt;result property = "roleName" column = "role_name"/&gt; &lt;result property = "note" column = "note"/&gt;&lt;/resultMap&gt; resultMap中的id属性：代表这个resultMap的标识 resultMap中的type属性：代表需要映射的POJO id元素：表示主键 property：表示POJO属性名称 column：表示数据库SQL列名 使用resultMap的代码123&lt;select parameterType = "long" id = "getRole" resultMap = "roleResultMap"&gt; select id, note_name, note from t_role where id = #&#123;id&#125;&lt;/select&gt; 推荐阅读基于MyBatis实现的JavaWeb项目源码-github 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 5.索引(三)——聚簇索引]]></title>
    <url>%2F2018%2F12%2F04%2FMySQL-5-%E7%B4%A2%E5%BC%95-%E4%B8%89-%E2%80%94%E2%80%94%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[聚簇索引聚簇索引是一种数据存储方式，InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中(叶子页包含了行的全部数据，节点页只包含了索引列)。“聚簇”表示数据行和相邻的键值紧凑的存储在一起。一个表只能有一个聚簇索引。 InnoDB会选择主键列进行聚簇索引，如果没有定义主键，InnoDB会选择唯一的非空索引代替。如果还是没有，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。 InnoDb的普通索引(二级索引)的叶子结点中存放的是主键的值，所以需要先查询普通索引(二级索引)的叶子节点找到对应的主键值，然后再根据主键值去聚集索引中查询到对应的数据。 非聚集索引的索引与数据是存在不同文件的。 聚簇索引优点： 可以把相关的数据保存在一起，例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数数据页就能获取某个用户的全部邮件，减少磁盘I/O次数。 数据访问更快：聚簇索引同时将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据要比非聚簇索引更快。 使用覆盖索引扫描的查询可以直接使用节点中的主键值。 聚簇索引缺点： 聚簇索引最大限度地提高了I/O密集型应用的性能。如果数据全放放在内存中，那么聚簇索引就没了优势。 插入速度严重依赖于插入顺序。按照主键顺序插入最快。 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳改行，这就是一次页分裂操作。页分裂会导致表占用更多磁盘空间 当行比较稀疏，或者有由于页分裂导致数据存储不连续的时候，可能会导致全表扫描变慢。 二级索引(费聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。 二级索引访问需要两次索引查找，而不是一次(因为二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值)。 InnoDB和MyISAM数据分布对比对于以下这个表，InnoDB和MyISAM存储方式不同：1234567CREATE TABLE layout_test ( col1 int NOT NULL, col2 int NOT NULL, PRIMARY KEY(col1), KEY(col2)); MyISAM的数据分布MyISAM按照数据插入的顺序存储在磁盘上，如图所示。因为这里行是定长的，所以MyISAM可以从表的开头跳过所需字节直接找到需要的行。可以看出MyISAM的主键索引和其他索引在结构上没有不同。 InnoDB的数据分布如图所示，可以发现图中显示了整个表，而不仅仅是索引。因为在InnoDB中，聚簇索引就是表，不需要像MyISAM那样需要独立的行存储。 聚簇索引的每一个叶子结点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列(在这里是col2)。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。 另一点和MyISAM不同的是，InnoDB的二级索引和聚簇索引并不相同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样会减少当出现行移动或者数据页分裂(上文有提到)时二级索引的维护工作。使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动时无需更新二级索引中的这个“指针”。 在InnoDB表中按主键顺序插入行尽量按主键顺序插入行，最简单的方法使用自增列(AUTO_INCREMENT)。因为这样填充时，当页满时，下一条记录就可以写在新页中。而如果无序插入，那么每次都要为行找到合适的位置，会增加许多额外工作。有以下一些缺点 写入的目标页可能已经刷新到磁盘上，并从缓存中移除，InnoDB在插入前必须先找到并从磁盘读取目标页到内存中，导致大量随机I/O。 因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页，而不是一个页。 频繁的页分裂，页会变得稀疏并被不规则地填充，最终会有碎片。 对于高并发工作负载，按主键顺序可能导致性能下降。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>MySQL性能</tag>
        <tag>InnoDB</tag>
        <tag>MyISAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 19.Remove Nth Node From End of List]]></title>
    <url>%2F2018%2F12%2F04%2FLeetCode-19-Remove-Nth-Node-From-End-of-List%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个链表和一个整数n，返回链表倒数第n个结点。 例子： 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. 输出: 1-&gt;2-&gt;3-&gt;5. 备注: n永远是有效的。 要求一次遍历。 解题方法使用两个指针p，q分别指向链表头。p先走n次，如果p走到头就说明n大于等于链表长度，就删除头结点(所以新建了一个h指向头结点，便于删除头结点)。如果p没有走到头，就让p和q一起走，直到p走到头，q指向的就是要删除的结点。 代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *h = new ListNode(0); h-&gt;next = head; ListNode *p =h ,*q=h; while(n--&amp;&amp;p!=NULL) p = p-&gt;next; if(n&gt;0) return NULL; while(p&amp;&amp;p-&gt;next)&#123; p = p-&gt;next; q = q-&gt;next; &#125; q-&gt;next= q-&gt;next-&gt;next; return h-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 4.索引(二)——高性能索引]]></title>
    <url>%2F2018%2F12%2F04%2FMySQL-4-%E7%B4%A2%E5%BC%95-%E4%BA%8C-%E2%80%94%E2%80%94%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[如果使用高性能索引独立的列：如果查询中的列不是独立的，则MySQL不会使用索引。“独立的列” 指的是索引列不能是表达式的一部分，也不能是函数的参数。 例如， 1mysql &gt; SELECT actor_id FROM actor where actor_id +1 =5; 这个查询就无法使用actor_id列的索引，因为它是表达式的一部分。但是如果我们把where的表达式写成actor_id = 4 就可以使用这列的索引了。所以，在写where语句时，尽量将索引列单独放在比较符号的一侧。 前缀索引和索引选择性：索引的选择性是指：不重复的索引值(基数，cardinality)和数据表的记录总数(#T)的比值，范围从 1/#T 到 1 之间。索引的选择性越高，则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。 前缀索引：对于一些很长的字符列，通常只索引开始的部分字符。例如BLOB、TEXT或很长VARCHAR，必须使用前缀索引，因为MySQL索引长度有限制。选择前缀索引时，应该让前缀索引的“基数”接近于完整列的“基数”。前缀索引的缺点是无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。 如何计算索引选择性：下面给出一个例子，演示如何计算完整列和不同长度前缀的的选择性： 1234567891011mysql &gt; CREATE TABLE city_demo (city VARCHAR(50) NOT NULL);-- 随机向city_demo中插入许多城市(可重复)--计算完整列的选择性mysql &gt; SELECT COUNT(DISTINCT city) / COUNT(*) FROM city_demo;--计算不同长度前缀的选择性(下面例子为长度为3，4，5的前缀)mysql &gt; SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3, COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4, COUNT(DISTINCT LEFT(city, 5))/COUNT(*) AS sel5 FROM city_demo 如何创建前缀索引：12--创建前缀长度为5的索引mysql &gt; ALTER TABLE city_demo ADD KEY (city(5)); 特殊用处：可以用来做后缀索引，其基本原理是把想要存储的信息(如电子邮件地址)反转后存储，然后建立前缀索引。这样可以用来查找电子邮件域名等。 多列索引：一个常见的错误是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。为每个列创建独立的索引，在WHERE语句中需要多个列的条件时，并不是最优的结果。 多列索引中列正确的顺序依赖于使用该索引的查询，并且应该更好地满足排序和分组的需要。索引首先按照最左列进行排序，其次是第二列，等等(对于B-Tree索引来说)。 将选择性最高的列放在前面通常是很好的。这对于优化WHERE 条件很有帮助，但是并不会提升排序和分组的效率。性能不止依赖于列的选择性，也和查询条件的值的分布有关。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>MySQL性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 14.Longest Common Prefix]]></title>
    <url>%2F2018%2F12%2F03%2FLeetCode-14-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[题目翻译给定一组字符串，找到这些字符串的最小前缀。 解题方法这些字符串的前缀的最大长度不可能超过这些字符串中最小的那个的长度。所以可以先找到那个最小的作为暂时的最大前缀，然后挨个与其他字符串比较，出现不一样的字符就删除该字符及之后的所有字符。 代码123456789101112131415161718192021class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size()==0) return ""; string pattern = strs[0]; for(int i = 1;i&lt;strs.size();i++) pattern = pattern.size()&lt;strs[i].size()?pattern:strs[i]; for(int i = 0;i&lt;strs.size();i++)&#123; for(int j = 0;j&lt;pattern.size();j++)&#123; if(strs[i][j]!=pattern[j])&#123; pattern.erase(pattern.begin()+j,pattern.end()); break; &#125; &#125; &#125; return pattern; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 11.Container With Most Water]]></title>
    <url>%2F2018%2F12%2F03%2FLeetCode-11-Container-With-Most-Water%2F</url>
    <content type="text"><![CDATA[题目翻译给定n个数字代表n条线段，每个线段的下标为它的横坐标，值为它的高度。使用两个线段和x轴组成一个装水的容器，求出最大的容器。你可以假设容器都是直的，并且n大于等于2。 解题方法既然是装水的容器，那么高度只能由两个线段中较短的那个决定，所以用i, j表示数组里两个数，可知 $容积=min(height[i], height[j])*abs(j-i)$。很容易可以想到暴力求解算法。但是可以进行优化。首先i，j分别为数组两端数字，并向中间移动。可知这时i，j之间影响容量大小的为短的那条边，因为高的那条边向里移动容积一定会减少。所以只要每次向里移动较短的那条边就可以了。 代码123456789101112131415161718192021class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int i = 0, j = height.size()-1; int max = 0; int cur = 0; while(i&lt;j)&#123; if(height[i]&lt;height[j])&#123; cur = height[i]*(j-i); i++; &#125; else&#123; cur = height[j]*(j-i); j--; &#125; max = max&gt;cur?max:cur; &#125; return max; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 3.映射器(二)——insert/update/delete元素]]></title>
    <url>%2F2018%2F12%2F03%2FMyBatis-3-%E6%98%A0%E5%B0%84%E5%99%A8-%E4%BA%8C-%E2%80%94%E2%80%94insert-update-delete%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[insert元素MyBatis会在执行插入之后返回一个整数，以表示进行操作后插入的记录数。 属性名称 说明 备注 id 它和Mapper的命名空间组合起来是唯一的，提供给MyBatis调用(其实就是Dao中对应的方法名) 如果命名空间和id组合起来不唯一，MyBatis将抛出异常 parameterType 传入参数的类型，例如long，String等(可以给出类的全命名，也可以给出类的别名，但别名必须是MyBatis内部定义或自定义的) 可以选择JavaBean、Map等复杂的参数类型 parameterMap 即将废弃，不建议使用 - flushCache 调用SQL后，是否要求MyBatis清空之前查询的本地缓存和二级缓存 true/false，默认为false timeout 设置超时参数，等超时的时候将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数 statementType 告诉MyBatis使用哪个JDBC的Statement工作，取值为STATEMENT(Statement)、CallableStatement 默认值为PREPARED keyProperty 表示以哪个列作为属性的主键，不能和keyColumn同时使用 设置哪个列为主键，联合主键可以用逗号隔开 useGenerateKeys 这会令MyBatis使用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键，例如，MySQL和SQLSever自动递增字段，Oracle的序列等，但是使用它就必须要给KeyProperty或者keyColumn赋值 true/false。默认为false keyColumn 指明第几列是主键，不能和keyProperty同时使用，只接受整形参数 和keyProperty一样，联合主键可以用逗号隔开 databaseId 取决于数据库厂商 - lang 自定义语言，可以使用第三方语言 - 插入实例：123&lt;insert parameterType = "role" id = "insertRole"&gt; insert into t_role(role_name, note) values(#&#123;roleName&#125;, #&#123;note&#125;)&lt;/insert&gt; 主键回填和自定义：MySQL中的主键可能需要根据一些特殊规则声称，例如自增字段，再插入后我们需要获得该主键。可以使用keyProperty属性指定哪个是主键字段，同时使用useGeneratedKeys属性告诉MyBatis这个主键是否使用数据库内置策略生成。例如，下面的例子中，id为表t_role的自增字段 123&lt;insert id = "insertRole" parameterType = "role" useGeneratedKeys = "true" keyProperty = "id"&gt; insert into t_role (role_name, note) values(#&#123;roleName&#125;, #&#123;note&#125;)&lt;/insert&gt; 我们传入的role对象，无需设置id的值，MyBatis会根据数据库的设置自动处理，在处理完毕后，MyBatis会自动回填MySQL数据库生成的id值到传入的JavaBean中。 实际工作中，还可能有一些更复杂的要求。例如，如果表t_role中没有记录，则设置id=1，否则取当前最大id加2，成为新的主键。这时需要使用selectKey元素处理 123456&lt;insert id = "insertRole" parameterType = "role" useGeneratedKeys = "true" keyProperty = "id"&gt; &lt;selectKey keyProperty = "id" resultType = "int" order = "BEFORE"&gt; select if ( max(id) is null, 1, max(id) + 2 ) as newId from t_role &lt;/selectKey&gt; insert into t_role(id, role_name, note) values (#&#123;id&#125;, #&#123;roleName&#125;, #&#123;note&#125;)&lt;/insert&gt; update元素和insert一样，MyBatis执行完update元素后会返回一个整数，代表进行更新的记录数。 更新实例：123456&lt;update parameterType = "role" id = "updateRole"&gt; update t_role set role_name = #&#123;roleName&#125;, note = #&#123;note&#125; where id = #&#123;id&#125;&lt;/update&gt; delete元素和insert一样，MyBatis执行完delete元素后会返回一个整数，代表进行删除的记录数。 删除实例：123&lt;delete id = "delete" parameterType = "long"&gt; delete from t_role where id = #&#123;id&#125;&lt;/delete&gt; 特殊字符串替换和处理优势我们想要传递SQL语句本身，而不是SQL所需的参数。例如，我们可能想要传递SQL列名，可以使用$符号实现。 1select $&#123;columns&#125; from t_tablename 但是这样对于SQL而言是不安全的。 推荐阅读基于MyBatis实现的JavaWeb项目源码-github 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 9.Palindrome Number]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-9-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[题目翻译求给定的数是否为回文数。 解题方法使用一个新数将原数反转，要是相等就是回文数，注意负数没有回文数。 代码1234567891011121314class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0) return 0; int newnum=0; int temp=x; while(temp)&#123; newnum=newnum*10+temp%10; temp/=10; &#125; return newnum==x; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 8.String to Integer]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-8-String-to-Integer%2F</url>
    <content type="text"><![CDATA[题目翻译实现atoi函数，将字符串变为整数。 输入的开头可能存在许多无用的空格，需要忽视掉。 空格后可能包含代表数正负的 ‘+’ 号和 ‘-‘ 号。 如果遇到不符合的字符就返回0。 如果溢出就按溢出方向返回INT_MAX (2147483647) 或 INT_MIN (-2147483648) 解题方法跳过开头的空格，然后判断是否存在 ‘+’ 号和 ‘-‘ 号。然后按序转换，遇到不符合字符退出。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int myAtoi(string str) &#123; if(str.size()==0) return 0; long long res = 0; int i = 0; for(i = 0;i&lt;str.size();i++)&#123; if(str[i]!=' ') break; &#125; if(i==str.size()) return 0; int flag = str[i]=='-'?-1:1; if(str[i]=='+'||str[i]=='-') i++; for(i;i&lt;str.size();i++)&#123; if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')&#123; res = res*10 + (str[i]-'0'); if(res*flag&gt;INT_MAX||res*flag&lt;INT_MIN) return flag&gt;0?INT_MAX:INT_MIN; &#125;else break; &#125; return res*flag; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 7.Reverse Integer]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个32位有符号整数，将这个数翻转。 例子： 输入：123 输出：321 输入：-80 输出：-8 注意：只考虑32位数，如果翻转后数字溢出返回0。 解题方法将原数每次模10加到输出上然后乘以10。 代码123456789101112class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while(x)&#123; res = res*10 + x%10; x/=10; &#125; return (res &lt; INT_MIN || res &gt; INT_MAX) ? 0 : res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 6.ZigZag Conversion]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-6-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[题目翻译给定字符串 “PAYPALISHIRING” 与特定数字numRows = 3，字符串实际显示方式为 P A H N A P L S I I G Y I R 从左到右，从上到下输出它们，结果为 “PAHNAPLSIIGYIR”。 解题方法通过找规律可得原字符串 n的值为 2 * (numRows - 1)。 第一行的字符在原字符串的位置为(0, 0+n, 0+2n…)。 第二行为(1, 1+n-2, 1+n, 1+2(n-2), 1+2n…)。 最后一行的值为( numRows-1, numRows-1+n, numRows-1+2n…)。 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows&gt;=s.size()||numRows&lt;=1) return s; string res(s); int flag = (numRows - 1)&lt;&lt;1; int m = flag, n = flag - m; int level = 0; int total = 0; while(m&gt;=0)&#123; int i = level; while(i&lt;s.size())&#123; if(m!=0)&#123; res[total++] = s[i]; i+=m; &#125; if(i&lt;s.size()&amp;&amp;n!=0)&#123; res[total++] = s[i]; i+=n; &#125; &#125; level++; m-=2; n+=2; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>数学规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 2.映射器(一)——select元素]]></title>
    <url>%2F2018%2F12%2F02%2FMyBatis-2-%E6%98%A0%E5%B0%84%E5%99%A8-%E4%B8%80-%E2%80%94%E2%80%94select%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[映射器MyBatis是针对映射器构造的SQL轻量级框架，通过配置生成对应的JavaBean返回给调用者。 映射器的主要元素映射器的配置 元素名称 描述 备注 select 查询语句 可以自定义参数，返回结果集 insert 插入语句 执行后返回一个整数，代表插入的条数 update 更新语句 执行后返回一个整数，代表更新的条数 delete 删除语句 执行后返回一个整数，代表删除的条数 parameterMap 定义参数映射关系 即将被删除的元素，不建议使用 sql 允许定义一部分的SQL，然后在多个地方引用 例如，一张表列名，可以一次定义，在多个SQL语句中使用 resultMap 用来描述从数据库结果集中加载的对象 提供映射规则 cache 给定命名空间的缓存配置 - cache-ref 其他命名空间缓存配置的引用 - select元素select元素负责从数据库中读出数据，并且组装数据。执行前，需要定义参数，例如int，float等简单参数类型，也可以是JavaBean、Map等复杂类型。执行后，MyBatis提供了自动映射可以把结果集绑定到JavaBean上。select配置如下： 元素 说明 备注 id 它和Mapper的命名空间组合起来是唯一的，提供给MyBatis调用(其实就是Dao中对应的方法名) 如果命名空间和id组合起来不唯一，MyBatis将抛出异常 parameterType 传入参数的类型，例如long，String等(可以给出类的全命名，也可以给出类的别名，但别名必须是MyBatis内部定义或自定义的) 可以选择JavaBean、Map等复杂的参数类型 parameterMap 即将废弃，不建议使用 - resultType 返回的类型。定义类的全路径，在允许自动匹配的情况下，结果集将通过JavaBean的规范映射；也可以定义为int、float、double等参数；不能和resultMap同时使用 - resultMap 可以执行强大的映射功能，通过该元素，可以自定义映射，不能与resultType同时使用 可以配置映射规则，typeHandler等 flushCache 调用SQL后，是否要求MyBatis清空之前查询的本地缓存和二级缓存 true/false，默认为false useCache 启动二级缓存的开关，是否要求MyBatis将此次结果缓存 true/false，t默认为true timeout 设置超时参数，等超时的时候将抛出异常，单位为秒 默认值是数据库厂商提供的JDBC驱动所设置的秒数 fetchSize 获取记录的总条数设定 默认值是数据库厂商提供的JDBC驱动所设置的条数 statementType 告诉MyBatis使用哪个JDBC的Statement工作，取值为STATEMENT(Statement)、CallableStatement 默认值为PREPARED resultSetType 针对JDBCresultSet接口 默认值是数据库厂商提供的JDBC驱动所设置的 databaseId 取决于数据库厂商 - resultOrdered 仅适用于嵌套集select语句。如果为true，就是假设包含了嵌套结果集或者是分组了。当返回一个主结果行的时候，就不能对前面结果集引用。确保了在获取嵌套结果集的时候不会导致内存不够用 true/false，默认为false resultSets 适用于多个结果集的情况，它将列出执行SQL后每个结果集的名称，每个名称之间用逗号分隔 很少使用 简易数据类型的例子例如，想要统计一个姓氏的数量，我们应该把‘姓’作为参数，而将结果(一个整数)作为结果返回123&lt;select id = "countFirstName" parameterType="String" resultType="int"&gt; select count(*) as total from t_userwhere name like #&#123;firstName&#125;&lt;/select&gt; 对应Dao中的方法为1public int countFirstName(String firstName); 每个部分的含义： id：对应的是Dao中的方法名 parameterType：是参数类型，也就是Dao中方法的参数类型 resultType：定义返回类型，也就是Dao中方法的返回类型 #{firstName}：也就是Dao中方法的参数名，#{}符号告诉MyBatis这是一个变量 在完整应用中的使用可以看下面这个例子mapper，Dao，JavaBean 自动映射MyBatis中可以设置参数autoMappingBehavior，当该值不为NONE时，MyBatis会自动根据SQL列名和JavaBean的属性自动映射(前提是他们一致)。大部分的数据库规范要求每个单词用下划线分割，而Java则是用驼峰命名。下面给出一个例子 JavaBean 1234567891011121314151617181920212223242526272829public class Role&#123; private Long id; private String roleName; private String note; public Long getId () &#123; return id; &#125; public void setId (Long id) &#123; this.id = id; &#125; public String getRoleName () &#123; retrun roleName; &#125; public void setRoleName (String roleName) &#123; this.roleName = roleName; &#125; public String getNote () &#123; return note; &#125; public void setNote (String note) &#123; this.note = note; &#125;&#125; 数据库表T_ROLE 字段 类型 说明 ID INT(20) 角色编号，主键，递增 ROLE_NAME VARCHAR(60) 角色名称 NOTE VARCHAR(1024) 备注 Mapper 1234&lt;select id = "getRole" parameterType = "long" resultType = "Role" &gt; select id, role_name as roleName, note from t_role where id = #&#123;id&#125;&lt;/select&gt; Dao 1public Role getRole(Long id); autoMappingBehavior属性包含三个值，可以再settings元素中配置： NONE：取消自动映射 PARTIAL(默认)：只会自动映射没有定义嵌套结果集映射的结果集 FULL：自动映射所有结果集 mapUnderscoreToCamelCase设置为true，可以实现从数据库到POJO的自动映射，前提是命名是规范的。 传递多个参数使用Map传递参数Mapper 12345&lt;select id="findRoleByMap" parameterType="map" resultMap="roleMap"&gt; select id, role_name, note from t_role where role_name like #&#123;roleName&#125; and note like #&#123;note&#125;&lt;/select&gt; Dao 1public List&lt;Role&gt; findRoleByMap (Map&lt;String, String&gt; params); 传递参数123456Map&lt;String, String&gt; paramsMap = new HashMap&lt;String, String&gt; ();paramsMap.put("roleName", "me");paramsMap.put("note", "te");roleMapper.findRoleByMap(paramsMap); 缺点是Map需要键值对应，业务关联性不强，造成可读性下降。 使用注解方式传递参数我们需要使用MyBatis的参数注解@param(org.apache.ibatis.annotations.Param)来实现想要的功能。操作方法是，把RoleDao接口修改为下面的形式。 12public List&lt;Role&gt; findRoleByAnnotation (@Param ("roleName") String rolename, @Param("note") String note); 注解式参数12345&lt;select id="findRoleByAnnotation" resultMap="roleMap"&gt; select id, role_name, note from t_role where role_name like #&#123;role_name&#125; and note like #&#123;note&#125;&lt;/select&gt; 缺点是如果参数过多会很复杂。 使用JavaBean传递参数首先定义一个参数的JavaBean1234567891011121314151617public class RoleParam &#123; private String roleName; private String note; public String getRoleName () &#123; return roleName; &#125; public void setRoleName (String roleName) &#123; this.roleName = roleName; &#125; public String getNote () &#123; return note; &#125; public void setNote (String note) &#123; this.note = note; &#125;&#125; 12345&lt;select id="findRoleByParams" parameterType = "RoleParam" resultMap="roleMap"&gt; select id, role_name, note from t_role where role_name like #&#123;role_name&#125; and note like #&#123;note&#125;&lt;/select&gt; 1public List&lt;Role&gt; findRoleByParams (RoleParam params); 使用resultMap映射结果集例如123456789&lt;resultMap id = "roleResultMap" type="Role"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="roleName" column="role_name"/&gt; &lt;result property="note" column="note"/&gt;&lt;/resultMap&gt;&lt;select parameterType="long" id="getRole" resultMap = "roleResultMap" &gt; select id, role_name, note from t_role where id = #&#123;id&#125;&lt;/select&gt; 解释一下配置： 定义了一个唯一标识(id)为roleResultMap的resultMap，用type属性定义它对应的是哪个JavaBean 通过id元素定义roleResultMap，这个对象代表着使用哪个属性作为其主键。 通过result元素定义普通列的映射关系。例如，把SQL结果返回的列role_name和type属性定义JavaBean的属性roleName等做对应。 推荐阅读基于MyBatis实现的JavaWeb项目源码-github 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>MyBatis映射器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 2.Add Two Numbers]]></title>
    <url>%2F2018%2F12%2F02%2FLeetCode-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[题目翻译给定两个非空单链表代表两个非负整数。每个结点有一位数字，以倒序保存在链表中。将两数相加，并返回一个代表结果的链表。假设两个数字不含无效的0(即数字不以0开头)，0本身除外。 例子： 输入: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出: 7 -&gt; 0 -&gt; 8 解释: 342 + 465 = 807. 解题方法遍历两个链表把每一位上的数字相加，并用变量记录是否需要进位，该变量初始为0。因为两个数字位数可能不同，所以有四种情况 两个链表中都有这一位数字，且两数与进位变量相加小于10，则直接得到新结点，并且将进位变量置位0. 两个链表中都有这一位数字，但两数与进位变量相加大于等于10，新结点的值为得到的和减10，并且将进位变量置位1. 只有一个链表有这一位数字，且这个数字加进位量小于10，直接得到新结点，变位量置位0. 只有一个链表有这一位数字，且这个数字加进位量大于等于10，新结点的值为得到的和减10，并且将进位变量置位1. 需要考虑到，最后可能两个链表相加完成后，进位量为1，要把这一进位量加到数字前面。 代码1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *p = l1; ListNode *q = l2; ListNode *h = new ListNode(0); ListNode *t = h; int flag = 0; while(p || q || flag&gt;0)&#123; int sump = p?p-&gt;val:0; int sumq = q?q-&gt;val:0; t-&gt;next = new ListNode(sump + sumq + flag); t = t-&gt;next; flag = t-&gt;val&gt;=10?1:0; t-&gt;val = t-&gt;val&gt;=10?t-&gt;val-10:t-&gt;val; p = p?p-&gt;next:NULL; q = q?q-&gt;next:NULL; &#125; t-&gt;next = NULL; return h-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 3.索引(一)——索引的类型]]></title>
    <url>%2F2018%2F12%2F02%2FMySQL-3-%E7%B4%A2%E5%BC%95-%E4%B8%80-%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[索引索引的作用：在MySQL中，想要查找某个行时，首先在索引中找到对应值，然后根据匹配的索引找到对应的数据行。在MySQL中，索引是在存储引擎层而不是服务器层实现的。对于索引的创建和如何使用索引进行查询 推荐阅读：如何理解并正确使用MySQL索引 索引的类型B-Tree索引B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。推荐阅读：什么是B树 B-Tree索引可以加快访问数据的速度，因为存储引擎可以从索引的根节点开始进行搜索，从而取代全表扫描。B-Tree对索引列是顺序组织存储的，所以比较适合查找范围数据 可以对多个列创建索引，索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。例如，定义索引时顺序为 姓名，生日。那么首先按姓名进行排序，只有当两人姓名一样时，才按生日排序。 B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。前面所述的索引对如下类型查询有效： 全值匹配：全值匹配指的是和索引中的所有列进行匹配。 匹配最左前缀：只匹配索引的第一列 匹配列前缀：只匹配第一列的值的开头部分，例如只匹配姓以J为开头的人。 匹配范围值：例如匹配成绩为60-100之间的人，只使用索引第一列 精确匹配某一列并范围匹配另一列：例如匹配所有姓名为张三，成绩在60-100分的人。 只访问索引的查询：查询只访问索引，并不访问数据行。 因为索引树中的节点是有序的，所以除了按值查找外，还可以用于查询中的ORDER BY操作。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。 B-Tree索引的限制： 如果不是按照索引最左列开始查找，则无法使用索引。例如，索引列按顺序为：姓名，生日，该索引无法用于查找某个特定生日的人，因为生日不是最左数据。同样也无法查找姓名以某个字结尾的人。 不能跳过索引中的列。例如，索引按顺序为：姓，名，生日。则无法查找所有在姓张的，且在1月1日生的人，因为不能跳过名。在这个查询中，MySQL只能使用‘姓’这列的索引。 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询(注意：LIKE也属于范围查询条件)。所以对于范围值有限的查询，可以用多个等于条件来代替范围条件。 哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎会对索引的索引列计算一个哈希码，不同键值行的哈希码不同。哈希索引将所有哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。如果哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中 例如，现在数据库表中有姓，名两列数据，且‘姓’列添加了哈希索引。当要查询一个姓为‘张’的数据时。MySQL先计算‘张’的哈希值，并且用该值在哈希表中找到对应的记录指针。 哈希索引自身只需存储对应哈希值，所以非常快。但是也存在限制： 哈希索引只包含哈希值和行指针，而不存储字段值。所以不能使用索引中的值来避免读取行 哈希索引无法用于排序，因为不是按照索引值顺序存储的(按照哈希后的值存储) 哈希索引不支持部分索引列匹配查找。 哈希索引只支持等值比较(包括=、IN()、&lt;=&gt;)。也不支持任何范围查询。 如果有很多哈希冲突，查询/维护代价会变高。 InnoDB有一个特殊功能叫做“自适应哈希索引(adaptive hash index)”。当InnoDB注意到某些索引值被使用的非常频繁时，它会在内存中基于B-Tree索引之上在创建一个哈希索引。 创建自定义哈希索引：如果存储引擎不支持哈希索引，则可以在B-Tree基础上创建一个伪哈希索引(本质上还是使用B-Tree查找)。 例如，需要存储大量URL，并且需要根据URL进行搜索查找。如果使用B-Tree直接查找，会很慢，存储内容也会很多。所以，可以给表新增一列，并且使用一个哈希函数，这个新增的列记录对应行URL哈希后的值，并在该列加上索引，这样在查找时，先对给定的URL进行哈希，然后再新增列上查找对应哈希后的值，找到后再返回对应的行就可以了。 有序数组即按一定顺序，将数据存在一个数组里，这种索引支持等值查询(二分法)，也支持范围查询(二分然后遍历)。但有序数组在更新时花费很高，所以只适合静态存储引擎。 全文索引它查找的是文本中的关键词，而不是直接比较索引中的值。在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE操作。 普通索引和唯一索引 普通索引：数据库中的基本索引类型，允许在定义索引的列中插入重复值和空值 唯一索引：索引列的值必须唯一，但允许有空值，主键索引是一种特殊的唯一索引，不允许有空值（比如自增ID） 单列索引和组合索引 单列索引： 即一个索引只包含单个列，一个表可以有多个单列索引 组合索引： 指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。在组合索引中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。 全文索引： 类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建，MySQL中只有MyISAM存储引擎支持全文索引 索引的优点索引除了可以让服务器快速地定位到指定位置，还有其他附加作用 对于B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。 优点： 索引减少了服务器需要扫描的数据量。 索引可以帮助服务器避免排序和临时表。 索引可将随机I/O变为顺序I/O InnoDB索引模型在InnoDB中，表都是根据主键顺序以索引的形式存放的，并且因为InnoDB采用B+ Tree，所以数据都存储在B+ Tree中。每一个索引在InnoDB里面对应一棵B+ Tree。 索引类型分为主键索引和非主键索引： 主键索引：叶子节点存的是整行数据，也称为聚簇索引。 非主键索引：叶子节点内容是主键的值，也称为二级索引。 对主键索引和非主键索引查询的区别： 主键查询方式只需要查询主键的B+ Tree。 普通查询需要先索引该列的B+ Tree，然后找到对应的主键，再进行主键查询，该过程称为回表。 如何选择主键一般情况下，使用自增主键是个比较好的选择： 可以减少插入/删除行时的分页/合并消耗。 主键长度越小，普通索引的叶子节点越小(因为叶子节点存储的是主键)。 下面这种场景下，可以直接使用业务字段做主键 只有一个索引 该索引必须是唯一索引 什么时候要使用索引 主键自动建立唯一索引。 经常作为查询条件在WHERE或者ORDER BY语句中出现的列要建立索引 作为排序的列要建立索引。 查询中与其他表关联的字段，外键关系建立索引。 高并发条件下倾向组合索引。 什么时候不要使用索引 经常增删改的的列不要建立索引。 有大量重复的列不要建立索引。 表记录太少不要建立索引。 在一个SELECT语句中，索引只能使用一次，如果在WHERE中使用了，那么在ORDER BY中就不要用了。 在索引的列上使用表达式或者函数会使索引失效。 在查询条件中使用正则表达式，只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。 在查询条件中使用&lt;&gt;会导致索引失效。 在查询条件中使用IS NULL会导致索引失效。 在查询条件中使用OR连接多个条件会导致索引失效，这时应该改为两次查询，然后用UNION ALL连接起来。 尽量不要多列排序，如果一定要，最好为这队列构建组合索引。 索引操作创建表时创建索引在执行CREATE TABLE语句时可以创建索引,也可以单独用CREATE INDEX或ALTER TABLE来为表增加索引。12345CREATE TABLE table_name( column_name data_type, ...... [UNIQUE|FULLTEXT|SPATIAL] &#123;INDEX|KEY&#125; index_name [USING &#123;BTREE | HASH&#125;] (col_name [(length)] [ASC | DESC]...); 为已存在表创建索引1234ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING &#123;BTREE | HASH&#125;] (col_name [(length)] [ASC | DESC]...)ALTER TABLE table_name ADD PRIMARY KEY (col_name [(length)] [ASC | DESC]..)CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING &#123;BTREE | HASH&#125;] ON tbl_name (col_name [(length)] [ASC | DESC],...) 删除索引12DROP INDEX index_name ON talbe_nameALTER TABLE table_name DROP INDEX index_name 联合索引123456CREATE TABLE t（ a INT, b INT, PRIMARY KEY（a）, KEY idx_a_b（a, b））ENGINE=InnoDB 联合索引的第二个好处是已经对第二个键值进行了排序处理。 全文索引12345678910111213//创建表的时候添加FULLTEXT索引CTREATE TABLE my_table( id INT(10) PRIMARY KEY, name VARCHAR(10) NOT NULL, my_text text CHARACTER SET utf8 COLLATE utf8_general_ci NULL, FULLTEXT(my_text));//创建表以后，在需要的时候添加FULLTEXT索引ALTER my_table ADD FULLTEXT ft_index(my_text);CREATE INDEX ft_index ON my_table(my_text); 推荐阅读什么是B树 如何理解并正确使用MySQL索引 极客时间：MySQL实战45讲 —— 04深入浅出索引(上) 12参考内容 &gt;&gt; 高性能MySQL第三版 &gt;&gt; 极客时间：MySQL实战45讲 —— 04深入浅出索引(上)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>InnoDB</tag>
        <tag>B-Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 2.数据类型及优化]]></title>
    <url>%2F2018%2F12%2F02%2FMySQL-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据类型选择原则 更小的通常更好(占用空间少)：但需要注意，不要低估值的范围 简单的更好：如整形比字符型好 尽量避免NULL：如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较更为复杂，并且会使用更多存储空间。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。尤其是有索引的列，应该避免可以为NULL。InnoDB对于稀疏数据(只有少数行为非NULL)，可以使用可以为NULL的列。 数据类型整数类型： 类型 位数 TINYINT 8 SMALLINT 16 MEDIUMINT 24 INT 32 BIGINT 64 UNSIGNED为可选属性。为整形类型指定宽度，如int(11)，并不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储来说int(1)和int(20)是一样的。 实数类型：不仅只是为了存储小数部分，还可以存储比BIGINT还大的数。MySQL既支持精确类型，也支持不精确类型。 FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。 DECIMAL类型用于存储精确的小数。在5.0版本及之后，支持精确计算。CPU不支持对DECIMAL直接计算，所以在5.0及更高版本中，MySQL服务器自身实现了DECIMAL的高精度计算，所以，浮点运算速度更快。 浮点和DECIMAL类型都可以指定精度。MySQL5.0及更高版本将数字打包保存到一个二进制字符串中。 MySQL5.0和更高版本DECIMAL最多允许65个数字。早期版本限制为254个数字且每个数字为一个字节。但其实并不能在计算中使用这么大的数字，因为早期版本DECIMAL只是一种存储格式，计算时会转换为浮点型。 应该只在对小数进行精确计算时才使用DECIMAL，在数据量比较大时，可以考虑BIGINT代替DECIMAL，将需要的单位根据小数位数乘以相应倍数即可。 字符串类型：VARCHAR和CHAR是两种最主要的字符串类型。 VARCHAR：VARCHAR类型用于存储可变长字符串。比定长类型更节省空间。但如果MySQL表使用ROW_FORMAT = FIXED创建的话，每一行都会使用定长存储，会很浪费空间。VARCHAR需要使用1或两个额外字节记录字符串长度：如果列的最大长度小于或等于255字节，则只需要使用1个字节表示，否则需要两个。 由于行是可变的，UPDATE时可能需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，不同的存储引擎处理方式不一样。例如，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页使行可以放进页内。 在5.0或更高版本，MySQL在存储和检索时，会保留末尾空格。早期版本会剔除。 下面情况使用VARCHAR比较合适： 字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题； 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储； CHAR：CHAR类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。 下面情况使用CHAR比较合适： 很短的字符串； 数据经常变更； 所有值都接近同一个长度。 BLOB类型和TEXT类型：都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。它们分别属于两组不同的数据类型 字符类型 对应二进制类型 TINYTEXT TINYBLOB SMALLTEXT SMALLBLOB TEXT BLOB MEDIUMTEXT MEDIUMBLOB LONGTEXT LONGBLOB MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。这两种类型的排序也和其他类型不同：只对每个列的最前max_sort_length字节而不是整个字符串做排序。 枚举类型：枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到一个或者两个字节中。MySQL内部会将每个值在列中的位置保存为整数，并在表的.frm文件中保存“数字-字符串”的映射关系。所以实际存储的为整数，而不是字符串。 例如： mysql &gt; CREATE TABLE enum_test( -&gt; e ENUM(&apos;fish&apos;, &apos;apple&apos;, &apos;dog&apos;) NOT NULL); mysql &gt; INSERT INTO enum_test(e) VALUES(&apos;fish&apos;), (&apos;dog&apos;), (&apos;apple&apos;); mysql &gt; SELECT e + 0 FROM enum_test; 结果： | e + 0 | | 1 | | 3 | | 2 | 如果使用数字本身作为枚举常量，会造成混乱，应避免这么做。 同样，枚举字段按照存储的整数而不是预定义的字符串进行排序。 mysql &gt; SELECT e FROM enum_test ORDER BY e; 结果： | e | | fish | | apple | | dog | 可以使用FIELD()函数显式地指定排序顺序，但会导致MySQL无法利用索引消除排序。 mysql &gt; SELECT e FROM enum_test ORDER BY FIELD(e, &apos;apple&apos;,&apos;dog&apos;,&apos;fish&apos;); 结果： | e | | apple | | dog | | fish | 枚举的缺点是，字符串列表固定，添加或删除预定义字符串，必须使用ALTER TABLE会花费许多时间。 优点是可能缩小表的大小。 日期和时间类型： DATETIME：能保存大范围的值，从1001年到9999年，精度为秒，与时区无关。使用8个字节的存储空间。 TIMESTAMP：从1970年1月1日午夜以来的秒数，使用4个字节的存储空间，只能表示1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把Unix时间戳转换为日期，及UNIX_TIMESTAMP()函数把日期转换我Unix时间戳。显示值依赖于时区。默认情况下，如果插入时没有指定第一个TIMESTAMP的列的值，MySQL则设置这个列的值为当前时间。在插入一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值(除非在UPDATE语句中明确指定了值)。可以配置任何TIMESTAMP列的插入和更新行为。TIMESTAMP列默认为NOT NULL。 位数据类型：所有位类型，不管底层存储格式还是处理方式如何，从技术上来说都是字符串类型。在MySQL5.0之前，BIT与TINYINT相同。但在5.0及之后版本中，并不相同。 BIT：可以使用BIT在一列中存储多个true/false值。BIT(1)定义一个包含单个位的字段，BIT(2)包含两个位，最大长度为64。BIT的行为因存储引擎而异。MyISAM会打包存储所有BIT的列，17个单独的BIT列只需要17个位(假设全都不可为NULL)，这样MyISAM只使用3个字节就足够了。而InnoDB为每个BIT列使用一个足够存储的最小整数类型来存放。 MySQL把BIT当作字符串类型，而不是数字类型。当检索BIT(1)的值时，结果是一个包含二进制0或1值的字符串，而不是ASCII码的“0”或“1”。但是，在数字上下文的场景中检索时，结果将是位字符串转换成的数字。例如，如果存储一个值b‘00111001’(二进制等于57)到BIT(8)的列并且检索，得到的内容是字符码为57的字符串。也就是得到ASCII码为57的字符“9”。但是在数字上下文场景中，得到的是数字57： 12345678mysql &gt; CREATE TABLE bittest(a bit(8));mysql &gt; INSERT INTO bittest VALUE(b &apos;00111001&apos;);mysql &gt; SELECT a, a + 0 FROM bittest;结果为：| a | a + 0|| 9 | 57 | 如果想在一个bit的存储空间中存储一个布尔值，一个可选的方法是创建一个可以为空的CHAR(0)列。该列可以保存空值(NULL)或者长度为零的字符串(空字符串)。 SET：如果需要保存很多true/false值，可以考虑合并这些列到一个SET数据类型，它在MySQL内部以一系列打包的位的集合来表示。缺点是改变列的定义的代价较高，需要ALTER TABLE，并且无法在SET列上通过索引查找。 可选的替代操作是使用一个整数包装一系列的位。例如，可以把8个位包装到一个TINYINT中，并且按位操作来使用(类似于Linux中文件的权限控制) 例如：12345678910mysql &gt; SET @CAN_READ := 1 &lt;&lt; 0, -&gt; @CAN_WRITE := 1 &lt;&lt; 1, -&gt; @CAN_DELETE := 1 &lt;&lt; 2;mysql &gt; CREATE TABLE acl (perms TINYINT UNSIGNED NOT NULL DEFAULT 0);mysql &gt; INSERT INTO acl(perms) VALUE(@CAN_READ + @CAN_DELETE);mysql &gt; SELECT perms FROM acl WHERE perms &amp; @CAN_READ;结果：| perms || 5 | MySQL schema 设计陷阱 太多关联：耗费很长时间查询和缓存。 太多的列：MySQL存储引擎API工作时，会在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列，这个过程代价很高(MyISAM定长行结构与服务器层相匹配，不需要转换)。代价依赖于列的数量 过度使用枚举：每次在枚举列中增加一个新选项，都要做一次ALTER TABLE操作 变相枚举：枚举ENUM列允许在列中存储一组定义值中的单个值，集合SET允许在列中存储一组定义值中的一个或多个值。所以当列中的值不可能同时出现多种情况时(e.g., 同一门成绩的挂科和通过不可能同时存在)，应该使用枚举代替集合。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>MySQL数据类型</tag>
        <tag>MySQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MySQL] 1.MySQL架构与引擎]]></title>
    <url>%2F2018%2F12%2F01%2FMySQL-1-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[基础架构MySQL服务器逻辑架构: 最上层服务负责连接处理、授权认证。安全等。 第二层包含了MySQL的大多核心功能，包括查询解析、分析、优化、缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。 第三层为存储引擎，存储引擎负责MySQL中数据的存储和提取。存储引擎不负责解析SQL(InnoDB是例外，它会解析外键定义)，不同存储引擎也不会相互通信。 并发控制读写锁：读锁也叫共享锁，写锁也叫排它锁。读锁是相互不阻塞的，多个用户在同一时刻可以同时读取同一个资源，而且互不干扰。写锁是排他的，一个写锁会阻塞其他的写锁和读锁，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。 表锁：开销最小的策略，会锁定整张表。一个用户在对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列之前。 行锁：可以最大程度支持并发处理，但同时锁开销最大。行级锁只在存储引擎层实现。 事务 事务是一组原子性的SQL查询。事务内的语句，要么全部执行成功，要么全部失败。 事务具有ACID的特性: Atomicity(原子性)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能执行其中的一部分操作，这就是事务的原子性。 Consistency(一致性)：数据库总是从一个一致性的状态转换到另外一个一致性的状态。 Isolation(隔离性)：通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的。 Durability(持久性)：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。 隔离级别: 未提交读(Read Uncommitted)：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，也被称为脏读(Dirty Read)。一般很少使用 提交读(Read Committed)：一个事务开始时，只能看见已经提交的事务所做的修改。即一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。也叫做不可重复读(nonrepeatable read)，因为两次同样的查询，可能得到不一样的结果。 可重复读(Repeatable Read)：解决了脏读问题，同时保证了在同一个事务中多次读取同样记录的结果是一致的。但无法解决幻读(Phantom Read)问题，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和XtraDB通过多版本并发控制(MVCC)解决了幻读问题。 可串行化(Serializable)：通过强制事务串行执行，避免了幻读。会在读取的每一行数据上都加锁。 隔离级别 脏读 不可重复读 幻读 加锁读 未提交读 √ √ √ × 提交读 × √ √ × 可重复读 × × √ × 可串行读 × × × √ 可以通过SET TRANSACTION ISOLATION LEVEL设置隔离级别。 mysql &gt; SET SESSION TRANSACTION ISOLATION LEVER ***; *** 为相应级别 死锁：锁的行为和顺序是和存储引擎相关的，以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁发生后，只有部分或者完全回滚其中一个事务才能打破死锁。对于事务型系统是无法避免的。 InnoDB解决死锁的方法是，将持有最少行级排他锁的事务进行回滚。 事务日志：事务日志可以帮助提高事务效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快的多。事务日志持久以后，内存中被修改的数据可以慢慢刷回到磁盘。称之为预写式日志(Write-Ahead Logging)，修改数据需要写两次磁盘。 自动提交：MysQL默认采用自动提交事务，如果不显式地开始一个事务，则每个查询都被当做一个事务执行提交操作，可以通过设置AUTOCOMMIT变量来查看。 mysql &gt; SHOW VARIABLES LIKE &apos;AUTOCOMMIT&apos;; mysql &gt; SET AUTOCOMMIT = 1; 1或者on表示启用，0或者off表示禁用。当AUTOCOMMIT= 0时，所有查询在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事务。修改AUTOCOMMIT对非事务型的表，比如MyISAM是无效的，因为对这类表来说，没有COMMIT和ROLLBACK的概念，可以看成一直处于AUTOCOMMIT开启状态。还有些命令，在执行前会强制COMMIT提交当前活动事务，如会导致大量数据改变的操作(e.g., ALTER TABLE) 在同一事务中，使用多种存储引擎是不可靠的(如事务型引擎和非事务引擎，回滚会造成数据不一致) 隐式和显式锁定：InnoDB采用两段锁定协议(two-phase locking protocol)。在事务执行过程中，随时可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。这些都属于隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁 InnoDB也支持显示锁定，但不属于SQL规范，如： SELECT ... LOCK IN SHARE MODE SELECT ... FOR UPDATE 多版本并发控制(MVCC):MVCC是行级锁的一个变种，但是在很多情况下避免了加锁操作，大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC通过保存数据在某个时间点的快照来实现的。不管执行多长时间，每个事务看到的数据都是一致的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。 InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是实际的是兼职，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。 SELECT：InnoDB会根据以下两个条件检查每行记录： InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始前未被删除。只有符合上述两个条件的记录，才能返回作为查询结果。 INSERT：InnoDB为新插入的每一行保存当前系统版本号作为版本号。 DELETE：InnoDB为删除的每一行保存当前系统版本号作为删除标识。 UPDATE：InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。 MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作。其他两个级别不兼容，因为READ UNCOMMITTED总是读取最新数据行，而SERIALIZABLE则会对所有读取的行都加锁。 存储引擎mysql &gt; SHOW TABLE STATUS LIKE &apos;***&apos; 用来查看表的相关信息，***为表名 InnoDB：被设计用来处理大量短期事务(short-lived)事务，短期事务大部分情况是正常提交的，很少被回滚。InnoDB的数据存储在表空间(tablespace)中，表空间是由InnoDB管理的一个黑盒子，由一系列数据文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。也可以使用裸设备作为表空间的存储介质。InnoDB采用MVCC支持高并发，默认隔离级别为可重复读，并且通过间隙锁(next-key locking)策略防止幻读。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。 InnoDB表基于聚簇索引建立，所以对主键查询有很高的性能，不过二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应尽可能的小。 MyISAM：提供了大量特性，包含全文索引、压缩、空间函数。但不支持事务和行级锁，而且没有安全的崩溃恢复。对于只读的数据，或者表比较小、可以容忍修复操作，则可以使用MyISAM。 MyISAM会将表存储在：数据文件和索引文件中。表可以包含动弹或者静态(长度固定)行。MySQL会根据表的定义来决定采用何种行格式。MyISAM表可以存储的行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸. 特性： 加锁与并发：对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也可以往表中插入新的记录。 修复：MySQL可以手工或者自定执行检查和修复操作，这里修复与事务恢复和崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，可以通过CHECK TABLE mytable检查表的错误，如果有错误可以通过执行REPAIR TABLE mytable进行修复。 索引：即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。同时也支持全文索引。 延迟更新索引键：创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。可以提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置。 压缩表：压缩表不能进行修改，支持索引，但索引也是只读的。 1参考内容 &gt;&gt; 高性能MySQL第三版]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>存储引擎</tag>
        <tag>ACID</tag>
        <tag>隔离级别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 3.Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个字符串，找出最长不重复子串。 例子： 输入: &quot;abcabcbb&quot; 输出: 3 解释：&quot;abc&quot; 输入: &quot;bbbbb&quot; 输出: 1 解释：&quot;b&quot; 输入: &quot;pwwkew&quot;&quot; 输出: 3 解释：&quot;wke&quot; 注意子串必须是连续的。 解题方法使用hash保存出现过的字符和位置。使用一个cur变量记录当前子串长度，start变量记录当前子串起始位置。遍历字符串，有三种可能： 如果当前字符没出现过，就将该字符与下标存到hash中，当前子串长度cur加1。 如果当前字符出现过，但是上一次出现的位置不在当前记录的子串中，就把当前长度cur加1，并把该字符在hash中的位置更新。 如果当前字符出现过，并且上一次出现的位置在当前子串中，说明该子串含有重复字符了，就把start变为上一次出现位置的后一个(这样可以保证子串中没有重复字符)。然后将当前子串长度更新，并把当前字符的位置更新。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char,int&gt; H; map&lt;char,int&gt;::iterator it; int max = 0; int start = 0; int cur = 0; for(int i = 0;i&lt;s.size();i++)&#123; it = H.find(s[i]); if(it==H.end())&#123; H.insert(pair&lt;char,int&gt;(s[i],i)); cur++; &#125;else&#123; if(it-&gt;second&lt;start)&#123; cur++; &#125;else&#123; start = it-&gt;second + 1; cur = i - start + 1; &#125; it-&gt;second = i; &#125; max = max&gt;cur?max:cur; &#125; max = max&gt;cur?max:cur; return max; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1.Two Sum]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个整数数组和一个目标值，返回两个相加等于目标值的数的下标。你可以假设每组输入只有一个正确答案，并且你不能使用同一个元素两次。 例子： 输入： nums = [2, 7, 11, 15], target = 9, 输出： [0,1] 解释： 因为num[0] + nums[1] = 2 + 7 = 9 解题方法解法1：使用hash，如果target与当前数的差已经在hash中就返回两个数的下标，否则把当前数加入到hash中。 解法2：将原数组的值和下标放在一个pair中，并组成一个新的数组，将该数组升序排列。从两端向里遍历，若两端的数的和大于target，则将右端向左移动。若两端数的和小于target，则左端向右移动，直到找到和为target的两个数字。 代码123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2); if(nums.size()&lt;=1) return res; map&lt;int,int&gt; H; map&lt;int,int&gt;::iterator it; for(int i = 0;i&lt;nums.size();i++)&#123; it = H.find(target - nums[i]); if(it == H.end())&#123; H.insert(pair&lt;int,int&gt;(nums[i],i)); &#125;else&#123; res[0] = it-&gt;second; res[1] = i; break; &#125; &#125; return res; &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;private: static bool cmp(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) &#123; return A.first &lt; B.first; &#125;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, 0); vector&lt;pair&lt;int, int&gt;&gt; temp; for (int i = 0; i&lt;nums.size(); i++) temp.push_back(pair&lt;int, int&gt;(nums[i], i)); sort(temp.begin(), temp.end(), cmp); int i = 0, j = temp.size() - 1; while (i&lt;j) &#123; if (temp[i].first + temp[j].first&gt;target) j--; else if (temp[i].first + temp[j].first&lt;target) i++; else &#123; res[0] = temp[i].second &lt; temp[j].second ? temp[i].second : temp[j].second; res[1] = temp[i].second &gt;= temp[j].second ? temp[i].second : temp[j].second; return res; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>哈希</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 1.MyBatis基本构成]]></title>
    <url>%2F2018%2F12%2F01%2FMyBatis-1-MyBatis%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[MyBatis核心组件： SqlSessionFactoryBuilder(构造器)：它会根据配置信息或者代码来生成SqlSessionFactory(工厂接口)。 SqlSessionFactory：依靠工厂来生成SqlSession(会话)。 SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口。 SQLMapper：由一个Java接口和XML文件(或注解)构成的，需要给出对应的SQL和映射规则，负责发送SQL去执行，并返回结果。 构建SqlSessionFactory：每个MyBatis应用都是以SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactory是一个工厂接口而不是现实类，它的任务是创建SqlSession。SqlSession类似于JDBC的Connection对象。MyBatis提供了两种模式去创建SqlSessionFactory： XML配置(推荐) 代码 Mybatis中有一个Configuration类存在于整个MyBatis应用的生命期中，以便重复读取和运用。可以解析一次配置的XML文件保存到Configuration类对象中，方便从这个对象中读取配置信息，性能高。单例占用空间小，基本不占用存储空间，而且可以反复使用。Configuration类对象保存着配置在MyBatis的信息。在MyBatis中提供了两个SqlSessionFactory的实现类，DefaultSqlSessionFactory和SqlSessionManager。不过SqlSessionManager目前没有使用。 创建SqlSession：SqlSession是一个接口类，真正工作的是Executor接口。构建了SqlSessionFactory，然后生成SqlSession。SqlSession接口类似于一个JDBC中的Connection接口对象，需要保证每次用完正常关闭，所以正确做法是将关闭SqlSession接口的代码写在finally语句中保证每次都会关闭SqlSession。 123456789101112131415// 定义SqlSession Sqlsession sqlSession = null; try &#123; // 打开SqlSession会话 sqlSession = sqlSessionFactory.openSession(); //... sqlSession.commit(); &#125; catch(Exception ex) &#123; sqlSession.rollback(); &#125;finally &#123; // 确保资源被正确关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; 主要用途有两种： 获取映射器，让映射器通过命名空间和方法名称找到对应的SQL，发送给数据库执行后返回结果。 直接通过命名信息去执行SQL返回结果。在SqlSession层可以通过update、insert、select、delete等方法，带上SQL的id来操作在XML中配置好的SQL。 映射器：由Java接口和XML文件(或注解)共同组成的，它的作用如下。 定义参数类型。 描述缓存。 描述SQL语句。 定义查询结果和POJO的映射关系。同样有XML和代码两种方式生成。 组件的生命周期 SqlSessionFactoryBuilder：一旦构建了SqlSessionFactory，它的作用就已经完结，应该被回收。所以它的生命周期只存在于方法的局部，作用是生成SqlSessionFactory对象。 SqlSessionFactory：作用是创建SqlSession(相当于JDBC的Connection对象)。每次应用程序需要访问数据库，就要通过SqlSessionFactory创建SqlSession，所以SqlSessionFactory存在于应用的整个生命周期中。应该采用单例模式(一般方法为将构造方法私有化，并给出一个静态方法，让其返回唯一单例，在多线程初始化单例时，一般需要加线程锁避免类对象被多次初始化)，以避免创建更多SqlSessionFactory而消耗资源。所以一个数据库只应该对应一个SqlSessionFactory。 SqlSession：一个会话，相当于JDBC一个Connection对象，生命周期是在请求数据库处理事务的过程中。该对象线程不安全，应该属于其隔离级别，数据库锁等特性。每次创建的SqlSession都应及时关闭，避免占用数据库连接池。所以，它存活于一个应用的请求和操作中，可以执行多条SQL。 Mapper：是一个接口，没有任何实现类，作用是发送SQL，并返回需要的结果，或者执行SQL以修改数据库数据。因此应该在一个SqlSession事务方法之内，属于方法级别。类似于JDBC中的一条SQL语句的执行，最大的范围和SqlSession相同。 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
