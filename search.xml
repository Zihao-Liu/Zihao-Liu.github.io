<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[MySQL] 1.MySQL架构与引擎]]></title>
    <url>%2F2018%2F12%2F01%2FMySQL-1-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[基础架构MySQL服务器逻辑架构: 最上层服务负责连接处理、授权认证。安全等。 第二层包含了MySQL的大多核心功能，包括查询解析、分析、优化、缓存以及所有内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。 第三层为存储引擎，存储引擎负责MySQL中数据的存储和提取。存储引擎不负责解析SQL(InnoDB是例外，它会解析外键定义)，不同存储引擎也不会相互通信。 并发控制读写锁：读锁也叫共享锁，写锁也叫排它锁。读锁是相互不阻塞的，多个用户在同一时刻可以同时读取同一个资源，而且互不干扰。写锁是排他的，一个写锁会阻塞其他的写锁和读锁，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。 表锁：开销最小的策略，会锁定整张表。一个用户在对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列之前。 行锁：可以最大程度支持并发处理，但同时锁开销最大。行级锁只在存储引擎层实现。 事务 事务是一组原子性的SQL查询。事务内的语句，要么全部执行成功，要么全部失败。 事务具有ACID的特性: Atomicity(原子性)：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能执行其中的一部分操作，这就是事务的原子性。 Consistency(一致性)：数据库总是从一个一致性的状态转换到另外一个一致性的状态。 Isolation(隔离性)：通常来说，一个事务所做的修改在最终提交之前，对其他事务是不可见的。 Durability(持久性)：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。 隔离级别: 未提交读(Read Uncommitted)：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，也被称为脏读(Dirty Read)。一般很少使用 提交读(Read Committed)：一个事务开始时，只能看见已经提交的事务所做的修改。即一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。也叫做不可重复读(nonrepeatable read)，因为两次同样的查询，可能得到不一样的结果。 可重复读(Repeatable Read)：解决了脏读问题，同时保证了在同一个事务中多次读取同样记录的结果是一致的。但无法解决幻读(Phantom Read)问题，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和XtraDB通过多版本并发控制(MVCC)解决了幻读问题。 可串行化(Serializable)：通过强制事务串行执行，避免了幻读。会在读取的每一行数据上都加锁。 隔离级别 脏读 不可重复读 幻读 加锁读 未提交读 √ √ √ × 提交读 × √ √ × 可重复读 × × √ × 可串行读 × × × √ 可以通过SET TRANSACTION ISOLATION LEVEL设置隔离级别。 mysql &gt; SET SESSION TRANSACTION ISOLATION LEVER ***; *** 为相应级别 死锁：锁的行为和顺序是和存储引擎相关的，以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁发生后，只有部分或者完全回滚其中一个事务才能打破死锁。对于事务型系统是无法避免的。 InnoDB解决死锁的方法是，将持有最少行级排他锁的事务进行回滚。 事务日志：事务日志可以帮助提高事务效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快的多。事务日志持久以后，内存中被修改的数据可以慢慢刷回到磁盘。称之为预写式日志(Write-Ahead Logging)，修改数据需要写两次磁盘。 自动提交：MysQL默认采用自动提交事务，如果不显式地开始一个事务，则每个查询都被当做一个事务执行提交操作，可以通过设置AUTOCOMMIT变量来查看。 mysql &gt; SHOW VARIABLES LIKE &apos;AUTOCOMMIT&apos;; mysql &gt; SET AUTOCOMMIT = 1; 1或者on表示启用，0或者off表示禁用。当AUTOCOMMIT= 0时，所有查询在一个事务中，直到显式地执行COMMIT提交或者ROLLBACK回滚，该事务结束，同时又开始了另一个新事务。修改AUTOCOMMIT对非事务型的表，比如MyISAM是无效的，因为对这类表来说，没有COMMIT和ROLLBACK的概念，可以看成一直处于AUTOCOMMIT开启状态。还有些命令，在执行前会强制COMMIT提交当前活动事务，如会导致大量数据改变的操作(e.g., ALTER TABLE) 在同一事务中，使用多种存储引擎是不可靠的(如事务型引擎和非事务引擎，回滚会造成数据不一致) 隐式和显式锁定：InnoDB采用两段锁定协议(two-phase locking protocol)。在事务执行过程中，随时可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。这些都属于隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁 InnoDB也支持显示锁定，但不属于SQL规范，如： SELECT ... LOCK IN SHARE MODE SELECT ... FOR UPDATE 多版本并发控制(MVCC):MVCC是行级锁的一个变种，但是在很多情况下避免了加锁操作，大都实现了非阻塞的读操作，写操作也只锁定必要的行。MVCC通过保存数据在某个时间点的快照来实现的。不管执行多长时间，每个事务看到的数据都是一致的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。 InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)。当然存储的并不是实际的是兼职，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。 SELECT：InnoDB会根据以下两个条件检查每行记录： InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始前未被删除。只有符合上述两个条件的记录，才能返回作为查询结果。 INSERT：InnoDB为新插入的每一行保存当前系统版本号作为版本号。 DELETE：InnoDB为删除的每一行保存当前系统版本号作为删除标识。 UPDATE：InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。 MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作。其他两个级别不兼容，因为READ UNCOMMITTED总是读取最新数据行，而SERIALIZABLE则会对所有读取的行都加锁。 存储引擎mysql &gt; SHOW TABLE STATUS LIKE &apos;***&apos; 用来查看表的相关信息，***为表名 InnoDB：被设计用来处理大量短期事务(short-lived)事务，短期事务大部分情况是正常提交的，很少被回滚。InnoDB的数据存储在表空间(tablespace)中，表空间是由InnoDB管理的一个黑盒子，由一系列数据文件组成。InnoDB可以将每个表的数据和索引存放在单独的文件中。也可以使用裸设备作为表空间的存储介质。InnoDB采用MVCC支持高并发，默认隔离级别为可重复读，并且通过间隙锁(next-key locking)策略防止幻读。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。 InnoDB表基于聚簇索引建立，所以对主键查询有很高的性能，不过二级索引(secondary index，非主键索引)中必须包含主键列，所以如果主键列很大的话，其他的所有索引都会很大。因此，若表上的索引较多的话，主键应尽可能的小。 MyISAM：提供了大量特性，包含全文索引、压缩、空间函数。但不支持事务和行级锁，而且没有安全的崩溃恢复。对于只读的数据，或者表比较小、可以容忍修复操作，则可以使用MyISAM。 MyISAM会将表存储在：数据文件和索引文件中。表可以包含动弹或者静态(长度固定)行。MySQL会根据表的定义来决定采用何种行格式。MyISAM表可以存储的行记录数，一般受限于可用的磁盘空间，或者操作系统中单个文件的最大尺寸. 特性： 加锁与并发：对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也可以往表中插入新的记录。 修复：MySQL可以手工或者自定执行检查和修复操作，这里修复与事务恢复和崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，可以通过CHECK TABLE mytable检查表的错误，如果有错误可以通过执行REPAIR TABLE mytable进行修复。 索引：即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。同时也支持全文索引。 延迟更新索引键：创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区(in-memory key buffer)，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。可以提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置。 压缩表：压缩表不能进行修改，支持索引，但索引也是只读的。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>存储引擎</tag>
        <tag>ACID</tag>
        <tag>隔离级别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 3.Longest Substring Without Repeating Characters]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个字符串，找出最长不重复子串。 例子： 输入: &quot;abcabcbb&quot; 输出: 3 解释：&quot;abc&quot; 输入: &quot;bbbbb&quot; 输出: 1 解释：&quot;b&quot; 输入: &quot;pwwkew&quot;&quot; 输出: 3 解释：&quot;wke&quot; 注意子串必须是连续的。 解题方法使用hash保存出现过的字符和位置。使用一个cur变量记录当前子串长度，start变量记录当前子串起始位置。遍历字符串，有三种可能： 如果当前字符没出现过，就将该字符与下标存到hash中，当前子串长度cur加1。 如果当前字符出现过，但是上一次出现的位置不在当前记录的子串中，就把当前长度cur加1，并把该字符在hash中的位置更新。 如果当前字符出现过，并且上一次出现的位置在当前子串中，说明该子串含有重复字符了，就把start变为上一次出现位置的后一个(这样可以保证子串中没有重复字符)。然后将当前子串长度更新，并把当前字符的位置更新。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char,int&gt; H; map&lt;char,int&gt;::iterator it; int max = 0; int start = 0; int cur = 0; for(int i = 0;i&lt;s.size();i++)&#123; it = H.find(s[i]); if(it==H.end())&#123; H.insert(pair&lt;char,int&gt;(s[i],i)); cur++; &#125;else&#123; if(it-&gt;second&lt;start)&#123; cur++; &#125;else&#123; start = it-&gt;second + 1; cur = i - start + 1; &#125; it-&gt;second = i; &#125; max = max&gt;cur?max:cur; &#125; max = max&gt;cur?max:cur; return max; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode] 1.Two Sum]]></title>
    <url>%2F2018%2F12%2F01%2FLeetCode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[题目翻译给定一个整数数组和一个目标值，返回两个相加等于目标值的数的下标。你可以假设每组输入只有一个正确答案，并且你不能使用同一个元素两次。 例子： 输入： nums = [2, 7, 11, 15], target = 9, 返回： [0,1](因为num[0] + nums[1] = 2 + 7 = 9) 解题方法解法1：使用hash，如果target与当前数的差已经在hash中就返回两个数的下标，否则把当前数加入到hash中。 解法2：将原数组的值和下标放在一个pair中，并组成一个新的数组，将该数组升序排列。从两端向里遍历，若两端的数的和大于target，则将右端向左移动。若两端数的和小于target，则左端向右移动，直到找到和为target的两个数字。 代码123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2); if(nums.size()&lt;=1) return res; map&lt;int,int&gt; H; map&lt;int,int&gt;::iterator it; for(int i = 0;i&lt;nums.size();i++)&#123; it = H.find(target - nums[i]); if(it == H.end())&#123; H.insert(pair&lt;int,int&gt;(nums[i],i)); &#125;else&#123; res[0] = it-&gt;second; res[1] = i; break; &#125; &#125; return res; &#125;&#125;; 123456789101112131415161718192021222324252627class Solution &#123;private: static bool cmp(pair&lt;int, int&gt; A, pair&lt;int, int&gt; B) &#123; return A.first &lt; B.first; &#125;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res(2, 0); vector&lt;pair&lt;int, int&gt;&gt; temp; for (int i = 0; i&lt;nums.size(); i++) temp.push_back(pair&lt;int, int&gt;(nums[i], i)); sort(temp.begin(), temp.end(), cmp); int i = 0, j = temp.size() - 1; while (i&lt;j) &#123; if (temp[i].first + temp[j].first&gt;target) j--; else if (temp[i].first + temp[j].first&lt;target) i++; else &#123; res[0] = temp[i].second &lt; temp[j].second ? temp[i].second : temp[j].second; res[1] = temp[i].second &gt;= temp[j].second ? temp[i].second : temp[j].second; return res; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode解题报告</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>哈希</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[MyBatis] 1.MyBatis基本构成]]></title>
    <url>%2F2018%2F12%2F01%2FMyBatis-1-MyBatis%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[MyBatis核心组件： SqlSessionFactoryBuilder(构造器)：它会根据配置信息或者代码来生成SqlSessionFactory(工厂接口)。 SqlSessionFactory：依靠工厂来生成SqlSession(会话)。 SqlSession：是一个既可以发送SQL去执行并返回结果，也可以获取Mapper的接口。 SQLMapper：由一个Java接口和XML文件(或注解)构成的，需要给出对应的SQL和映射规则，负责发送SQL去执行，并返回结果。 构建SqlSessionFactory：每个MyBatis应用都是以SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。SqlSessionFactory是一个工厂接口而不是现实类，它的任务是创建SqlSession。SqlSession类似于JDBC的Connection对象。MyBatis提供了两种模式去创建SqlSessionFactory： XML配置(推荐) 代码 Mybatis中有一个Configuration类存在于整个MyBatis应用的生命期中，以便重复读取和运用。可以解析一次配置的XML文件保存到Configuration类对象中，方便从这个对象中读取配置信息，性能高。单例占用空间小，基本不占用存储空间，而且可以反复使用。Configuration类对象保存着配置在MyBatis的信息。在MyBatis中提供了两个SqlSessionFactory的实现类，DefaultSqlSessionFactory和SqlSessionManager。不过SqlSessionManager目前没有使用。 创建SqlSession：SqlSession是一个接口类，真正工作的是Executor接口。构建了SqlSessionFactory，然后生成SqlSession。SqlSession接口类似于一个JDBC中的Connection接口对象，需要保证每次用完正常关闭，所以正确做法是将关闭SqlSession接口的代码写在finally语句中保证每次都会关闭SqlSession。 123456789101112131415// 定义SqlSession Sqlsession sqlSession = null; try &#123; // 打开SqlSession会话 sqlSession = sqlSessionFactory.openSession(); //... sqlSession.commit(); &#125; catch(Exception ex) &#123; sqlSession.rollback(); &#125;finally &#123; // 确保资源被正确关闭 if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; 主要用途有两种： 获取映射器，让映射器通过命名空间和方法名称找到对应的SQL，发送给数据库执行后返回结果。 直接通过命名信息去执行SQL返回结果。在SqlSession层可以通过update、insert、select、delete等方法，带上SQL的id来操作在XML中配置好的SQL。 映射器：由Java接口和XML文件(或注解)共同组成的，它的作用如下。 定义参数类型。 描述缓存。 描述SQL语句。 定义查询结果和POJO的映射关系。同样有XML和代码两种方式生成。 组件的生命周期 SqlSessionFactoryBuilder：一旦构建了SqlSessionFactory，它的作用就已经完结，应该被回收。所以它的生命周期只存在于方法的局部，作用是生成SqlSessionFactory对象。 SqlSessionFactory：作用是创建SqlSession(相当于JDBC的Connection对象)。每次应用程序需要访问数据库，就要通过SqlSessionFactory创建SqlSession，所以SqlSessionFactory存在于应用的整个生命周期中。应该采用单例模式(一般方法为将构造方法私有化，并给出一个静态方法，让其返回唯一单例，在多线程初始化单例时，一般需要加线程锁避免类对象被多次初始化)，以避免创建更多SqlSessionFactory而消耗资源。所以一个数据库只应该对应一个SqlSessionFactory。 SqlSession：一个会话，相当于JDBC一个Connection对象，生命周期是在请求数据库处理事务的过程中。该对象线程不安全，应该属于其隔离级别，数据库锁等特性。每次创建的SqlSession都应及时关闭，避免占用数据库连接池。所以，它存活于一个应用的请求和操作中，可以执行多条SQL。 Mapper：是一个接口，没有任何实现类，作用是发送SQL，并返回需要的结果，或者执行SQL以修改数据库数据。因此应该在一个SqlSession事务方法之内，属于方法级别。类似于JDBC中的一条SQL语句的执行，最大的范围和SqlSession相同。 1参考内容 &gt;&gt; 深入浅出MyBatis技术原理与实战]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
